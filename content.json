[{"title":"XRCE-DDS源码阅读（epromisa实现）","date":"2022-03-17T06:18:00.000Z","path":"2022/03/17/XRCE-DDS源码阅读（epromisa实现）/","text":"XRCE-DDS源码阅读（epromisa实现）XRCE-DDS源代码的阅读和感悟 MICRO-XRCE-DDS-CLIENT源码结构忽略编译后生成的build文件和其他cmake配置文件，可以得到从GitHub上下载的源码目录如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748.├── CMakeLists.txt├── colcon.pkg├── CONTRIBUTING.md├── CTestConfig.cmake├── Dockerfile├── docs│ ├── Client.png│ └── General.png├── examples│ ├── ContinuousFragment│ ├── CustomTransports│ ├── Deployment│ ├── Discovery│ ├── Discovery_try│ ├── MultiSessionHelloWorld│ ├── PingAgent│ ├── PublishHelloWorld│ ├── PublishHelloWorldBestEffort│ ├── PublishHelloWorldP2P│ ├── ReplyAdder│ ├── RequestAdder│ ├── ShapesDemo│ ├── SubscribeHelloWorld│ ├── SubscribeHelloWorldBestEffort│ ├── SubscribeHelloWorldP2P│ ├── TimeSync│ └── TimeSyncWithCb├── include│ └── uxr├── LICENSE├── PLATFORM_SUPPORT.md├── QUALITY.md├── README.md├── src│ └── c├── test│ ├── case│ ├── memory│ ├── transport│ └── unitary├── toolchains│ ├── CMakeLists.txt│ ├── nuttx_toolchain.cmake│ ├── nuttx_toolchain.cmake.in│ └── raspberrypi_toolchain.cmake├── tree.txt└── VERSIONING.md 其中，显然include和src以及example文件夹下的文件对我们比较重要。example中有大量的示例程序，包括发现、可靠发送/接收消息等等。include中包含了XRCE-DDS定义的所需要的头文件。src下面则包括了最主要的实际实现代码 其中src的框架如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980.├── c│ ├── core│ │ ├── log│ │ │ ├── log.c│ │ │ └── log_internal.h│ │ ├── serialization│ │ │ ├── xrce_header.c│ │ │ ├── xrce_header_internal.h│ │ │ ├── xrce_subheader.c│ │ │ ├── xrce_subheader_internal.h│ │ │ └── xrce_types.c│ │ └── session│ │ ├── common_create_entities.c│ │ ├── common_create_entities_internal.h│ │ ├── create_entities_ref.c│ │ ├── create_entities_xml.c│ │ ├── object_id.c│ │ ├── read_access.c│ │ ├── session.c│ │ ├── session_info.c│ │ ├── session_info_internal.h│ │ ├── session_internal.h│ │ ├── stream│ │ │ ├── common_reliable_stream_internal.h│ │ │ ├── input_best_effort_stream.c│ │ │ ├── input_best_effort_stream_internal.h│ │ │ ├── input_reliable_stream.c│ │ │ ├── input_reliable_stream_internal.h│ │ │ ├── output_best_effort_stream.c│ │ │ ├── output_best_effort_stream_internal.h│ │ │ ├── output_reliable_stream.c│ │ │ ├── output_reliable_stream_internal.h│ │ │ ├── seq_num.c│ │ │ ├── seq_num_internal.h│ │ │ ├── stream_id.c│ │ │ ├── stream_storage.c│ │ │ └── stream_storage_internal.h│ │ ├── submessage.c│ │ ├── submessage_internal.h│ │ └── write_access.c│ ├── profile│ │ ├── discovery│ │ │ ├── discovery.c│ │ │ └── transport│ │ │ ├── udp_transport_datagram_freertos_plus_tcp.c│ │ │ ├── udp_transport_datagram_internal.h│ │ │ ├── udp_transport_datagram_posix.c│ │ │ ├── udp_transport_datagram_posix_nopoll.c│ │ │ └── udp_transport_datagram_windows.c│ │ └── transport│ │ ├── custom│ │ │ └── custom_transport.c│ │ ├── ip│ │ │ ├── ip_freertos_plus_tcp.c│ │ │ ├── ip_posix.c│ │ │ ├── ip_windows.c│ │ │ ├── tcp│ │ │ │ ├── tcp_transport.c│ │ │ │ ├── tcp_transport_freertos_plus_tcp.c│ │ │ │ ├── tcp_transport_internal.h│ │ │ │ ├── tcp_transport_posix.c│ │ │ │ └── tcp_transport_windows.c│ │ │ └── udp│ │ │ ├── udp_transport.c│ │ │ ├── udp_transport_freertos_plus_tcp.c│ │ │ ├── udp_transport_internal.h│ │ │ ├── udp_transport_posix.c│ │ │ ├── udp_transport_posix_nopoll.c│ │ │ └── udp_transport_windows.c│ │ ├── serial│ │ │ ├── serial_transport.c│ │ │ └── serial_transport_posix.c│ │ └── stream_framing│ │ ├── stream_framing_protocol.c│ │ └── stream_framing_protocol.h│ └── util│ ├── ping.c│ ├── time.c│ └── time_internal.h MICRO-XRCE-DDS-AGENT相关线程agentthread由Agent_instance单例调用函数创建并启动。 负责解析命令后启动agentserver。 agentserver是一个继承自Server类的子类，可以是多个类型，跟传输方式有关，UDP、TCP等。 Server类是一个继承Agent和SessoinManager类的子类。 agentserver启动主要负责三件事，一件事初始化server（主要是网络编程，使用poll进行IO复用），一个是初始化input_scheduler设置队列大小和优先级大小，以及初始化output_scheduler。最后一件事是负责初始化五个线程，这五个线程的作用会在下面讲解。 input_scheduler和output_scheduler消息包packet的处理借助于类PacketScheduler，这个类包含了两个map类型的成员变量，一个key是优先级，value是一个队列，存放待处理的packet；另一个key是优先级，value表示队列的大小。这里其实是一个高优先级先调度的模型。 error_handler_thread处理错误的线程 一个条件循环函数 receiver_loop处理接受消息的线程 线程启动后从传输中接受input_packet包，然后将接受的消息放入input_scheduler调度器，将不同的消息放入不同优先级的队列。 sender_loop处理发送消息的线程 从output_scheduler中取出优先级最高的队列的队首元素，通过send_message发送出去。 processing_loop处理调度器中的消息的线程 从inputscheduler中取出优先级最高的队列的队首元素，交给processor来进行处理。 processor_对象是Processor类的对象。该类统一处理所有的packet消息。会根据inputpacket消息的sessionid来确定消息要交由root\\处理还是根据clientKey来确定消息交给client来处理。 交由client处理的消息实际是又交给了client自己的session中指定sessionID的队列，根据session的sessionID队列messages_来依次进行处理message。 处理inputmessage的过程就是不断看是否有下一条submessage，然后读取submessage，根据submessage的类型与内容，和DDS进行交互，如有数据回馈则将数据填充组成output_packet，返回给server\\的output_scheduler，最后将交互结果返回给上一层。 处理过inputmessage后，考虑对于可靠流的消息，要组织acknack子消息。将acknack消息构成一个output_packet，交付server\\的output_scheduler 如果client不存在 还要处理delete子消息的返回。 heartbeat_loop让processor_检查心跳信号，就是构造心跳信号进行发送，完毕后陷入休眠，休眠结束继续检查，不断循环","tags":[{"name":"DDS","slug":"DDS","permalink":"https://zijian.wang/tags/DDS/"},{"name":"研究方向","slug":"研究方向","permalink":"https://zijian.wang/tags/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://zijian.wang/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"对MQTT的形式化分析和建模","date":"2021-12-30T10:18:00.000Z","path":"2021/12/30/对MQTT的形式化分析与建模/","text":"一篇对MQTT发布订阅协议的形式化工作 MQTT简述一个消息发布订阅协议 MQTT3.1.1控制包类型 CONNECT 客户端在建立和服务端的链接后发送的第一个数据包。服务端收到两个时说明违反协议断开连接 CONNACK 服务端对CONNECT的一个确认链接请求的回复。是服务端发到客户端的第一个包。如果客户端等待这个包超时，则客户端关闭连接。 PUBLISH 发送消息 PUBACK 当存在QoS时，会对PUBLISH进行确认 PUBREC QoS 2 对PUBLISH包的确认 PUBREL 对PUBREC的回复 PUBCOMP 对PUBREL的回复 SUBSCRIBE 客户端发出 创建一个subscriptions，注册一个或多个客户端感兴趣的话题。同时该消息会注明对于该subscriptions，服务端可以向客户端发送消息的最大QoS。 SUBACK 对SUBSCRIBE的确认，并处理该包 UNSUBSCRIBE 取消订阅。 UNSUBACK 对UNSUBSCRIBE的确认 PINGREQ 表明client依旧活跃，或测试网络连接依旧存活 PINGRESP 对PINGREQ的回应，表明服务端依然存活 DISCONNECT 客户端最后发送来断开连接的。 QoS的等级 QoS 0（最多一次传输）—— 发送者发送PUBLISH，接收者接受消息 QoS 1 （最少一次传输）—— 发送者发送PUBLISH和一个未使用的包标识符，必须收到接收者回复的PUBACK才视作PUBLISH发送成功。 另一方面，接收者必须回复一个PUBACK包，且对所有传入的含有相同包标识符的PUBLISH数据包进行这样的对待 QoS 2 发送者和QoS2的发送类似。但是除此之外，他必须在收到PUBREC时回复PUBREL。接收者对PUBLISH的回复是PUBREC，接收 PUBREL 时，它不能导致重复的消息被传递，它必须通过发送包含与 PUBREL 相同的包标识符的 PUBCOMP 包来响应 PUBREL 包。 非形式化表述两部分，其一是链接与断开连接，其二是发布与订阅 形式化建模半形式化建模就是UML建立类图和序列图 基于PTA的形式化建模没有概率的模型对代理的建模 subscriber端的建模 publisher端的建模 ​ B12的环是检测链接是否还在 ​ 当收到client的PUBLISH的时候，进入结束接收l，发送pub_broc信号进入B8````` 对Subscription、Unsubscription和Connection的建模 有概率和时间的模型对Subscriber建立的概率模型 对Publisher建立的概率模型 SMC和概率时间自动机解决了可达性和安全性因空间爆炸不可判定的问题 验证的性质","tags":[{"name":"研究方向","slug":"研究方向","permalink":"https://zijian.wang/tags/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/"},{"name":"论文阅读","slug":"论文阅读","permalink":"https://zijian.wang/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"形式化验证","slug":"形式化验证","permalink":"https://zijian.wang/tags/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81/"}]},{"title":"git学习","date":"2021-12-13T02:20:22.000Z","path":"2021/12/13/git学习/","text":"git版本控制，若干个版本构成一个history，git本质是对history的snapshot的记录 简单模型：线性模型、 123graph TD; G1--&gt;G2; G2--&gt;G3 git参照的模型：DAG（有向无环图）,允许某个snapshot有多个父亲 12345graph TD; G1--&gt;G2; G2--&gt;G3; G2--&gt;G4; G3--&gt;G4; snapshot在git中定义为：一堆文件和目录的集合 文件就是blob（一堆字符），目录就是tree（其实是一个map），目录既可以包含tree也可以包含blob。 1234567891011// 文件type blob = array&lt;byte&gt;// 目录type tree = map&lt;string,tree|map&gt;// 提交 committype commit = struct&#123; parents:array&lt;commit&gt; author:string message:string snapshot:tree&#125; 上述伪代码表示了git的模型，这三种类型在git中统称为objects 1234567type object = blob | tree | commitobjects = map&lt;string, object&gt;def store(object): id = sha1(object) objects[id] = objectdef load(id): return objects[id] objects本质是使用了sha1的哈希， SHA-1对人并不友好，所以定义了references（main、master等）作为指向SHA-1的指针。 12345references = map&lt;string, string&gt; //前者是master··· 后者是SHA1值def update_reference(name,id): references[name] = iddef read_reference(name): return reference[name] Staging Area是一个git的优化 生成新的snapshot时使用此区域，放着在commit时记录到snapshot里的东西，这一部分需要手动增加。 commandBasic git hlep git init: 新开始一个项目，建立仓库 git status：查看这个仓库的状态 git add \\: 如果不执行，增加或更改的文件会显示为Untracked files后跟红色文件名 git commit: 如果不执行，新add的文件会显示Changes to be committed 后跟绿色文件名，然后git commit -m “XX”后就添加进去了 这里本质是创建了一个新的snapshot，生成新的历史 git commit -m “info” 将stage（暂存区）中的内容提交到本地仓库 加上提交信息，比如一些描述 git commit -m “info” -s 提交信息中自动附带个人签名和邮箱 git commit -am “info” 将正在追踪的文件（tracked file）提交到stage（暂存区），然后进行提交到本地仓库。 相当于git add . &amp;&amp; git commit -m “info” git commit —amend 修改最近一次commit的message。 git log git checkout [commit_id] 回滚 id根据git log 看到 git diff \\&lt;文件名> 使用在add前，可以看到做了哪些修改 git提交的基本格式（以Linux为例） 第一行：git提供命令生成的邮件名 第二行：描述explain 每行有限量 第三行：个人签名 signed-off-by 真实姓名 邮箱 默认加”-s”就行。 分支在调试bug时加上一些log之类的。 git checkout -b [新的分支命令] git branch 查看当前所在分支 合并 git merge \\ git rebase branch1 branch2 将branch2的整条分支整理到branch1的末尾 git rebase —onto branch1 branch2 branch3 把branch2分出来的branch3挪到branch1上,相当于branch3不再和branch2有关而是和branch1相关 git rebase —onto branch~M branch~N branch 将branch上的N~M个commit删除掉 修改 git commit —amend 修改最近一次commit的message。 不改变其他属性 git reset HEAD \\ 将误add的文件从stage中除去 git checkout — \\ 将文件回滚到branch的初始状态。 高级主题 git blame ： 找到bug到底是是谁写的。 git stash push/pop/list ：将当前正在做的东西放到一个临时的地方、或者取回、或者看都有哪些再放 .gitignore ： 将一些生成的中间文件不用放到仓库里 Object files *.o *.a *.dep Build &amp; install directories build/ installs/ Development friendly files tags 常用主题 git config 高级自定义 git clone —depth=1 最近版本，浅克隆，不含完整的版本历史信息 git add -p 交互式暂存 git rebase -i 交互式rebase git stash 临时删除对工作目录的修改 git bisect 二分查找历史","tags":[{"name":"工具使用","slug":"工具使用","permalink":"https://zijian.wang/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"git","slug":"git","permalink":"https://zijian.wang/tags/git/"}]},{"title":"对ROS2的DDS的形式化分析","date":"2021-12-01T10:18:00.000Z","path":"2021/12/01/对ROS2的DDS的形式化分析/","text":"一篇对ROS2的DDS的形式化分析 模型组成模型由下述五部分组成： 节点、发布缓存、订阅缓存、DDS缓存、传输信道 概念过程表示概念和过程表示如下： 节点——N1，N2····· 发布缓存——Pn——bp[n] 订阅缓存——Sn——bs[n] DDS缓存——bds 传输信道——bc DDS收集信息——Publishing Interfacce ——数据从bp[n]到bds DDS分发数据——Subscribing Interface——数据从 bc到bs[n] 信道中的数据丢失概率——pn 论文特点优先级问题：论文使用的是非抢占式优先级 PTA（概率时间自动机）是一个对有限自动机在时间和概率上的一个扩展 各模块详细建模A.节点模块 状态集（PTA中是Location）：Init、Send_wait、Receive 不变式：true、无、t&lt;=TRH（接受和处理消息的最大时间） 迁移： 变量：时钟变量t、临时存储的发送消息：tmp_pub、publisher的buffer : bp、subscriber的buffer bs B. Publishing Interface 模块 状态集： Init、Collect 不变式：true、t&lt;=TCH 变量：时钟变量t、DDS的buffer bds collect时优先级高的pb[n]先进行收集，如果bds满了就删除buffer中第一条消息 C. 数据分发模块 状态集：Init、 根据数据类型不同，有5个其他状态、PUB（发布注册）、UNP（取消发布）、SUB（订阅注册）、UBS（取消订阅）、DAT（普通消息） 不变式：true、t&lt;=TNH(*4),t&lt;=TDH 变量：时钟变量t、publish表pub、subscribe表sub、传输信道的buffer bc D. Subscribe Interface模块状态集：Init、Match、Distribute 不变式：true、无、t&lt;=TTH 变量：sub表中和bc[0]的topic对应的 sub[j]、sub[j]的nodeID tmp1、bs[tmp1]的当前大小（新消息存放位置） temp2，时钟变量t、概率p[i] 其中涉及的数据结构消息：一个结构体，包含node_id、type、消息内容 bds：一维队列，存放的是消息 sub表和pub表：一维数组，存放的是消息 bc：一维队列，存放的是消息 bs和bp：二维数组，第一维表示某一个节点的publisher或subscriber（也就是消息的node_id），然后数组存放单元为消息 性质提取与统计分析安全性 无死锁 活性 Nn可以到达Send_Wait位置 高优先级节点平均有更高的概率来先发送数据 低优先级的节点的pb满的概率比高优先级节点的pb满的概率大 低优先级节点的pb空的概率比高优先级的节点小","tags":[{"name":"DDS","slug":"DDS","permalink":"https://zijian.wang/tags/DDS/"},{"name":"研究方向","slug":"研究方向","permalink":"https://zijian.wang/tags/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/"},{"name":"论文阅读","slug":"论文阅读","permalink":"https://zijian.wang/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"name":"形式化验证","slug":"形式化验证","permalink":"https://zijian.wang/tags/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81/"}]},{"title":"时间自动机","date":"2021-10-19T02:45:22.000Z","path":"2021/10/19/时间自动机/","text":"对《Principles of Model Checking》一书时间自动机部分的翻译。 （不全） 时间自动机到目前为止，我们遇到的逻辑是在描述转移系统（Transition System）如何从一种状态演变到另一种状态的转换系统上进行解释的。但是，没有涵盖时间方面。也就是说，既没有给出状态的停留时间，也没有给出在特定时间间隔内进行转换的可能性的指示。然而，诸如设备驱动程序、咖啡机、通信协议和自动取款机等反应式系统（reactive system）必须及时做出反应——它们是时间关键（Time-critical）的。时间关键的系统的行为通常受到相当严格的时序约束。对于火车交叉口，必须在检测到火车接近时，在一定时间内关闭闸门，以便在火车到达交叉口之前停止汽车和行人的通行。对于放射机来说，癌症患者接受高剂量放射的时间段极为重要；这段时间的小幅延长是危险的，可能会导致患者死亡。 简而言之： 时间关键的系统的正确性不仅取决于计算的逻辑结果，还取决于结果产生的时间 由于对于反应式系统来说，及时性是至关重要的，因此必须保证满足系统的时间约束。检查时间约束是否满足是这一章节的主题。为了表达这样的时间限制，策略将被扩展到允许表达时间顺序的逻辑形式（logical formalisms），以及定量时间的概念。这些扩展允许时间约束表达，如： “交通灯将在接下来的30秒内变绿“ 首先要做的选择是时域（time domain）：它是离散的还是连续的？ 离散时域在概念上很简单。 转移系统用于对时间系统（timed system）进行建模，其中假设每个动作持续一个时间单位。更一般的延时可以用一个专用的不可观察的动作，$\\tau$（对于每个tick），来建模。动作$\\alpha$持续$k&gt;1$时间单位的事实可以用$k-1$个跟着$\\alpha$的（或$\\alpha$之前的）滴答动作来建模。这个经典的方法导致了非常大的转移系统。请注意，在此类模型中，任何一对动作的最小时间差都是提前固定的时间单位的倍数。对于同步系统（synchronous），比如，其中涉及的过程以锁步（lockstep）的方式进行，离散时间领域是合适的：一个时间单位对应一个时钟脉冲。在这种情况下，可以使用传统的时间逻辑表达时序约束。下一步操作可以被用来“”度量“过去时间的描述，即，$\\bigcirc \\Phi$表示了$\\Phi$在确切的一个时间单位后满足。通过定义$\\bigcirc^{k+1}\\Phi=\\bigcirc^k(\\bigcirc\\Phi)$和$\\bigcirc^0\\Phi=\\Phi$,通常的时间约束可以被指定，通过简写$\\diamondsuit^{\\leq k}\\Phi=\\bigcirc^0\\Phi \\vee \\bigcirc \\Phi \\vee \\dots \\vee \\bigcirc^k\\Phi$，上述对交通灯的非形式化的时间状态描述可以表示为： \\Box(red \\Rightarrow \\diamondsuit^{\\leq 30}green) \\nonumber对于同步系统，可以使用 LTL 或 CTL 等转移系统和逻辑来表达时序约束，传统的模型检测算法可以使用。 在这本书中，我们不想将自己限制在同步系统中，而是将像在牛顿物理学中一样考虑具有连续性的时间。 也就是说，非负实数（集合$\\mathbb{R}_{\\geq0}$ ）将被用作时域。 一个主要优点是不需要预先确定最小时间单位，因为连续时间模型对时间尺度的变化是不变的。 这对于异步系统更合适，例如分布式系统，其中组件可能以不同的速度运行，并且比离散时间模型更直观。 没有附加时序信息的异步系统的转换系统表示确实太抽象了，无法充分模拟时序约束，如下面的示例所示。 示例 9.1. 一个铁路交叉口 考虑一个铁路交叉路口，正如示例2.30（50页）一样，如示意图9.1所示。对于这个铁路示意图，需要开发一个控制系统，在收到一个火车靠近的信号时关闭闸门，收到火车完全通过道路时打开闸门。控制系统应该成立的安全性质是当火车穿过道路时，闸门应该总是关闭的。完整的系统组成包括三个组件：火车、闸门和控制器。 火车 || 闸门 || 控制器 回想一下，一对进程共有的动作需要联合（jointly）执行，而其他动作则是自主（autonomously）执行的。这些进程的转移系统表示如图9.2所示。它遵循组合系统（composite system） 火车||闸门||控制器 不能保证当火车通过交叉口时闸门是关闭的。这可以通过检查组合转移系统的一个初始片段轻松的看到；观察图9.3——在发出“”靠近“信号之后，火车是在闸门关闭前到达道路还是之后到达道路，都无法从转移系统中推断出来。 然而，再假设火车不会超过某个确定的最大速度的情况下，一个信号“接近”和火车已经到达十字路口的时刻之间的时间段的下界，是可以指示的，如图9.4所示。假定火车在发出“接近”信号后，需要至少2分钟到达路口。据此，对控制器和闸门进行了时序假定。在获得“到达”信号是，1分钟后，控制器将会通知放下闸门，闸门确切的关闭时间被家丁不超过1分钟。全局状态中的分支$$可以用时序信息来标注： 火车在超过两分钟之后仅仅可以执行状态迁移$near\\xrightarrow{enter} in$。另一方面，闸门在收到“接近”信号之后最多两分钟被关闭。因此，全局状态迁移 \\xrightarrow{enter} \\nonumber永不会出现。因此，闸门在火车到达交叉路口前总是关闭的。只要火车在交叉路口，闸门就保持关闭状态的事实通过动作raise仅仅会在火车指示exit后发生的事实得到确认。 根据时间关键系统的形式化建模，时间自动机的概念已经得到发展，这是一种具有测量时间流逝的时钟变量的转移系统（事实上是一个程序图（program graphs））的扩展。这个模型包括对状态和动作的的停留时间施加约束的方法。 9.1 时间自动机时间自动机对时间关键系统的行为进行建模。时间自动机实际上是一个程序图，它配备了一组有限的实值时钟变量，简称为时钟。时钟不同于通常的变量，因为它们的访问是有限的：时钟只能被查看，以及重置为零。时钟可以重置为零，然后随着时间的推移，它们开始隐式增加它们的值。所有时钟都以速率 1 运行，即在 d 个时间单位过去后，所有时钟都前进 d。因此，时钟的值表示自上次重置以来已经过去的时间量。时钟可以直观地被视为秒表，可以相互独立地启动和查看。时钟值的条件用作动作的使能条件（即$guard$）：只有满足条件才能使能并能够采取动作；否则，该操作将被禁用。依赖于时钟值的条件称为时钟约束。为简单起见，假设启用条件仅取决于时钟而不取决于其他数据变量。 时钟约束还用于限制可能在某个位置花费的时间。 以下定义规定了如何定义时钟约束。 定义 9.2：时钟约束根据语法形成对时钟集合 $C$ 的时钟约束 ： g::= xc\\ |\\ x\\geq c\\ |\\ g \\land g \\nonumber其中，$c\\in \\mathbb{N}$且$x\\in C$。令$CC(C)$表示$C$上的时钟约束集合。 不包含任何连词的时钟约束是原子性的。 让$ ACC(C)$ 表示 $C $上所有原子时钟约束的集合 时钟约束通常以缩写形式书写，例如，$(x\\geq c_1)∧ (x&lt;c_2) $可以缩写为$ x \\in [c_1, c_2) $或 $c_1 \\leq x&lt;c_2$。 可以以稍微复杂一点的理论为代价添加时钟差约束，例如$ x−y&lt;c$。 为简单起见，这里省略了它们，我们将讨论限制在原子钟约束上，将时钟与常数$ c \\in \\mathbb{N} $进行比较。如果允许 c 为有理数，则模型检查问题的可判定性不受影响。 在这种情况下，每个公式中的有理数都可以通过适当的缩放转换为自然数。 一般来说，我们可以将每个常数乘以出现在所有时钟约束中的所有常数的最小公倍数。 直观地说，时间自动机是一个（稍作修改的）程序图，其变量是时钟。 时钟用于制定系统行为的实时假设。 时间自动机中的边用$guard$（何时允许选取该边？）、动作（选取该边时执行什么？）和一组时钟（要重置哪些时钟？）来标记。一个位置（location）配备了一个不变量，用于限制可能在该位置花费的时间。 正式定义是： 定义9.3： 时间自动机一个时间自动机是一个八元组$TA = (Loc,Act,C,\\hookrightarrow,Loc_0,Inv,AP,L)$，其中 $Loc$是位置(location)的有限集合 $Loc_0 \\subseteq Loc$是初始位置的集合 $Act$是动作的有限集合 $C$是时钟的有限集合 $\\hookrightarrow \\subseteq Loc \\times CC(C) \\times Act \\times2^C\\times Loc$是转移关系的集合 $Inv:Loc\\rightarrow CC(C)$是一个不变的赋值函数 $AP$是一个原子属性的有限集合 $L:Loc\\rightarrow2^{AP}$是对位置(location)的标签函数 $ACC(TA)$表示了发生在$TA$的$guard$或者位置不变量中的原子时钟约束 时间自动机是具有有限时钟集$C$的程序图。边用元组 $(g,\\alpha, D)$ 标记，其中$g$是对时间自动机时钟的时钟约束，$\\alpha$是一个动作，而$D \\subseteq C$ 是一组时钟。$\\ell \\xhookrightarrow{g:\\alpha,D}\\ell’$的直观解释是时间自动机可以在时钟约束$g$满足的的情况下从一个位置$\\ell$移动到另一个位置$\\ell’$。此外，当从位置$\\ell$移动到$\\ell’$时，$D$中的所有时钟都将重置为零并执行动作$\\alpha$。函数$Inv$为每个位置分配一个位置不变量，指定时间自动机可以在那里停留多长时间。对于位置$\\ell$ ，$Inv(\\ell)$限制了可能在$\\ell$中花费的时间量。也就是说，位置应该在不变的$Inv(\\ell)$失效之前停留。如果这是不可能的——因为没有启用传出转移——就不可能有进一步的进展。在定义9.11中的时间自动机的形式语义中，这种情况可能导致时间进程停止。由于时间进度不再可能，这种情况也称为死锁。 稍后将更详细地讨论这种现象。 函数$L$具有与转换系统相同的作用，并将在该位置有效的原子命题集与任何位置相关联。 在考虑对时间自动机的精确解释之前，我们先举几个简单的例子 为了描绘时间自动机，我们采用如下的程序图的绘制约定。 不变量在位置内标识，当它们等于真时被省略。 边标有$guard$、动作和要重置的时钟集。 空时钟集经常被省略。 这同样适用于始终为真的时钟约束。 时钟组$D$的复位有时由$reset(D)$ 表示。 如果动作不相关，则省略它们 实例9.4 $Guards$和位置不变量图 9.5(a) 描绘了一个简单的时间自动机，它有一个时钟$x$和一个配备自环的位置$\\ell$。 如果时钟$x$ 值最少到达2，则可以采用自循环，并且在采用时，时钟$x$被重置。 最初，默认时钟$x$的值为 0。 图 9.5(b) 通过描述时钟$x$的值与自从自动机启动以来经过的时间，给出了这个时间自动机的执行示例。 每次时钟重置为 0 时，自动机都会遍历位置$\\ell$处的自循环。 由于$Inv(\\ell) = true$，居于$\\ell$中的时间可以不受任何限制地前进。 尤其是这个自动机的合法行为是将无限期地停留在位置$\\ell$上。形式化地， Loc=Loc_0=\\{\\ell\\},C=\\{x\\},\\ell \\xhookrightarrow{true:x\\geq2,{x}}\\ell, 且Inv(\\ell)=true \\nonumber 标签和动作被省略。 通过在位置$\\ell$中加入位置不变性$x\\leq 3$, 稍微改变图 9.5(a) 的时间自动机，会导致$x$不再无边界的前进的效果。 相反，如果$x\\geq 2$ ($guard$) 和$x\\leq 3$ (不变式)，则必须进行传出转移。 请注意，没有指定在区间$[2, 3]$ 中的哪个时刻进行转换，即，这是不确定的。 时间自动机及其行为示例分别如图 9.5(c) 和 (d) 所示。 观察到在将图 9.5(a) 中的$guard$加强为$2\\leq x\\leq 3$ 的同时保持$Inv(\\ell) = true$ 时不会获得相同的效果。 在这种情况下，传出转换只能在$2\\leq x\\leq 3$ 时进行（如前一场景中），但不是强制采用的，即，可以通过在停留$\\ell$期间让时间流逝而简单地忽略它。 这在图 9.5(e) 和 (f) 中进行了说明。 简而言之，不变量是强制转换的唯一方法 。 实例 9.5 闸门的时间自动机 考虑铁路道口的闸门（见例 9.1）。 假设降低闸门最多需要一个时间单位，升门需要至少一个和最多两个时间单位，过程Gate的时间自动机如图 9.6 所示。我们有$Act={lowder,raise}$和 Loc = \\{up,comingdown,down,goingup\\} \\nonumber且$Loc_0={up}$。时间自动机的转移为： up \\xhookrightarrow{true:lower,\\{x\\}}comingdown \\ \\ \\ comingdwon \\xhookrightarrow{true:\\tau,\\varnothing} down \\\\ down \\xhookrightarrow{true:raise,\\{x\\}} goingup \\ \\ \\ goingup \\xhookrightarrow{x\\geq 1:\\tau,\\varnothing} up \\nonumber带有不变式$x\\leq 1$的位置$coming\\ down$已被添加到模型中，该模型在动作$lower$发生和位置$down$改变之间的最大延迟至多是单个时间单位。 时钟$x$在动作$lower$发生时设置为零，从而“测量”自该事件发生以来的时间流逝。 通过将$coming\\ down$的停留时间限制为$x\\leq 1$，必须在一个时间单位内切换到$down$。 请注意，这不会通过在带有$guard$ $x\\leq1$ 的位置$up$和$down$之间建立直接的边来建立，因为$x$的值不会指代$lower$的发生时间 。以类似的方式，具有不变式$x\\leq2$ 的位置$going\\ up$的目的是模拟打开阀门最多需要两个时间单位。 在初始位置$up$处，对停留时间没有限制，即$Inv(up) = true$。 这同样适用于位置$down$。 令$AP = {up, down}$，标记函数 $L(up) = { up }，L(down) ={ down }，L(comingdown) = L(goingup) = \\varnothing$。 备注 9.6 位置图(Location Diagram)时间自动机的每个有限行为都可以用位置图表示。 这描绘了直到某个先验固定上限的每个时刻，时间自动机在该行为期间的位置。 对于阀门的定时自动机，一个可能的实时行为由图 9.7 中的位置图指示。 时间自动机的并行组合对于复杂系统的建模，允许并行组合定时自动机很方便。这允许建模以组合方式对时间关键系统进行分析。 我们考虑一个并行组合算子，记为$||_H$ ，它用一组handshanking动作$H$参数化。这个算子在精神上类似于转换系统上的相应算子； 参见定义 2.26:$H$中的动作需要由两个相关的时间自动机共同执行，而$H$之外的动作则以交错方式自主执行。 时间自动机的握手假设$TAi = (Loc_i,Act_i,C_i,\\hookrightarrow_i,Loc{0,i},Inv_i,AP_i,L_i),i=1,2$是一个时间自动机，$H\\subseteq Act_1 \\cap Act_2，C_1 \\cap C_2=\\emptyset,且AP_1 \\cap AP_2 = \\emptyset$。时间自动机$TA_1 |_H TA_2$可被定义为： (Loc_1 \\times Loc_2,Act_1 \\cup Act_2,C_1 \\cup C_2,\\hookrightarrow,Loc_{0,1}\\times Loc_{0,2},Inv,AP_1\\cup AP_2,L)其中$L(&lt;\\ell_1,\\ell_2&gt;) = L_1(\\ell_1)\\cup L_2(\\ell_2)$且$Inv(&lt;\\ell_1,\\ell_2&gt;)=Inv_1(\\ell_1)\\and Inv_2(\\ell_2)$。 转移关系","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://zijian.wang/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"模型检测","slug":"模型检测","permalink":"https://zijian.wang/tags/%E6%A8%A1%E5%9E%8B%E6%A3%80%E6%B5%8B/"}]},{"title":"ROS2 Executors上的处理链的响应时间分析和优先级分配","date":"2021-10-01T12:09:30.000Z","path":"2021/10/01/ROS2的Executors上的处理链的响应时间分析和优先级分配/","text":"摘要ROS（机器人操作系统）是近年来最受欢迎的机器人软件开发框架。安全有关领域的机器人软件往往受制于硬实时的约束，所以设计者必须形式化建模和分析他们的时间行为，来保证运行时实施约束始终兑现。这篇论文研究了ROS2中的处理链（processing chain）的实时调度和分析，ROS2就是ROS主要考虑了实时能力的第二个版本。首先，论文研究了ROS2 Executors上的处理链的响应时间分析。论文展示了这个问题唯一存在的结果就是共同考虑乐观和悲观，并且开发了新的技术来定位这些问题，显著地提升了分析精度。然后，论文揭示了一个执行器（Executor）上的一个处理链的响应时间仅仅取决于他的最后的调度实体（callback）,这个实体以非常少的设计代价为设计者提供了很有用的指导，不仅提升了响应时间的边界，也提升了系统实际的最差情况/平均响应时间。最后，论文使用随机生成的工作量和一个在真实ROS2平台上的样例研究来评估和证明了研究的结果。 介绍 ROS是当今最受欢迎的机器人软件开放框架，它的主要理念是通过促进软件的模块化和可组合行来推动机器人软件的开发。主要的缺点就是因此导致的缺乏实时能力。这也限制了ROS的广泛传播 ROS2是2017年基于ROS推出的二代版本。ROS2继承了ROS的成功的概念并做了一定的发展，然后最主要考虑的就是对强的实时能力的支持，比如ROS集成了DDS作为进程间实时数据交换通信的中间件，且可以基于实时操作系统上，而不是仅仅在Linux上进行运行，从而可以支持实时安全资源在控制导向代码路径上的预配置。 虽然ROS2的架构提供了好的基础，但是其本身对硬实时的支持依然不够显著。对于硬实时系统，设计者必须验证系统时间性质，以及保证时间约束在运行时所有场景都能得到保证。《Response-Time Analysis of ROS 2 Processing Chains Under Reservation-Based Scheduling》这篇论文在ROS2中的处理链的分析和形式化建模方面进行了开创性的工作。在特定情况下，那篇论文对ROS2执行器（ROS2中多路复用计算任务的一个核心组件）的工作量结构（workload structure）和调度策略进行了建模，并且发明了用来对ROS2执行器处理链响应时间限制上界的技术。这篇论文揭示了ROS2执行器的调度行为是完全不同于过去实时调度研究，并且需要新的分析技术。这篇论文的高层次视角和特殊的成果已经在ROS社区引起了直接的影响，并潜在的触发了实时调度和ROS社区之间的更近的交互来支持分析ROS2硬实时保证。 除了它的重要性，引文中的工作有一些问题： 引文中ROS2执行器处理链（引文中被称作subchains）的响应时间边界既是乐观的（边界可能比实际最坏情况更小）也是悲观的（边界通常不必要大于实际的最坏情况）。我们将会讨论在第四节这些问题的细节。 本文有两大贡献 通过为ROS2执行器的处理链开发新的响应时间分析工具解决了上述引文的问题。新的分析工具通过深度探索ROS执行器内部的调度行为，显著地提升了分析精度。随机生成的工作负载的实验评估表明本文新的响应时间边界始终优于引文，并且具有明显的差距。 本文研究了回调优先级分配是如何影响ROS2执行器处理链的响应时间的，就作者们所了解，之前的工作还没有解决过这一问题。本文揭示了处理链的响应时间仅仅取决于处理链中最后一次回调的优先级：分配给对最后一个回调的优先级越高，处理链的潜在响应时间就会越短。这个性质将会帮助ROS2应用开发者来提升系统的反应能力，不仅仅是对硬实时系统的响应时间上界，也包括软实时和通常系统的实际最坏和平均响应时间，且仅仅消耗很少或者不需要额外的设计开销。我们使用随机生成的工作负载和一个实际基于ROS2机器人软件系统的样例研究模拟实验来证明我们的发现的作用。 相关工作学术界意识到ROS中缺乏实时能力，着手在这方面进行提升。有的在ROS调度和数据交换中加入优先级机制，有的为了更好的实时表现在实时操作系统上运行实时节点。有的发明了实时调度框架，有的提出了关于透明的CPU/GPU协调机制的实时ROS扩展。然而这些研究仅仅提升了实时系统的能力，但是并不能保证任何分析实时保证。对于ROS2，有两篇论文实验评估了在不同潜在条件的实时操作系统和不同DDS实现下的ROS2，但是都基于测量而没有考虑形式化建模和分析。 据文章所知道的，唯一对ROS2执行器的时间行为进行形式化建模和分析的工作就是《Response-Time Analysis of ROS 2 Processing Chains Under Reservation-Based Scheduling》。然而，正如同上文所提到的，引文中对处理链的响应时间分析既是乐观的，也是悲观的。 基于链的任务模型时序分析的实时调度研究已经存在很多工作，根据任务的激活方式可以分为两类，一类被称作触发链（trigger chains），也就是一个前驱任务触发后继任务的释放；另一类被称为数据链（data chains）,也就是任务独立的被触发，也因此可能导致过采样或欠采样。广义上讲，ROS2执行器上的处理链在本文考虑属于触发链类。然而，ROS2执行器的调度行为是非常不同于先前的研究的，且不存在已有的分析技术可以应用在我们的问题。 系统建模 图1(a)展示了ROS2的架构。ROS2应用通常包括的组件有独立的互相之间通过发布订阅机制进行通信的节点（node）。节点会就话题（topic）发布信息（message），这些信息会广播给所有订阅了话题的节点。节点对到来的信息作出回应的方式就是通过回调（callback）来处理每条信息。为了部署ROS应用，独立的节点分布在各个主机上，并被映射到操作系统进程中。ROS2客户端库中的执行器（Executors）协调操作系统进程中的节点的回调执行。ROS2提供了两种内置的执行器，一种是顺序的，以单线程执行回调；另一种是并行的，在多线程之间分配挂起回调的处理。本文主要致力于单执行器上一个链的响应时间边界的计算。尽管如此，和引文相同，本文可以通过组合性能分析（CPA）方法轻松地将结果扩展到跨多个执行器的链的端到端响应时间分析。 A. 工作负载模型我们在一个ROS2的执行器上考虑一个系统$\\Gamma$，该系统包括了一系列独立的处理链（或者短的链），$\\Gamma = {C,C’,C’’\\dots}$。每一个系统$\\Gamma $中的链$C$（$C\\in \\Gamma$）都包含了一个回调有序序列，即$C={C{tm},C_1,\\dots,C{|C|}}$。$C{tm}$是一个定时器（timer）回调，后面跟着的是常规（regular）回调$C_1,\\cdots,C{|C|}$，其中$|C|$表示链$C$中常规回调的数量。最后的常规回调$C{|C|}$被链的槽（sink）回调调用。除了明确指定，本文惯例使用$C={C{tm},C1,\\dots,C{|C|}}$来表示目前正在分析的链，叫做分析链（analyzed chain），使用$C’={C’{tm},C’_1,\\dots,C’{||C’||}}$来表示任意其他链，叫做干扰链（interfering chain），也就是和C竞争资源的链。本文使用$e(C)$表示链$C$完整的WCET（最坏情况执行时间）: e(C) = e(C_{tm})+\\sum_{z=1}^{||C||}e(C_z) \\nonumber其中$e(C{tm})$是定时器回调$C{tm}$的WCET，$e(C_z)$是第$z$个常规回调WCET，其中$1&lt;=z&lt;=|C|$。 一个链会在每次它的定时器回调收到一个外部事件时发布链实例（chain instances）。我们使用$C^i$表示链$C$的第$i$个实例，也就包含了对应的回调实例$C^i={C^i{tm},C^i_1,\\dots,C^i{|C|}}$。当$C^i{tm}$完成了执行后，$C^i{tm}$会产生一个消息来触发$C^i_1$，然后以此类推触发$C^i_2、C^i_3\\dots$。链$C$的发布模式（即外部事件到其定时器回调的到达模式）以到达曲线（arrival curve）$\\alpha_C(\\Delta)$表示，该曲线限制了在$\\Delta$长度内的任意时间间隔中链$C$释放的链实例的数量。本文使用 \\bar{\\alpha_C}(x) = inf\\{\\Delta : \\alpha_C(\\Delta)\\ge x\\} \\nonumber来表示$\\alphaC(\\Delta)$的伪逆函数（pseudo-inverse function），即，链C的$x$个被释放的连续实例的任何时间间隔的长度下界为$\\bar{\\alpha{C}}$。 本文的模型允许$e(C_{tm})=0$，也就是说链$C$可以没有定时器回调。这是为了建模一种情况，即应用程序只有端到端处理链的一部分被分配到了考虑的执行器，如图1-(b)所示。 链实例$C^i={C^i{tm},C^i_1,\\dots,C^i{|C|}}$的响应时间（response time）指的是它的发布时间和它的槽回调实例$C^i_{|C|}$的完成时间之间的时间。链的最坏情况的响应时间指的是所有的实例的响应时间中的最大值。本文的目标就是为系统$\\Gamma$中的每个链C的最坏情况响应时间计算出一个安全的上界。 B. 资源模型和引文一样，本文假定$\\Gamma$在ROS2中的一个单线程执行器上执行，它的资源预留通过供给边界函数（supply bound function）$sbf(\\Delta)$标识，这个函数为执行器的可用处理链的数量规定了下界。本文使用 \\bar{sbf(x)} = sup\\{\\Delta : sbf(\\Delta)\\mu'-1 \\\\ 0,& 其他 \\end{cases}引理 6 的证明在附录中给出。 证明思路与引理 5 类似。 它们的不同在两个方面 (i) 干扰链的常规回调次数可能与被分析链不同（而在引理 5 中，被分析链实例和对干扰有贡献的实例来自同一链，因此具有相同数量的常规回调） (ii) 来自干扰链的实例和被分析的链实例之间的释放顺序可能与其常规回调实例执行的顺序不同（而在引理 5 中，两个被考虑的链实例来自同一链，它们的释放顺序和开始执行它们的常规回调实例的顺序是一致的）。 接下来我们要固定$\\gamma’$的值。引理7将展示$\\mathcal{W’}(\\gamma’,t_3)$相对于$\\gamma’$是非减的，引理8将说明$\\gamma’$的值的上界。因此我们可以通过设置$\\gamma’$的上界得到$\\mathcal{W’}(\\gamma’,t_3)$的上界。 引理 7 $\\mathcal{W’}(\\gamma’,t_3)$是一个对$\\gamma’$的非减函数 证明：首先使用$x=j-\\gamma’$重写$\\mathcal{W’}(\\gamma’,t_3)$： \\mathcal{W'}(\\gamma',t_3)=\\sum^{\\alpha_{C'}(t_3)-\\gamma'}_{x=1}(e(C'_{tm})+e(C'_{\\mu'})\\cdot \\varepsilon'+\\sum^{min(\\mu'-1,\\|C'\\|)}_{z=1}e(C'_z)) \\\\ \\mu'=\\|C\\|-x \\\\ \\varepsilon' = \\begin{cases} 1,& C'_{\\mu'} \\in hp(C_{\\|C\\|})\\land \\|C'\\|>\\mu'-1 \\\\ 0,& 其他 \\end{cases} \\nonumber更进一步定义 \\xi(x)=e(C'_{tm})+e(C'_{\\mu'})\\cdot\\varepsilon'+\\sum^{min(\\mu'-1,\\|C'\\|)}_{z=1}e(C'_z) \\nonumber通过定义$\\xi(x)$，我们能观察到$\\xi(x)\\leq e(C’)$(直觉上看，$\\xi(x)$表示$t_3$时刻前干扰链$C’^{\\gamma’+x}$执行的回调实例的工作负载，也就无法大于完整链的所有WCET)。 给定任意$\\gamma’_1\\leq \\gamma’_2$，我们可以得到 \\mathcal{W'}(\\gamma'_2,t_3)-\\mathcal{W'}(\\gamma'_1,t_3) \\\\ =\\gamma'_2\\cdot e(C')+\\sum^{\\alpha_{C'}(t_3)-\\gamma'_2}_{x=1}\\xi(x)-(\\gamma'_1\\cdot e(C')+\\sum^{\\alpha_{C'}(t_3)-\\gamma'_1}_{x=1}) \\\\ = (\\gamma'_2-\\gamma'_1)\\cdot e(C')-(\\sum^{\\alpha_{C'}(t_3)-\\gamma'_2}_{x=1}-\\sum^{\\alpha_{C'}(t_3)-\\gamma'_1}_{x=1}) \\\\ =(\\gamma'_2-\\gamma'_1)\\cdot e(C')-\\sum^{\\alpha_{C'}(t_3)-\\gamma'_2}_{x=\\alpha_{C'}(t_3)-\\gamma'_2+1}\\xi(x) \\\\ \\geq(\\gamma'_2-\\gamma'_1)\\cdot e(C')-(\\gamma'_2-\\gamma'_1)\\cdot e(C') \\ \\ \\ \\ \\ (\\because\\xi(x)\\leq e(C')) \\\\ =0 \\nonumber这样就证明了。 引理 8 $t_2$是满足下列公式的最小正值的上界： \\chi(\\delta) = sbf(\\delta) \\\\ where \\chi(\\delta) = \\alpha_C(\\delta)e(C_{tm})+(i-1)\\sum^{\\|C\\|}_{z=1}e(C_Z)+\\sum_{C' \\in \\Gamma \\backslash \\{C\\}}\\alpha_{C'}(\\delta)e(C')证明：通过反证法证明，假设$t*$是公式(6)的最小解，且$t&lt;t2$，那么在$[0,t]$窗口中，执行的工作负载包括三部分： 被分析链$C$在$[0,t*]$窗口内释放的定时回调实例的工作负载。该窗口内释放的数量最多为$\\alpha_C(t)$，所以他们的工作负载上界为$\\alpha{C}(t)e(C_{tm})$ 被分析链$C$在$[0,t*]$窗口内成为就绪状态的常规回调实例。由于$C^i$的第一个常规回调在$t_2$时刻开始执行，且$t&lt;t2$，所以在$[0,t]$之间就绪的常规回调实例都属于$C^i$之前的链实例。这些链实例的数量最多为$i-1$个，所以对应的工作负载的上界就是$(i-1)\\sum^{|C|}_{z=1}e(C_z)$ 干扰链在$[0,t*]$窗口内释放的实例的的工作负载。对于每一个干扰链$C’$，在$[0,t]$中释放的实例的数量最多为$\\alpha{C’}(t)$。因此，所有的干扰链在$[0,t*]$窗口内释放的实例的上界表示为$\\sum{C’\\in\\Gamma\\backslash{C}}\\alpha{C’}(t*)e(C’)$ 总的来说，在$[0,t*]$窗口内执行的工作负载上界可以用$\\chi(t)$表示。另一方面，在$[0,t_]$窗口内可用资源最少为$sbf(t*)$。由于$\\chi(t)=sbf(t_)$，且在$[0,t*]$窗口内可执行的工作负载最多为$sbf(t)$，所以所有由$t_$准备好的工作负载都将由$t*$完成。这和$t*$是忙碌期间中的一个时间点的事实相违背（回忆一下我们正在研究忙碌期的链C的第i个实例，且执行器一定在$[0,t_3]$窗口内是忙碌的。 我们可以重写公式6为$\\delta=\\bar{sbf}(\\chi(\\delta))$，并使用众所周知的不动点迭代技术来找到最小的正值解。 结合引理6、7、8，可以得到引理9： 引理 9： 一个干扰链$C’$在$[0,t3]$窗口期内执行的工作负载上界表示为$\\mathcal{W}’(\\alpha{c’}(\\bar{t_2}),t3)$，其中$\\bar{t_2}$是公式（6）中$\\delta$的最小解 响应时间边界的计算 到目前为止，本文已经获得了被分析链和每个干扰连的工作负载的上界，并指出了系统在$[0,t_3]$中完整的工作负载。另一方面，$sbf(t_3)$给出了$[0,t_3]$中可获得资源的下届。因此我们可以通过下述引理，得到$t_3$的上界： 引理10： $t_3$是满足下述等式的最小正值的上界： \\mathcal{W}(\\delta)+\\sum_{C'\\in \\Gamma \\backslash\\{C\\}}\\mathcal{W'}(\\alpha_{C'}(\\bar{t_2}),\\delta)=sbf(\\delta)其中，$t_2$是引理8公式6中的最小解。 形式化证明略。直观的，公式7的左值右值对于$\\delta$来说是非减的，且他们的第一个交点给出了一个时间点的上界，该交点表示在被分析链实例不大于可用资源之前，将要被执行就绪的工作负载，所以被分析链实例的槽回调实例可以开始执行。类似于公式（6），公式（7）也可以使用$\\bar{sbf}$进行重写，并使用不动点迭代技术来找到它的最小正解。 最终，被分析链实例$C’$的响应时间边界将由下述引理计算： 引理 11： 链实例$C^i$的响应时间上界表述为： R(C^i) = \\bar{sbf}(sbf(\\bar{t_3})+e(C_{\\|C\\|}))-\\bar{\\alpha_C}(i)其中，$\\bar{t_3}$是引理10中的公式7的最小解。 证明：令$tf$代表$C^i{|C|}$的结束时间，那么$C^i$的响应时间就是$t_f-t_i$($t_1$就是$C^i$的释放时间)。 $[0,t_3]$中完整的工作负载的上界为 \\mathcal{W}(t_3)+\\sum_{C'\\in\\Gamma\\backslash{C}}\\mathcal{W'}(\\alpha_{C'}(\\bar{t_2}),t_3) \\nonumber由于$t_3\\leq\\bar{t_3}$，上界也可表述为 \\mathcal{W}(\\bar{t_3})+\\sum_{C'\\in\\Gamma\\backslash{C}}\\mathcal{W'}(\\alpha_{C'}(\\bar{t_2}),\\bar{t_3}) \\nonumber还可以表述为$sbf(\\bar{t_3})$，其中$t_3$是公式7中的一个解。 因此，$[0,tf]$中完整的工作负载上界为$sbf(\\bar{t_3})+e(C{|C|})$。因为$\\bar{sbf}(x)$规定了完成工作负载$x$时间总和的上界，我们可以得到： t_f\\leq\\bar{sbf}(sbf(\\bar{t_3})+e(C_{\\|C\\|}))另一方面，$\\bar{\\alpha_C}(i)$限制了被链释放的链$C$的$i$个实例的时间间隔的长度的下界，所以$t_1\\geq\\bar{\\alpha_C}(i)$。结合公式(9)，引理得证。 引理 12： 令$\\bar{\\Delta}$作为满足下述等式的$\\Delta$的最小正值： \\sum_{C'\\in\\Gamma}\\alpha_{C'}(\\Delta)\\cdot e(C')=sbf(\\Delta)那么在忙碌期内，被被分析链$C$释放的实例数量的上界为$\\alpha_C(\\bar{\\Delta})$。 形式化证明略。 直观的看，公式10的左值给出了一个时间间隔内整个被释放的系统的整个工作负载上界，右值给出了在该时间间隔内整个可获得资源的下界。如果这个时间间隔的整个工作负载没有超过整个可获取的资源，忙碌期一定要结束，因此，$\\alpha_C(\\bar{\\Delta})$给出了链$C$在忙碌期释放的实例数量的上界。类似于公式（6）和公式（7），可以使用$\\bar{sbf}$重写公式（10），并且应用不动点迭代技术找到最小正值解。 最终，通过对$[1,\\alpha_C(\\bar{\\Delta})]$中的每个$i$应用引理11，并取得最大值，我们就可以得到C的最差情况响应时间的上界。 定理 1： 系统中一个任意的链的最坏响应时间的上界表示为： R(C)=max\\{R(C^i) | 1\\leq i \\leq \\alpha_C{\\bar{\\Delta}}\\}其中$\\bar{\\Delta}$是引理12中公式（10）的最小解。 优先级分配本节中论文研究了优先级分配如何影响一条链的响应时间。本文发现，在工作负载中，被分析链的上界（引理5）和干扰链的上界（引文6），唯一取决于回调优先级的因素是检查和被分析链的实例的槽回调实例$C^i{|C|}$在同一个处理窗口的回调实例是否具有比$C^i{|C|}$更高的优先级（这取决于公式2中的$\\varepsilon$以及公式5中的$\\varepsilon’$）。因此，定理1中的响应时间边界仅仅被被分析链的槽回调函数的优先级所影响：优先级越高，潜在响应时间边界越低，但是不取决于其他回调的相对的优先级。下面，本文将展示上属性值不仅适用于我们的响应时间边界，也适用于实际的系统行为。 引理 13： 在每个处理器窗口中，执行的不同优先级分配下回调实例集合是完全相同的。 证明：本文考虑了系统的一个随机释放序列，在所给序列中，每个链实例的释放时间和每个回调实例的实际执行时间是固定的。每个繁忙时段的长度在不同优先级分配下不会改变，因此我们将我们的注意力限制在任意一个繁忙时间段。首先看繁忙时段的第一个处理窗口$pw_1$：只有$pw_1$中定的时器回调实例在$pw_1$中执行，且它们都在$pw_1$的末未结束，所以在$pw_1$中执行的回调实例在不同的优先级分配下是相同的（在$pw_1$末尾的轮训点处被加入到就续集$\\Omega$的就绪回调实例在不同优先级分配下也是相同的。）接下来我们证明该引理在其他繁忙时段的处理器窗口中也是成立的。 使用反证法证明，假定在一些处理器窗口中执行的回调实例在两种优先级分配$\\Phi$和%$\\Phi’$下是不同的。使用$pw_n$和$pw_n’$来分别代表在优先级分配$\\Phi$和%$\\Phi’$下所考虑的繁忙时段的第$n$个处理窗口。 让$pw_m$作为第一个与其对应的$pw_m’$具有这种不同的处理器窗口。我们假设$C^i_z$表示最早的（释放时段内）导致这种差别的回调实例，不失一般性的，我们假定$C^i_z$在$pw_m$窗口中执行，而没有在$pw_m’$中执行（当然这同样可以证明相反的情况）。我们首先展示$C^i_z$不是一个常规回调实例。一个常规回调实例$C^i_z$当且仅当满足下述两条条件时，才在$pw_m$中执行： 前驱$C^i{z-1}$已经在窗口$pw{m-1}$的末尾完成 所有同一个回调$Cz$以前的实例都已经在$pw{m-1}$的末尾完成。 由于$pwm$是被执行回调实例集合中第一个不同于对应的$pw_m’$的执行窗口，$C^i{z-1}$和所有$C{z}$的前面的实例都在$pw{m-1}’$的结尾完成了，所以$C^iz$也会在$pw_m’$中执行。因此$C^i_z$不能使常规回调实例，所以他一定是一个定时器回调实例（所以下面我们称呼$C^i_z$为$C^i{tm}$）。我们将会展示这也是矛盾的。 证明略 定理 2： 链实例的响应时间只受其接收器回调的优先级影响（优先级越高，潜在响应时间越短），而不依赖于系统中其他回调的相对优先级顺序。 证明略。 定理 2 表明，从响应时间上限（对于硬实时系统）以及实际最坏情况和平均响应时间（对于软实时系统和一般系统）的角度来看，提升槽回调的优先级总是有益的。 在 ROS2 中，回调的优先级由两个级别决定： (1) 回调类型：不同的回调类型具有不同的优先级。 正如我们的模型中所定义的，定时器回调比任何常规回调具有更高的优先级。 实际上，常规回调进一步分为三种类型：订阅者（subscriber）、服务（service）和客户端（timer）。 总的来说，四种回调类型的优先级顺序是 timer \\succ subscriber \\succ service \\succ client其中$\\succ$代表拥有更高的优先级。 (2) 注册顺序：同类型回调的优先顺序取决于它们注册到执行器的顺序：越早注册，优先级越高。 由于上面提到的优先级层次结构，并不总是可以将槽回调的优先级提升到最高。 尽管如此，开发者可以通过在相同类型的回调中尽早注册来在相同的回调类型中授予尽可能高的优先级，这在实践中基本上是一个无成本的优化选项。 还可以通过修改应用程序设计来执行更积极的优化。 例如，由于三种常规回调类型的主要区别在于触发执行的方式，因此在某些应用程序中可以更改回调的类型（将槽回调提升为更高优先级的类型，或者将其他类型的回调降级为低优先级类型的回调）。 对需要修改应用程序的优化机会的得失进行彻底调查超出了本文的范围，将在我们未来的工作中考虑。 评估在本节中，我们首先对随机生成的工作负载进行实验，以实证评估我们提出的响应时间分析技术的性能改进以及通过提升接收器回调优先级对我们的最坏情况响应时间限制的影响，并使用案例研究来证明优先级优化对观察到的最坏情况和平均情况响应时间的好处。 实验评估本文对执行器的$sbf(\\Delta)$使用TDMA模型：$sbf(\\Delta)=(\\lfloor\\Delta’/c \\rfloor\\cdot s+min(\\Delta’mod \\ c,s))\\cdot b$，其中$\\Delta’=max(\\Delta-C+s,0)$。在实验中，我们设$c=10,s=8,b=1$。用下述方法随机初始化系统$\\Gamma$：系统的总利用率在$[0.1, 0.8]$中随机选择，链的数量在$[2, 5]$中随机选择，每条链的第一个回调有 1/3 的概率是定时器回调。 每个链$C$的到达曲线按照$PJD$模型生成：$\\alpha_C(\\Delta) = min(\\lceil (\\Delta+J)/P\\rceil,\\lceil \\Delta/D \\rceil)$，其中$P,J,D$分别在$[60, 100], [0, 2P ] 和[1, P − 1]$中随机选择。然后我们将系统的总利用率分配给各个链。 第一条链的利用率是从 $[0.02, 2U/3] $中随机选择的，其中 $U $是系统的总利用率。然后我们通过减去第一条链的利用率来更新剩余的总利用率$ U$。 然后我们从$ [0.02, 2U/3] $中随机选择第二条链的利用率，并通过减去其利用率再次更新$ U$。重复这个过程，直到只剩下一条链，然后我们将所有剩余的利用率分配给它。 接下来，我们通过与上述类似的过程将每个链的利用率分配给其各个回调。回调获取其利用率的顺序对应于它们在链中的优先顺序，并且在每个分配中最多分配剩余利用率的 1/2。 每个回调的 WCET 是通过将其利用率乘以相应链的周期$P$（四舍五入到最接近的整数）来计算的。 系统中所有回调的优先级顺序是随机决定的，受定时器回调（链的第一个回调）比任何常规回调具有更高优先级的约束。我们产生10000个系统，对于每个系统，我们比较通过以下方法得到的响应时间估计： $\\mathrm{OUR}$：由定理 1 得到的响应时间界限。 $\\mathrm{OUR}*$：与$\\mathrm{OUR}$相同，但将接收器回调的优先级提升为该链所有常规回调中的最高优先级（通过将其优先级与该链中最高优先级的常规回调切换） $\\mathrm{EX}$：通过引文中的分析获得的响应时间界限。 $\\mathrm{SIM}$：系统模拟中观察到的最大响应时间，假设所有链同时释放第一个实例，每个链尽快释放实例，每个回调实例执行到 WCET。 模拟持续到繁忙时段结束。 $\\mathrm{SIM}$ 的结果是实际最坏情况响应时间的下限，但仍为评估我们方法的精度提供了有用的信息。 $\\mathrm{SIM}^$：与 $\\mathrm{SIM}$ 相同，但使用与$\\mathrm{OUR}$相同的方法将接收器回调的优先级提升为该链的所有常规回调中的最高优先级 图 5 显示了按不同参数（x 轴）分组的实验结果。 每张图中，五条曲线是上述五种方法得到的平均响应时间估计值（左边y轴对应的数值）。曲线上的每个结果是所有生成系统的所有链的平均响应时间估计，该特定参数落在对应于每个 x 轴的范围内（5-(d) 和 (e) 除外，其中 x 轴值是离散的）。例如，图5-(a)中x轴上的值0.3表示利用范围$[0.25,0.35)$。 在图 5-(d) 到 (f) 中，结果仅包括总利用率在$ [0.55, 0.65] $范围内的系统。这是因为根据这些数字的 x 轴进行分组与系统总利用率具有很强的相关性。例如，具有更多链的系统通常具有更高的总利用率。 因此，我们只评估固定利用率范围内的系统，以更好地揭示关于这些参数的结果趋势。在每个图中，我们还报告了由 $\\mathrm{EX}$ 获得的至少一个链的响应时间估计小于$\\mathrm{SIM}$的系统的比率，由直方图表示（对应于右 y 轴的值）。在这些情况下， $\\mathrm{EX}$ 的结果一定是不安全的，因为$\\mathrm{SIM}$给出了实际最坏情况响应时间的下限。从图 5 中的结果我们可以看到，我们的新分析方法在不同的参数设置下始终以显着的优势优于$\\mathrm{EX}$ 。 通过提高接收器回调的优先级，获得的响应时间界限得到改善（平均提高 5% - 8%）。 样例评估该案例研究由部署在 ROS2 的 Eloquent Elusor 版本（2019 年 11 月 22 日发布）中的单线程执行器上的三个处理链组成，运行在具有内核 5.4.0-48-generic 的 Ubuntu 18.04.5桌面版本上，使用 Intel i7-9700F CPU@3.00 GHz 和 16 GB 总内存（一个内核用于运行此 ROS2 执行器）。 进程内通信用于在每个链上的回调之间发布/订阅消息。 每个链都以一个由系统计时器触发的计时器回调开始，并且具有固定的周期。 表 I 给出了链和回调的简要说明。 ACET 和 WCET 列是 10,000 次运行中每个回调的平均和最坏情况观察执行时间。 表 II 报告了在不同优先级分配下每个链的平均和最坏情况观察响应时间，如表 III 所示。 在每个优先级分配下，我们运行系统 20 分钟。 “I”是默认的优先级分配，“II”在 C 中切换两个非接收器常规回调的优先级。我们可以看到，这种优先级调整不会导致平均/最坏情况观察到的响应时间发生显着变化。 在优先级分配“III”中，我们将每个链中接收器回调的优先级切换为该链中最高优先级的常规回调，这导致平均和最坏情况观察响应时间的明显改善。 我们在案例研究中观察到的一个有趣现象是，尽管在我们的模型（也是引文中的模型）中，如果某个消息在处理窗口中产生，则必须在处理窗口结束时在轮询点（polling point）考虑，现实中并非总是如此。由于 ROS 中的信息传播延迟，在某些情况下，消息实际上无法在该处理窗口的末尾赶上轮询点。 当信息跨不同内核传播时，这种延迟更为显着。 由于这种行为偏离了我们假设的模型，我们有意将其排除在上述实验之外。为此，一方面，我们不仅在单个核上运行所考虑的执行器，还将整个 ROS2 堆栈运行，以避免核间信息传播，另一方面，我们分析了实验的执行日志（ 周期和抖动设置略有不同），并确保报告的结果不包含此类不需要的行为。虽然在本文中我们没有进一步深入研究这一现象，但为了使本文的理论成果在实践中适用，确实需要认真解决这个问题。 例如，本文提出的分析技术可以通过考虑在最坏情况下丢失最近的轮询点导致的额外延迟来扩展。 实际上，由于这种行为可能会增加平均情况和最坏情况的端到端处理延迟，并使系统在时序上更加不可预测，我们认为应该努力改进 ROS 架构以消除这种行为，最少对于实时应用程序来说。 我们将对该问题的进一步调查留给我们未来的工作。 总结与未来工作我们为 ROS2 单线程执行器上的处理链开发了响应时间分析技术，不仅修复了引文中的乐观结果，而且显着提高了精度。我们还证明了一个处理链在一个执行器上的响应时间只取决于它的最后一个回调，通过它设计者可以优化优先级分配，不仅可以提高响应时间上限，还可以提高系统的实际最坏情况和平均响应时间。我们的最终目标是为基于 ROS 的机器人软件系统提供分析时序保证。 这篇论文是朝着这个目标迈出的一小步，但仍然受到许多限制。 下一步，我们会将我们的工作扩展到更通用和更复杂的设置，例如多线程执行器，将每个执行器的分析与通过 DDS 通信引起的延迟的建模和分析相结合，以及改进 ROS 架构以获得更好的时间可预测性效果。（例如，为了避免第 VII-B 部分末尾所述的问题）。 引文：《Response-time analysis of ros 2 processing chains under reservation-based scheduling,》","tags":[{"name":"论文阅读，ROS2","slug":"论文阅读，ROS2","permalink":"https://zijian.wang/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%8CROS2/"}]},{"title":"2021-9-22科研周记","date":"2021-09-23T02:20:22.000Z","path":"2021/09/23/2021-9-22周记/","text":"本周主要阅读了两篇论文，其一是今年2-3月份发表在CCF B类会议DATE上的一篇short paper，题目是《Modeling, implementation, and analysis of XRCE-DDS applications in distributed multi-processor real-time embedded system》。其二是前年11月份发表在CCF C类会议ISPA上的一篇论文《Model checking for the Goal-Feedback-Result Pattern in ROS》。 Modeling, implementation, and analysis of XRCE-DDS applications in distributed multi-processor real-time embedded system摘要发布订阅机制是一种最近许多分布式应用中透明通信的设计模式。DDS是一个基于发布订阅机制的机器对机器的通信标准，旨在保证可靠、高效、互操作且实时数据交换。然而，对资源的高需求限制了DDS在低开销嵌入式系统中的使用。XRCE-DDS是一个基于客户-代理的标准，来使资源受限的小型嵌入式系统连接到DDS全局数据空间中。当前XRCE-DDS实现受限于主机操作系统，目标仅限于单处理器模块，并且缺乏性能分析方法。在这篇论文中，作者在CompSOC平台上实现了XRCE-DDS标准的裸机实现，来作为一个片上多处理器系统（MPSoC）上的一个实例。提出的框架包括一个硬实时XRCE-DDS的Client端和一个软实时XRCE-DDS的Agent端。一个场景感知数据流（SADF）模型被提出来，来捕捉在不同执行场景中系统的动态行为。作者通过使用经过实验验证的马尔可夫模型捕获概率场景切换来分析吞吐量的长期预期值。 主要贡献 在ZYNQ板上的CompSOC平台中实现了XRCE-DDS的裸机实现。客户端在硬实时的RISC-V处理器上实现，Agent跑在软实时的Arm处理器上。多个RISC-V处理器并行运行，每个处理器运行了多个客户端。 使用SADF表示了XRCE-DDS应用的概率模型。提出一个马尔可夫模型来分析长期预期吞吐量 ​ Publisher端的SADF模型 ​ Program这个actor代表的是一个实时程序，使用到了XRCE-DDS的两个接口，也就是Pub_Req和Pub_Res这两个用来publish消息的接口，这里抽象为两个actor。Agent位于Arm处理器上，通过非实时的网络和Client进行通讯，所以消息传输会发生丢失、延迟等概率行为。因此也就设计了多个不同的执行场景。 ​ 途中a和b代表的分别是信道上message的生产和消费速率，此处可以理解a为agent向DDS域成功发送的message。 场景p1代表时限内Agent成功publish了消息到DDS中 场景p2代表虽然经过很长时间（但未超时），但是Agent还是成功publish了消息到DDS中。 场景p3代表超时了，仍然未收到Agent发来的成功response，此时相当于未成功生产，所以a值为0。此时Pub_Res会让实时程序继续工作。 ​ Subscriber端的SADF模型 ​ 这个模型和Publisher其实非常类似。但是可能的场景有4个，同时需要关注的信道有3个，DDS和Agent之间的非实时网络，Sub_Res和实时程序之间的可忍受的失败消息传递信道，以及多次可忍受失败导致的Sub_Res向实施程序下达重启的信道。 场景S1代表正常情况下快速的收到了DDS的消息 场景S2代表经过很长时间（但未超时），Client收到DDS消息 场景S3代表可忍受的消息传递失败，会先让程序继续工作，等待XRCE-DDS的历史变量和流运行完成，将已经收到的消息传递完（因为此时ef都还有消息在传递）。 场景S4代表n次可忍受的消息失败后，就不可忍受了，且此时历史消息已经都结束，那么就下达重启命令 ​ 应用的SADF模型 ​ 将上述两个模型进行结合，再加上实验中的具体数据，得到DDS域进行的时间场景D1,D2和D3，并得到他们的概率。同事在DDS域中的信息丢失与否也被两个场景进行建模为L1,L2。这样单个发布订阅者就存在了24个场景。 ​ 马尔可夫模型的SADF模型 ​ 通过两千万次迭代实验，得到上图的两个马尔可夫模型，然后结合上面对场景D和场景L的值，就可以得到24个大场景中两两转移的概率。从而可以计算预期吞吐量。 在CompSOC平台上的一个网络，进行实验分析了XRCE-DDS的应用 思考 首先这篇论文是对XRCE-DDS的建模分析，但是其本质却是立足于完整的DDS发布订阅机制来进行考量的，而不是针对XRCE-DDS的协议最核心的C-S机制进行建模分析。我觉得这一点是可以考虑学习的。但是还没想好跟ROS1相联系，毕竟ROS1没使用DDS 论文的贡献既然实现了对XRCE-DDS协议的一种实现，且是基于多处理器、嵌入式系统的一个实现，我觉得是一个比较大、比较新的工作量。不过说实话如果不是网络问题一直下载不下来，我觉得我们可能也已经走在这一步的路上了。 这个文章的概率其实解释的都挺笼统，大部分都说是从实验得来，那可能实验就是这样的吧，如果想要进行概率模型检测，无论是模拟还是实际的实验都需要进行统计。 Model checking for the Goal-Feedback-Result Pattern in ROS摘要目标-回馈-结果模式广泛运用于基于机器人操作系统的多任务进程和分布式控制系统的通讯中。随着越来越多的传感器设备和应用在服务机器人中被部署，保证ROS中的GFR通信结构的正确性和可靠性越来越重要。ROS中的GFR通信和任务调度的形式化分析和验证在本文中通过模型检测实现。为了对通信进程和调度策略进行建模，本文设计了客户端进程、服务端进程和调度器的时间自动机。无死锁、可调度和可响应性质使用CTL语言进行了形式化描述，并使用自动模型检测工具进行了自动验证。GFR模式的形式化模型分析和验证提供了一种精化设计模型，并且对避免基于机器人系统应用GFR早期设计阶段的细微错误或者bug很有帮助。 主要贡献模型检测被用于带调度的GFR通信机制的形式化分析和验证。建立了时间自动机来描述通信进程和调度策略。并使用CTL语言描述了无死锁、可调度和可响应等性质，然后使用了UPPAAL进行了自动检测。 关于调度这方面，主要是实现了EDF（最早截止时间）的调度算法。 建立的模型主要构成为三个模块——client、scheduler和server client可以发布目标（goal），也可以取消正在进行的任务 scheduler用来维护一个任务队列，同时负责抢占相关 server用来执行client所布置的、由scheduler交给的goal，并根据时间触发向client汇报执行情况（feedback），当最后任务完成\\终止\\取消后，目标（goal）有结果之后，向client发送result消息。 三者自动机分别如下所示 idle状态就是起始状态，信号goal[id]表示触发的要scheduler调度的任务，数组result[id]=0,ggoal[id]=1,getback[id]=0表示了目标id的结果、feedback等的初始化。 router状态是一个路由状态，此处在等待其他信号的到来，如果scheduler发送了dealit[id]表明要处理任务了，则进入connect这个中间状态再转入active状态，如果scheduler发送了wait[id]信号，则说明任务队列前面还有任务，就需要进入waitit状态进行等待。如果说收到了server发来的finish[id]信号，说明任务已经完成了， 可以回到idle状态了。或者如果收到server发来的canceled[id]信号，说明此时任务已经取消了，同样回到idle状态。 waitit状态需要等待任务队列前面的任务顺利完成或取消后，自己就会有dealit[it]信号通知转入connect中间状态，不停留，直接转到active状态。 active状态存在三种可能的路径 收到了server的信号，任务已经finish了，那就回到idle状态 向server发出信号cancel[id]，通知server任务取消。回到router状态。 来了一个优先级更高的任务由scheduler调度到前面，把自己抢占了，也就是收到了bepreemptedp[id]信号，进入preempted状态等待重新被启用。 preempted状态会等待dealit[id]信号的到来，然后回到active状态。 同时，为了模拟feedback，在goal发出后，未被抢占的三个状态——router、waitit和active状态都会定时发送feedback[id]信号，来得到server执行过程中的信息。getback[id]赋值为1表示等待得到回馈。 idle状态就是起始状态，最开始时Sstatus[front()]为0，当收到scheduler发来的dealit[front()]信号时，将时间t进行初始化，进入deal状态。或者当Sstatus[front()]为2时，说明是在deal状态中被抢占的任务，当收到scheduler发来的dealit[front()]信号时，则不需要对时间初始化，而是需要将Sstatus[front()]初始化，进入deal状态。 deal状态负责处理任务，在这个阶段设计三个概念，最快执行时间、截止时间（DL）和执行时间（ET）。当任务完成后，t超过了DL，则将结果result[front()]赋值为2，表示超市完成，并进入名为outtime的临时状态，然后进入router状态；或者当任务完成时，t大于了执行时间，但是没超过截止时间DL，那么就将result[front()]赋值为3，表示时限内完成任务，进入router状态。同时在此状态还有一种转移情况是当收到scheduler发来的抢占信号bepreempted[e]，就需要将Sstatus[e]赋值为2，表示被强占，进入preempted的临时状态，candeal赋值为1表示下次可以进行下个任务的处理，最后回到idle状态。最后还有一种情况，就是在执行过程中，client不想要再继续执行，向scheduler发送了cancel信号，scheduler就会发来getfinish[front()]信号，此时deal状态就会将result[front()]赋值为1，表示取消任务，然后进入一个临时状态，紧接着进入finised状态 router状态可以理解是一个中间状态，但是很奇怪论文没有给出它的转移guard（可能是抽象掉了），总之它也可以响应scheduler的getfinish[front()]信号，取消放弃任务，将result[front()]赋值为1,进入临界状态然后直接进入finished状态。同时他也会被优先级更高的任务进行抢占，响应抢占信号bepreempted[e]，将Sstatus[e]赋值为1，然后当下一次dealit信号来临时直接转移回router状态。而除此之外的正常情况，他会在这一状态和客户端建立联系，然后进入connect的临时状态，然后顺利进入finished状态。 finished状态是任务已经不再执行的一个状态，一般包含三种任务，一种是被取消掉的，一种是超时完成的，一种是正常完成的，该状态会等待finish[front()]信号，然后回到idle状态。 同client状态对应，在deal状态、router状态以及finished状态，都会对client中的feedback信号进行接受，但是具体处理细节不太相同 ，ideal状态会将feedback[e]被赋值为1表示此时任务还在处理中，然后getback[e]赋值为0表示已进行回馈；router状态会将feedback[e]被赋值为2表示此时任务已处理完成，等待路由的建立，然后getback[e]赋值为0表示已进行回馈；finish状态则会将feedback[e]被赋值为3表示此时任务已结束，然后getback[e]赋值为0表示已进行回馈。 idle状态就是起始状态。如果此时任务队列长度len为0，当client的goal[e]信号到达时，就会将任务e放入任务队列，并将任务e的截止日期赋值给x,并进入一个瞬时状态，然后发出dealit[front()]信号通知server对任务队列队首进行处理；如果队列长度不为0，那么该状态会马上向server发送dealit[front()]信号通知它来处理队首任务。 select状态是最关键的状态。 收到client发来的goal[e]信号，如果该事件的截止日期比x要小，那就要把x更新为该事件的截止日期上限，并进入preempted的瞬时状态，因为该事件显然应该具有更高优先级；然后将此时的队首进行抢占，即向server发送bepreempted[front()]!消息，且将队首任务出队，进入下个瞬时状态，发送dealit[front()]!让server进行下一个队首任务的处理，如果此时candeal为1则赋值为0表示不可以处理下个任务（这里应该是和server做的一个同步操作），然后回到select状态。 如果收到goal[e]信号，新入队的任务的DL比x要大，说明它的优先级不强，放入队尾，向client发出wait[tail()]信号。回到select状态。 如果收到cancel[e]信号，则进入getcancel状态，如果此时dealcancel为0，发送canceled[e]给client，表示已经取消了任务，并出队任务，且将任务e的result改为1表示取消任务，回到select状态。如果dealcancel为1，则需要向server发送getfinish[front()]信号，将dealcancel改为0。进入新状态后，如果收到server的finish[front()]，说明该任务已经取消，则出队队首元素，回到idle状态。 如果收到server的finish[e]，说明该任务已经结束，如果该任务就是队首元素，那么出队队首元素，并进入idle状态。 思考这篇论文跟之前我和师兄做的工作有所关联，都是对ROS进行的建模、验证，区别在于我们将建模的对象放在了发布-订阅机制上，而本文则是将研究重心放在了所谓的GFR机制上，这个GFR机制其实就是ROS1中的action通信。是基于pub/sub和client/service机制的ROS独有机制。根据论文的网址，我们看到确实在相关的库的介绍中，甚至是存在有specification的。 那这确实感觉是一个非常不错的切入点。 这篇论文的建模感觉确实抽象层次挺高，忽略了大部分细节，集中注意力在client、server和scheduler这三个地方，我觉得对scheduler部分的抽象是本文的一个亮点，尤其是将调度器如何执行了EFD调度算法这一部分建立的蛮有新意。但是有一些没有特别看懂，就是被强占的任务的后续处理没看的很明白，因为有一些执行的函数在论文中没有讲。 总结思考如何对前后工作进行联系关于之前的，能不能接着我们之前对ROS1验证的思路往下走，看能不能走到我们的MicroROS上，我缕了一下两者的关系，大概是这样的： ROS1和ROS2作为一二代，互成竞品 ROS1中最常用的和嵌入式部分进行通信的是rosserial包（官方实现有arduino等）。 而到了ROS2中和ROS2进行通信的就是MicroROS了。 要么参考第一篇论文，考虑像它那样，放弃对client-server的模式的底层建模，转而考虑对整体的的建模。然后再想办法加别的工作量。 要么就是围绕ROS2再做一些工作，从而可以过渡到MicroROS上来。问题就是其他人已经做过了对ROS2中DDS的建模了，那可能就还要调研一下到底做什么东西。 建模思路和工作量努力方向的拓展之前的建模思路主要集中在最直接最底层最简单的机制进行建模，然后根据specification和代码细节丰富模型。但实际上太过追求往底层靠进行抽象的话，感觉会忽略掉更具有代表性的独特的机制，就比如ROS1中我们一直在深挖pub/sub机制，但好像往上面一层的action相较而言更具有创新点以及更具有对ROS应用的代表性。 感觉自己可以考虑再跳出来，不考虑实现细节，实现底层，而是协议或者系统最具代表性的层次来抽象建模。 然后就是感觉仅仅靠阅读源码、建立模型，工作量无法支撑好的文章，还是得想办法做模拟、做实现；甚至考虑多环境、多处理器、多平台的实现。同时考虑到第二篇论文对scheduler的建模是一个亮点，再加上XRCE-DDS的Agent端中的Agent类同样继承了一个Scheduler类（不过是FCFS的比较简单的调度），这方面能不能提炼出什么值得深挖实现，然后进行建模的东西呢？","tags":[{"name":"科研周记","slug":"科研周记","permalink":"https://zijian.wang/tags/%E7%A7%91%E7%A0%94%E5%91%A8%E8%AE%B0/"},{"name":"ROS","slug":"ROS","permalink":"https://zijian.wang/tags/ROS/"},{"name":"形式化","slug":"形式化","permalink":"https://zijian.wang/tags/%E5%BD%A2%E5%BC%8F%E5%8C%96/"}]},{"title":"238. 除自身以外数组的乘积","date":"2021-09-17T02:20:22.000Z","path":"2021/09/17/238. 除自身以外数组的乘积（数组）/","text":"238. 除自身以外数组的乘积 题目给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例: 12输入: [1,2,3,4]输出: [24,12,8,6] 提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 主要思路首先应该想到的是使用两个数组，分别存放左乘结果和右乘结果，这样最后两个数组中相同位置的乘积即为除该处元素外的乘积。这是一种$O(n)$的解法 为了保证常数空间复杂度，就需要想办法对空间进行优化。由于输出数组不被视为额外空间，那么我们就可以将输出数组先作为单边乘积数组。 然后另一边乘积数组我们发现其实每次计算只和前一个元素有关系，所以我们使用一个变量来代表。但同时这也意味着我们最终计算时的方向已经确定了。 代码实现123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; // 要求用额外常数级空间 但不计入答案数组 // 所以想办法使用答案数组。 vector&lt;int&gt; ans(nums.size()); // 此处计算的答案数组是左乘结果数组 ans[0]=1; for(int i=1;i&lt;nums.size();i++)&#123; ans[i] = ans[i-1]*nums[i-1]; &#125; // 本来应该有一个右乘结果数组，但为了空间，只能优化掉，用一个变量代表当前右乘结果 int R = 1; // 因为右乘结果不断变化，所以我们从右边算起 for(int i=nums.size()-1;i&gt;=0;i--)&#123; ans[i] = ans[i]*R; R = R*nums[i]; &#125; return ans; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"数组","slug":"数组","permalink":"https://zijian.wang/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"334. 递增的三元子序列","date":"2021-09-17T02:20:22.000Z","path":"2021/09/17/334. 递增的三元子序列（贪心）/","text":"334. 递增的三元子序列 题目给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。 如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。 示例 1： 123输入：nums = [1,2,3,4,5]输出：true解释：任何 i &lt; j &lt; k 的三元组都满足题意 示例 2： 123输入：nums = [5,4,3,2,1]输出：false解释：不存在满足题意的三元组 示例 3： 123输入：nums = [2,1,5,0,4,6]输出：true解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 &lt; nums[4] == 4 &lt; nums[5] == 6 提示： $1 &lt;= nums.length &lt;= 10^5$ $-2^{31} &lt;= nums[i] &lt;= 2^{31} - 1$ 主要思想为什么可以这么贪心。 最开始找到的small和mid是有序的，如果此时下一个数大于mid，说明直接找到，如果大于small，直接刷新small而保持mid不变，此时虽然small和mid已经不再是顺序关系，但是隐含的是存在一个顺序关系（小于mid的前small在mid前面）。 一旦我们更新了mid，则small和mid恢复顺序关系 一旦我们不更新mid，说明mid前面有小于他的前small 那么一旦需要我们发现了比当前mid大的数，显然三个数就找到了。 代码实现12345678910111213141516171819202122232425class Solution &#123;public: bool increasingTriplet(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size();; if(n&lt;3)&#123; return false; &#125; int small=INT_MAX,mid=INT_MAX; for(int i=0;i&lt;n;i++)&#123; // 为什么可以替换？ // 此时可能会出现small &gt; mid的情况, // 但是隐含的条件是mid前面有一个比small还小的数，所以此时在发现一个比mid大的数 一样可以找到三个，不过不是small、mid、第三个数而已。 // if(nums[i]&lt;=small)&#123; small = nums[i]; &#125;else if(nums[i]&lt;=mid)&#123; mid = nums[i]; &#125;else if(nums[i]&gt;mid)&#123; return true; &#125; &#125; return false; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"矩阵","slug":"矩阵","permalink":"https://zijian.wang/tags/%E7%9F%A9%E9%98%B5/"},{"name":"hash","slug":"hash","permalink":"https://zijian.wang/tags/hash/"}]},{"title":"48. 旋转图像","date":"2021-09-17T02:20:22.000Z","path":"2021/09/17/36. 有效的数独（hash）/","text":"36. 有效的数独 题目请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 注意： 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 示例 1： 1234567891011输入：board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出：true 示例 2： 123456789101112输入：board = [[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出：false解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 提示： board.length == 9 board[i].length == 9 board[i][j] 是一位数字或者 ‘.’ 注意事项这道题显然用hash表来做很直接，此时需要注意3*3的块状区域如何计算。 代码实现1234567891011121314151617181920212223242526class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; // 3*9个hash表，分别存每一行、每一列以及每一块的情况 vector&lt;vector&lt;int&gt;&gt; rows(9,vector&lt;int&gt;(10,0)); vector&lt;vector&lt;int&gt;&gt; cols(9,vector&lt;int&gt;(10,0)); vector&lt;vector&lt;int&gt;&gt; blocks(9,vector&lt;int&gt;(10,0)); for(int i=0;i&lt;board.size();i++)&#123; for(int j=0;j&lt;board[0].size();j++)&#123; if(board[i][j]==&#x27;.&#x27;) continue; int k = board[i][j]-&#x27;0&#x27;-1; rows[i][k]++; cols[j][k]++; blocks[i/3*3+j/3][k]++; // 如果大于1说明该行/块/列出现过 if(rows[i][k]&gt;1 || cols[j][k]&gt;1 || blocks[i/3*3+j/3][k]&gt;1)&#123; return false; &#125; &#125; &#125; return true; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"矩阵","slug":"矩阵","permalink":"https://zijian.wang/tags/%E7%9F%A9%E9%98%B5/"},{"name":"hash","slug":"hash","permalink":"https://zijian.wang/tags/hash/"}]},{"title":"560. 和为 K 的子数组","date":"2021-09-17T02:20:22.000Z","path":"2021/09/17/560. 和为K的子数组/","text":"560. 和为 K 的子数组 题目给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。 示例 1： 12输入：nums = [1,1,1], k = 2输出：2 示例 2： 12输入：nums = [1,2,3], k = 3输出：2 提示： $1 &lt;= nums.length &lt;= 2 * 10^4$ -1000 &lt;= nums[i] &lt;= 1000 -10^7","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"hash","slug":"hash","permalink":"https://zijian.wang/tags/hash/"},{"name":"前缀和","slug":"前缀和","permalink":"https://zijian.wang/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"DDS问与答","date":"2021-09-16T02:20:22.000Z","path":"2021/09/16/DDS问答/","text":"整理一些DDS以及DDS-XRCE上的一些思考 DDS SpecificationQ&amp;A Q：DDS位与网络栈的那一层 A：传输层之上，基于TCP、UDP Q：DDS全局数据空间到底在哪里？ A：事实上DDS的全局数据空间并不存在于物理界的某个确定位置，而是一种抽象的概念。事实上是通过DDS发送消息，更新了远程节点上的存储。其本质就是所有DDS中各个应用程序的本地空间的集合。任何系统运行的所有语言的任何应用程序都会以最佳的符合自己格式的方式读取到数据，正是因为数据存在于自己的内存空间。 Q：我从ROS1出发，了解到ROS1的发布订阅是这个样子的：发布者-Master-订阅者，发布者和订阅者通过topic进行对应，该关系是在master节点上的。然后在ROS2中，了解到它使用了去中心化，不要一个单独的Master来维持关系，而是使用DDS进行负责底层消息的传递。那么我就很好奇DDS是如何来做这一步的？DDS有一个所谓的global data domain全局数据空间，但它又一再强调，这个全局数据空间仅仅存在于概念上，那么对于该空间内的所有节点，他们是怎么知道和彼此之间的订阅关系呢？是否代表他们每个节点都要存储网络内所有其他参与者的信息呢？DDS中间件又存在于哪里呢？如果是DDS中间件在控制这个GDD，他们怎么解决同步关系呢？他们是存在于总线上么？（感觉不太可能） A： DDSI-RTPSDDS specification和DDSI-RTPS的关系两者都是DDS规范，前者定义了上层模型，也就是DCPS（以数据为中心的发布-订阅模型），后者通过UDP传输实现best-effort和realiable的通信，主要目的是实现互操作性。他们在结构上应该是有一种上层和底层的关系。 DDS-XRCEDDS-XRCE不是一个类似于DDS的发布订阅机制的通讯协议。而是一个让嵌入式设备端的Client通过DDS域内的一个Agent，通过重用一些DDSI-XRCE协议和DDS Specification中定义的功能，来实现Client在DDS域中发送、订阅消息的功能。 DDS-XRCE的通信协议——我的理解 在一个DDS-XRCE协议中，定义了以上这些概念。 Session是client和agent进行通信的双向链接，是通过一次握手建立的。 stream是独立信息流，管理一批message，是依托于session的 message就是一个信息，由一个messageHeader和一群submessage组成，属于某个stream，message header中，信息由sessionId和streamId标识，每条message在流内有序，由sequenceNr指定流内顺序， clientKey是一个标识，仅仅在0-127号stream（best-effort流）中存在。其目的是为了在best-effort这种情况下使Agent迅速知道message对应来自于哪个client。而在128-256号stream（reliable流）中之所以不存在，则是因为代理已经拥有预制了client的clientKey，不需要确认每条消息是否来自于某个client。（问：如何知道的呢？猜想：应该是在stream建立时就确认了client的clientkey，所以只需要sessionId和streamId就可以确认client） submessage是最直接的具体消息的载体，由submessageHeader和payload组成，前者包括了submessageId来标识submessage的种类（一共有13种），flag来定义内容相关，比如大小端序、以及submessageLength来告知整个submessage的长度。后者就是具体的某种submessage所包括的信息。 想象两个城市隔海相望，为了互通有无，两者互相通了气之后，挖了一个隧道，取名叫Session，然后为了合理运用这个隧道，对隧道进行了分层，比如上层跑车队下层跑地铁，这就是不同的stream。无论哪一种交通工具中，都有一个车头（MessageHeader），车头标注了它是来自于哪个城市（clientKey）、属于哪一个隧道（session）、哪一层（stream），在所有车次中属于哪一车次（sequenceNr）的信息。车头后面跟的就是车厢或者其他跟着车头跑的车（submessage），为了方便统计，这些车厢或者车同样有一个自己的身份证（submessageHeader），包括了他们的类型（submessageId）、负载方式（flags）以及负重（submessageLength），最后当然最重要的是每个车厢和车子都有自己的负载（payload）。 XRCE-DDSQ：CREATE_CLIENT消息是否每次client沉睡唤醒后都需要调用？如果是的话Agent是否知道何时为创建何时为重用？如果不是的话client唤醒后如何发送消息？ A：根据specification的介绍，当create_client操作被触发进行执行时，检索agent端是否存在和client_key对应的ProxyClient，如果存在，则比较ProxyClient的session_id和传入的参数的信息，如果都相同，则不做任何操作，只是将返回状态置为STATUS_OK，否则就需要删除原来的ProxyClient，创建新的ProxyClient，这样导致的后果是之前所有和该proxyClient所绑定的对象全都失效。从这里来看，理论上讲没有必要再每次client沉睡唤醒后都调用。只需要从client端已经存在来的TrasportLocator，来执行和Agent交流的行为就可以了。 Q：CREATE消息创建Object对象时，是否规定了object_id,如果规定了object_id,这个取值从何而来,如何保证全局唯一性？ A：不全是，CREATE操作实际上输入的是objectid_prefix,它是组成objectid的元素而非objectid，它和object_kind共同组成objectid来保证其唯一性，生成的真正的objectid会以create函数的返回值的形式，利用STATUS信息返回给Client。 如何保证唯一性，事实上CREATE的输入还有一个creationMode参数，这个参数有两个布尔值作为成员变量，一个是reuse，一个是replace，再加上构成的objectid，这三者共同决定了是创建object、还是使用object、还是删除已存在的object创建新的object。 Q：XRCE Cookie起到了什么作用？和普通的http连接中的cookie的作用是相同的么？ A：在一般的http通信中，cookie存储在客户端，在会话过程中可以起到对客户端进行标识，让服务端session知道客户端的功能。在XRCE-DDS中，主要用于区分Client的是clientkey这一子消息。所以cookie应当与http中所用的cookie技术不同。鉴于specification中描述，似乎XRCE-DDS中的XRCE-Cookie被锁定为‘X’、‘R’、‘C‘、’E‘，所以估计它的作用主要是用来进行区分协议。","tags":[{"name":"DDS","slug":"DDS","permalink":"https://zijian.wang/tags/DDS/"}]},{"title":"240. 搜索二维矩阵 II","date":"2021-09-15T02:20:22.000Z","path":"2021/09/15/240. 搜索二维矩阵II（减治）/","text":"240. 搜索二维矩阵 II 题目编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例 1： 12输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5输出：true 示例 2： 12输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20输出：false 提示： m == matrix.length n == matrix[i].length 1 &lt;= n, m &lt;= 300 $-10^9 &lt;= matrix[i][j] &lt;= 10^9$ 每行的所有元素从左到右升序排列 每列的所有元素从上到下升序排列 $-10^9 &lt;= target &lt;= 10^9$ 注意要点选取起始点是为了缩减搜索范围，起始点的选择一定要选择一维变大一维变小的。 代码实现12345678910111213141516171819class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int m = matrix.size(); int n = matrix[0].size(); // 选起始点 选一个增大一个减小的。 int i=m-1,j=0; while(i&gt;=0 &amp;&amp; j&lt;n)&#123; if(matrix[i][j]&gt;target)&#123; i--; &#125;else if(matrix[i][j]&lt;target)&#123; j++; &#125;else return true; &#125; return false; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"数组","slug":"数组","permalink":"https://zijian.wang/tags/%E6%95%B0%E7%BB%84/"},{"name":"二分查找","slug":"二分查找","permalink":"https://zijian.wang/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"435. 无重叠区间","date":"2021-09-15T02:20:22.000Z","path":"2021/09/15/435. 无重叠区间（贪心 动规）/","text":"435. 无重叠区间 题目给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 123输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 123输入: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 123输入: [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 关键思路贪心的关键是发现要贪的是排序后的右边界。 代码实现123456789101112131415161718192021222324class Solution &#123;public: int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; if(intervals.size()&lt;2)&#123; return 0; &#125; // 根据右边界排序 sort(intervals.begin(),intervals.end(),[&amp;](const vector&lt;int&gt;&amp; v1,const vector&lt;int&gt;&amp; v2)&#123; return v1[1]&lt;v2[1]; &#125;); // right初始化第一个区间的右边界 int right = intervals[0][1]; int ans=1; // 遍历所有 for(int i=1;i&lt;intervals.size();i++)&#123; // 如果新的区间的左边界大于等于right，就说明该区间可以保留，并且更新right if(intervals[i][0]&gt;=right)&#123; ans++; right = intervals[i][1]; &#125; &#125; return intervals.size()-ans; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"动态规划","slug":"动态规划","permalink":"https://zijian.wang/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心","slug":"贪心","permalink":"https://zijian.wang/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"48. 旋转图像","date":"2021-09-15T02:20:22.000Z","path":"2021/09/15/48. 旋转图像（二维数组）/","text":"48. 旋转图像 题目给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 示例 1： 12输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[[7,4,1],[8,5,2],[9,6,3]] 示例 2： 12输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] 示例 3： 12输入：matrix = [[1]]输出：[[1]] 示例 4： 12输入：matrix = [[1,2],[3,4]]输出：[[3,1],[4,2]] 提示： matrix.length == n matrix[i].length == n 1 &lt;= n &lt;= 20 -1000 &lt;= matrix[i][j] &lt;= 1000 主要思想一切矩阵的旋转，都可以用矩阵的对称翻转来实现。 代码实现1234567891011121314151617181920class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); if(n==0) return; // 左右反转 for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; swap(matrix[i][j],matrix[j][i]); &#125; &#125; // 延主对角线反转 for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n/2;j++)&#123; swap(matrix[i][j],matrix[i][n-j-1]); &#125; &#125; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"矩阵","slug":"矩阵","permalink":"https://zijian.wang/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"59. 螺旋矩阵 II","date":"2021-09-15T02:20:22.000Z","path":"2021/09/15/59. 旋转矩阵II（二维数组）/","text":"48. 旋转图像 题目给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 提示： 12输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2： 12输入：n = 1输出：[[1]] 提示： 1 &lt;= n &lt;= 20 主要思路按层遍历 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt;&gt; matrix(n,vector&lt;int&gt;(n)); int num=1; int left = 0, right=n-1, top = 0, bottom=n-1; while(left&lt;=right &amp;&amp; top&lt;=bottom)&#123; int i= left; while(i&lt;=right)&#123; matrix[top][i] = num; i++; num++; &#125; i=top+1; while(i&lt;=bottom)&#123; matrix[i][right] = num; i++; num++; &#125; i=right-1; while(i&gt;=left)&#123; matrix[bottom][i]=num; i--; num++; &#125; i=bottom-1; while(i&gt;top)&#123; matrix[i][left]=num; i--; num++; &#125; top++; bottom--; left++; right--; &#125; return matrix; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"矩阵","slug":"矩阵","permalink":"https://zijian.wang/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"pintos环境配置与安装","date":"2021-09-14T12:09:30.000Z","path":"2021/09/14/pintos环境配置/","text":"记录关于最新pintos在Ubuntu20.04的环境上，进行安装，并将qemu替换默认的bochs的配置所遇到的问题和解决方案。 简介pintos是斯坦福大学操作系统的一个project。国内很多高校会用这个来作为学生学习操作系统的实验课课程。很多学生反映难度高，耗时长。我导师带着本科生这门课，一是好奇，二是体验一下，并且巩固一下操作系统的知识，所以我也来玩一玩。 pintos默认使用的模拟器是bochs模拟器，由于需要很多的相关的依赖，以及一些更新编译的库，比较繁琐，所以该教程中我们不使用bochs模拟器，改用qemu模拟器。 安装步骤准备工作安装vim、make、gcc、build-essential1234sudo apt-get install vimsudo apt-get install makesudo apt-get install gccsudo apt-get install build-essential 安装qemu-system-x861sudo apt-get install qemu-system-x86 下载pintos可以直接从pintos的git公开仓库中进行下载最新版本，也可以下载老版本。 其中下载新版本在公开仓库中，按下述步骤下载 找到master，并点击它的tree，如图1所示 找到snapshot，点击，保存文件，如图52所示 此处我下载的版本为pintos-anon-master-f685123.tar.gz 为了方便，使用tar的解压命令解压，放到根目录下并更名为pintos 12tar -zxvf pintos-anon-master-f685123.tar.gzmv pintos-anon-master-f685123 ~/pintos 修改一些本地化配置 修改pintos-gdb文件 将路径切换到/home/&#123;username&#125;/pintos/src/utils下。使用vim修改其中的pintos-gdb文件。 主要修改GDBMACROS变量的值。 原值为： 修改为本机上的gdb-macors路径，该路径也在解压的pintos下，具体路径为： 注意一定要填为绝对路径。 ![pintos-gdb修改后](https://gitee.com/zijian98/images/raw/master/img/pintos-gdb%E4%BF%AE%E6%94%B9%E5%90%8E.png) - 修改Makefile 还在当前```utils```路径下，修改```Makefile```文件，只需要改动一个变量的名字就可以，原名为： ![Makefile修改前](https://gitee.com/zijian98/images/raw/master/img/Makefile%E4%BF%AE%E6%94%B9%E5%89%8D.png) 将```LOADLIBES```改为```LDLIBS 编译utils 当前路径下使用make进行默认编译 修改模拟器bochs到qemu 修改Make.vars 修改/home/&#123;username&#125;/pintos/src/threads/的Make.vars文件 主要修改模拟器，修改前为 将bochs改为qemu 结束后可以切换到threads路径下，使用make进行默认编译生成build 修改pintos文件 将路径切换到utils下 使用vim修改pintos文件104行左右代码，将bochs改为qemu，修改前后如图所示 使用vim修改pintos文件260行左右代码，将kernel.bin改为绝对路径。kernel.bin是上一步在threads路径下编译生成的，在编译生成的build文件夹下，路径为/home/&#123;username&#125;/pintos/src/threads/build。修改前后如图所示 使用vim修改pintos文件627行左右代码，将qemu的版本从qemu-system-i386改为qemu-system-x86_64。修改前后如图所示 修改Pintos.pm文件 仍在当前utils路径下，使用vim修改Pintos.pm文件，将loader.bin也更改为绝对路径。loader.bin跟kernel.bin文件一样被编译生成在threads/build/路径下。修改前后如图所示 添加环境变量使用vim修改~/.bashrc，在最后一行加上 1export PATH=/home/&#123;username&#125;/pintos/src/utils:$PATH 如图所示 123```shellsource ~/.bashrc 试运行与make check执行 1pintos run alarm-multiple 会弹出qemu，并有很多信息刷新，最后显示complete，出现如图所示结果： 为了实验一顺利进行，在threads/build路径下进行make check，第一次make check时间消耗很长，需要多等等，最后出现如图所示结果表示成功","tags":[{"name":"操作系统，环境配置","slug":"操作系统，环境配置","permalink":"https://zijian.wang/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"119. 杨辉三角 II","date":"2021-09-14T02:20:22.000Z","path":"2021/09/14/119. 杨辉三角II(数学)/","text":"119. 杨辉三角 II 题目给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 示例 1: 12输入: rowIndex = 3输出: [1,3,3,1] 示例 2: 12输入: rowIndex = 0输出: [1] 示例 3: 12输入: rowIndex = 1输出: [1,1] 提示: 0 &lt;= rowIndex &lt;= 33 注意要点没啥注意的，考察数组知识。这里记录一些可以节约时间、空间的奇淫巧技 最普通做法 二维数组二维数组，模拟铺开 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;vector&lt;int&gt;&gt; yanghui(rowIndex+1); for(int i=0;i&lt;=rowIndex;i++)&#123; // 首先将该层的数组空间申请下来 yanghui[i].resize(i+1); // 初始化两边的1 yanghui[i][0]=yanghui[i][i]=1; // 依次将中间填上去 for(int j=1;j&lt;i;j++)&#123; yanghui[i][j] = yanghui[i-1][j-1]+yanghui[i-1][j]; &#125; &#125; return yanghui[rowIndex]; &#125;&#125;; 两个一维数组二维数组我们可以发现，当前层只跟上一层有关系，那么只记录上一层就可以了 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; pre,cur; for(int i=0;i&lt;=rowIndex;i++)&#123; cur.resize(i+1); cur[0]=cur[i]=1; for(int j=1;j&lt;i;j++)&#123; cur[j] = pre[j-1]+pre[j]; &#125; pre = cur; &#125; return cur; &#125;&#125;; 一个一维数组我们还发现当前层的数只和上一层的该位置的数和前一个位置数有关，那么我们可以不破坏前一个数，倒着更新当前数组。 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; cur(rowIndex+1); // 显然我们需要在循环开始前将最开始的1进行标注 cur[0]=1; // 因为跟i-1相关，所以i要从1开始 for(int i=1;i&lt;=rowIndex;i++)&#123; // 倒着填内容 for(int j=i;j&gt;0;j--)&#123; cur[j] = cur[j]+cur[j-1]; &#125; &#125; return cur; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"数组","slug":"数组","permalink":"https://zijian.wang/tags/%E6%95%B0%E7%BB%84/"},{"name":"动态规划","slug":"动态规划","permalink":"https://zijian.wang/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"162. 寻找峰值","date":"2021-09-14T02:20:22.000Z","path":"2021/09/14/162. 寻找峰值（二分查找）/","text":"162. 寻找峰值 题目峰值元素是指其值严格大于左右相邻值的元素。 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞ 。 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。 示例 1： 123输入：nums = [1,2,3,1]输出：2解释：3 是峰值元素，你的函数应该返回其索引 2。 示例 2： 1234输入：nums = [1,2,1,3,5,6,4]输出：1 或 5 解释：你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 提示： 1 &lt;= nums.length &lt;= 1000 $-2^31 &lt;= nums[i] &lt;= 2^31 - 1$ 对于所有有效的 i 都有 nums[i] != nums[i + 1] 关键思路题目要求了时间复杂度为$O(logn)$。在大多数情况下，这是在暗示想办法使用二分法进行做题。虽然数组无序，但是要求只需要找到一个峰值，且数组边界外为负无穷数，那么我们只需要找到爬坡的方向就最终可以找到峰值。 代码实现1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; int left=0,right=nums.size()-1; // 处理一下越界情况 auto get = [&amp;](int i)-&gt;int&#123; if(i==-1 || i==nums.size())&#123; return INT_MIN; &#125;else&#123; return nums[i]; &#125; &#125;; int mid; // 使用二分的原因是只要找到一个峰值就可以，然后只要有上坡，峰值必能找到。 while(left&lt;=right)&#123; mid = left+(right-left)/2; // 找到峰值 if(get(mid-1)&lt;get(mid)&amp;&amp;get(mid+1)&lt;get(mid))&#123; //cout &lt;&lt; get(mid-1)&lt;&lt; &quot; &quot; &lt;&lt; get(mid+1) &lt;&lt; endl; return mid; &#125; // 根据爬坡来决定接下来去哪里找 if(get(mid)&lt;get(mid+1))&#123; left = mid+1; &#125;else&#123; right = mid-1; &#125; &#125; return mid; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"二分查找","slug":"二分查找","permalink":"https://zijian.wang/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"447. 回旋镖的数量","date":"2021-09-13T02:20:22.000Z","path":"2021/09/13/447.回旋镖的数量（暴力 hash） /","text":"Leetcode 447. 回旋镖的数量 题目描述给定平面上 n 对互不相同的点 points ，其中 points[i] = [xi, yi] 。回旋镖是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。 返回平面上所有回旋镖的数量。 示例 1： 123输入：points = [[0,0],[1,0],[2,0]]输出：2解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]] 示例 2： 12输入：points = [[1,1],[2,2],[3,3]]输出：2 示例 3： 12输入：points = [[1,1]]输出：0 提示： n == points.length 1 &lt;= n &lt;= 500 points[i].length == 2 $ -10^4 &lt;= x_i , y_i &lt;= 10^4 $ 所有点都互不相同 注意要点注意n的范围只有1～500。其实说明是可以进行$O(n)$的暴力计算的。 排列组合公式 A^2_m = m \\times (m-1)当我们使用hash表搞出相同距离的个数时，可以用此公式来计算对的数量 实现代码12345678910111213141516171819202122class Solution &#123;public: int numberOfBoomerangs(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int n = points.size(); int ans=0; // 以p为出发点 for(auto &amp;p:points)&#123; // 记录以p为出发点，各个距离的数量 unordered_map&lt;int,int&gt; hash; // 遍历各个距离 for(auto &amp;q:points)&#123; int dis = (p[0]-q[0])*(p[0]-q[0]) +(p[1]-q[1])*(p[1]-q[1]); hash[dis]++; &#125; // value个节点和出发点距离相同，则里面的相同对有n*(n-1)个 for(auto [_,value] : hash)&#123; ans += value*(value-1); &#125; &#125; return ans; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"hash","slug":"hash","permalink":"https://zijian.wang/tags/hash/"}]},{"title":"524. 通过删除字母匹配到字典里最长单词","date":"2021-09-13T02:20:22.000Z","path":"2021/09/13/524. 通过删除字母匹配到字典里最长单词（排序 双指针 二维DP）/","text":"524. 通过删除字母匹配到字典里最长单词 题目给你一个字符串 s 和一个字符串数组 dictionary 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。 如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。 示例 1： 12输入：s = &quot;abpcplea&quot;, dictionary = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]输出：&quot;apple&quot; 示例 2： 12输入：s = &quot;abpcplea&quot;, dictionary = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]输出：&quot;a&quot; 提示： 1 &lt;= s.length &lt;= 1000 1 &lt;= dictionary.length &lt;= 1000 1 &lt;= dictionary[i].length &lt;= 1000 s 和 dictionary[i] 仅由小写英文字母组成 方法一：排序+双指针比较直接简单的思路，就是利用自定义sort函数，满足最长、字典序最小的要求，再用双指针遍历每一个单词，得到的第一个解就是该题目的解。 代码实现12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: string findLongestWord(string s, vector&lt;string&gt;&amp; dictionary) &#123; int n = dictionary.size(); // 对词典进行排序，优先按照长度从大到小排，如果长度相同按字典序从小到大排 sort(dictionary.begin(),dictionary.end(),[&amp;](string s1,string s2)&#123; if(s1.size()!=s2.size())&#123; return s1.size()&gt;s2.size(); &#125;else&#123; return s1&lt;s2; &#125; &#125;); string ans; // 对于排好序的词典中的单词，第一个符合要求的就可以返回。 for(auto &amp; word : dictionary)&#123; int i=0,j=0; // 双指针解法 匹配上时两个指针同时移动，没匹配上s指针单独移动 while(i&lt;s.size() &amp;&amp; j&lt;word.size())&#123; if(word[j]==s[i])&#123; i++; j++; &#125;else&#123; i++; &#125; &#125; // 如果用来匹配word的指针走到头，说明全部匹配了。 if(j==word.size())&#123; ans = word; break; &#125; &#125; return ans; &#125;&#125;; 方法二： 双指针+维护最优解一个贪心思路：当s中存在两个相同字符和词典中的单词匹配时，优先选择匹配靠前的字符。 该方法较方法一时间复杂度高 代码实现12345678910111213141516171819202122232425262728class Solution &#123;public: string findLongestWord(string s, vector&lt;string&gt;&amp; dictionary) &#123; int n = dictionary.size(); string ans; // 遍历每一个单词 for(auto &amp; word : dictionary)&#123; int i=0,j=0; // 双指针解法 匹配上时两个指针同时移动，没匹配上s指针单独移动 while(i&lt;s.size() &amp;&amp; j&lt;word.size())&#123; if(word[j]==s[i])&#123; i++; j++; &#125;else&#123; i++; &#125; &#125; // 如果用来匹配word的指针走到头，说明全部匹配了。 // 此时要进行对最优解的维护 if(j==word.size())&#123; if(word.size()&gt;ans.size() || (word.size()==ans.size()&amp;&amp; word&lt;ans)) ans = word; &#125; &#125; return ans; &#125;&#125;; 方法三：动态规划针对方法2进行改进，使用DP数组，对双指针遍历部分进行简化。 DP数组虽然是二维，但是一层的长度只要涵盖26个英文字母就好。状态转移方程为： dp[i][j] = \\left\\{ \\begin{aligned} i\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\text{s[i] = j} \\\\ dp[i+1][j] \\ \\ \\ \\ s[i]\\neq j \\end{aligned} \\right.其含义是，对于s中的第$i$个位置，字符j将会在$dp[i][j]$处出现，所以显然当$s[i]=j$时，出现为$i$，否则就看看$i+1$是否知道位置。 因此该DP数组要倒退实现。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: string findLongestWord(string s, vector&lt;string&gt;&amp; dictionary) &#123; int n = s.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(26,n)); // 倒序构成dp数组 for(int i=n-1;i&gt;=0;i--)&#123; for(int j=0;j&lt;26;j++)&#123; if(&#x27;a&#x27;+j==s[i])&#123; dp[i][j]=i; &#125;else&#123; dp[i][j] = dp[i+1][j]; &#125; //cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;; &#125; //cout &lt;&lt; endl; &#125; string ans=&quot;&quot;; // 遍历每一个单词 for(auto &amp; word : dictionary)&#123; bool match=true; int i=0; for(auto &amp; c : word)&#123; if(dp[i][c-&#x27;a&#x27;]==n)&#123; match=false; break; &#125;else&#123; i = dp[i][c-&#x27;a&#x27;]+1; &#125; &#125; // 如果用来匹配word的指针走到头，说明全部匹配了。 // 此时要进行对最优解的维护 if(match)&#123; if(word.size()&gt;ans.size() || (word.size()==ans.size()&amp;&amp; word&lt;ans)) ans = word; &#125; &#125; return ans; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"动态规划","slug":"动态规划","permalink":"https://zijian.wang/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"双指针","slug":"双指针","permalink":"https://zijian.wang/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"56. 合并区间","date":"2021-09-13T02:20:22.000Z","path":"2021/09/13/56. 合并区间（排序）/","text":"56. 合并区间 题目以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。 示例 1： 123输入：intervals = [[1,3],[2,6],[8,10],[15,18]]输出：[[1,6],[8,10],[15,18]]解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2： 123输入：intervals = [[1,4],[4,5]]输出：[[1,5]]解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 提示： 1 &lt;= intervals.length &lt;= 104 intervals[i].length == 2 0 &lt;= starti &lt;= endi &lt;= 104 注意事项sort函数在对vector进行排序时，似乎会默认优先排最前面的元素，相同时排下个元素。不需要额外的lambda表达式 这道题需要画出来线段图进行分析，很容易发现sort就可以解题。剩下的就是写法和实现了。 代码实现123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; int n =intervals.size(); vector&lt;vector&lt;int&gt;&gt; ans; // sort函数。不过似乎就算不写lambda，也会按照这个顺序来排列 sort(intervals.begin(),intervals.end(),[&amp;](vector&lt;int&gt; interval1,vector&lt;int&gt; interval2)&#123; if(interval1[0]!=interval2[0])&#123; return interval1[0]&lt;interval2[0]; &#125;else&#123; return interval1[1]&lt;interval2[1]; &#125; &#125;); for(int i=0;i&lt;n;i++)&#123; // 条件一：ans为空，则放入第一个元素 // 条件二：ans不为空，最后一个元素跟新来的元素没有交集，放入新来的元素 if(ans.size()==0 || ans[ans.size()-1][1]&lt;intervals[i][0])&#123; ans.push_back(&#123;intervals[i][0],intervals[i][1]&#125;); &#125;else&#123; // 此时ans不为空，且最后一个元素跟新来的元素有交集 // 根据ans最后一个元素和新来的元素的右边界 判断是否需要扩充。 ans[ans.size()-1][1] = max(ans[ans.size()-1][1],intervals[i][1]); &#125; &#125; return ans; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"数组","slug":"数组","permalink":"https://zijian.wang/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"75. 颜色分类","date":"2021-09-13T02:20:22.000Z","path":"2021/09/13/75. 颜色分类（双指针）/","text":"75. 颜色分类 题目给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 示例 1： 12输入：nums = [2,0,2,1,1,0]输出：[0,0,1,1,2,2] 示例 2： 12输入：nums = [2,0,1]输出：[0,1,2] 示例 3： 12输入：nums = [0]输出：[0] 示例 4： 12输入：nums = [1]输出：[1] 提示： n == nums.length 1 &lt;= n &lt;= 300 nums[i] 为 0、1 或 2 进阶： 你可以不使用代码库中的排序函数来解决这道题吗？ 你能想出一个仅使用常数空间的一趟扫描算法吗？ 注意要点题目要求有原地排序、禁止使用排序函数以及常数空间一边扫描等要求。所以我们可以排除sort函数、hash、新数组等方法。而一边扫描最常用的就是双指针或多指针。 这道题是“荷兰国旗问题”。又是Dijkstra提的。 代码实现1234567891011121314151617181920212223242526272829class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); // p0用来交换0 p1用来交换1 int p0 = 0, p1 = 0; for (int i = 0; i &lt; n; ++i) &#123; // 如果遍历到的数为1 if (nums[i] == 1) &#123; // 和p1交换，p1++ swap(nums[i], nums[p1]); ++p1; // 如果遍历到的数为0 &#125; else if (nums[i] == 0) &#123; // 交换p0 swap(nums[i], nums[p0]); // 如果此时p0在p1前面，说明此时1被交换到了外面，所以需要再交换到p1的位置 if (p0 &lt; p1) &#123; swap(nums[i], nums[p1]); &#125; // 都要自增 ++p0; // 如果p0&lt;p1,因为做了交换，所以要自增 // 如果p1&lt;=p0。显然该位置放了0 所以p1也要自增 ++p1; &#125; &#125; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"双指针","slug":"双指针","permalink":"https://zijian.wang/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"左值引用和右值引用","date":"2021-07-24T02:20:22.000Z","path":"2021/07/24/左值引用和右值引用/","text":"关于C++中左值引用和右值引用的一个总结 表示&amp; 表示左值引用 &amp;&amp; 表示右值引用 左值和右值C语言中的左值和右值简单的区分就是：左值可以位于复制语句的左侧，右值不能。C++中的左值右值概念也是从此引申而来，不过有了一些更复杂的情形。 比如： 以常量对象为代表的一些左值实际无法作为赋值语句的左侧运算对象 某些表达式的求值结果为对象，但是却是右值而非左值 我们可以简单归纳为当一个对象被用作右值时，用的是对象的值（内容），被用作左值时，用的是对象的身份（内存中的位置）。 左值引用不能绑定到要求转换的表达式、字面常量或者返回右值的表达式。 一般无法将一个左值引用绑定到一个右值上 但我们可以使用一个const左值引用绑定到一个右值上。 返回左值引用的函数，连同赋值、下标、解引用和前置递增递减运算符，都是返回左值的表达式的例子，可以使用左值引用绑定到这些表达式的结果上。 右值引用可以绑定到要求转换的表达式、字面常量或者返回右值的表达式。 但是无法将一个右值引用直接绑定到一个左值上。 返回非左值引用类型的函数，连同算数、关系、位以及后置递增递减运算符，都生成右值。我们可以使用const的左值引用或者右值引用绑定到这类表达式。 性质左值持久；右值短暂左值有持久的状态，右值要么是字面常量，要么是表达式求值过程中创建的临时对象 右值引用两个特性 所引用的对象将要被销毁 该对象没有其他用户 所以使用右值引用，可以自由接管所引用的对象的资源。 变量与std::move函数变量表达式都是左值表达式，因此无法使用右值引用绑定到一个变量上，包括一个右值引用类型的变量上。 但是我们可以显示的将一个左值转换为对应的右值引用类型，也可以通过C++11 标准下的std:move函数来获得绑定到左值上的右值引用。该函数在utility头文件中。 std::move函数的作用是告诉编译器，我们希望像使用一个右值一样使用一个左值。当使用该函数时，就意味着我们的程序除了对这个左值赋值或销毁之外，不再使用它。也就是说调用之后，我们不能对移后源对象的值作任何假设。 也就是说我们可以销毁一个移后源对象，也可以赋予新值，但不能使用它的值。","tags":[{"name":"C++","slug":"C","permalink":"https://zijian.wang/tags/C/"}]},{"title":"《剑指offer》 29. 顺时针打印矩阵","date":"2021-07-19T02:54:01.000Z","path":"2021/07/19/29. 顺时针打印矩阵/","text":"note： 虽然是简单题，但是挺麻烦，尤其是在（好久）没做过的情况下，建议记住方法二的第二种写法，更简洁易懂一点。 题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1： 12输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5] 示例 2： 12输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7] 限制： 120 &lt;= matrix.length &lt;= 1000 &lt;= matrix[i].length &lt;= 100 方法一 模拟思路通过方向数组模拟遍历路径，以便进行顺时针旋转。同时搭配一个标识是否访问过的数组，防止重复访问。 首先是向右、向下、向左和向上的方向数组： static constexpr int directions[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; // 方向数组 使用方向索引directionIndex来决定选用那个方向数组。 然后引入理论下标nextRow和nextColumn，来计算方向不改变时，下一个要访问的元素的下标。 判断理论下标是否合法，不合法的情况有两个，其一是数组越界，其二是访问的元素已经访问过了。 当理论下标不合法时，变换方向索引到顺时针的下个方向。 然后更新下标为真实的合法下标。 代码123456789101112131415161718192021222324252627282930313233class Solution &#123;private: static constexpr int directions[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; // 方向数组public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; // 超出情况 if (matrix.size() == 0 || matrix[0].size() == 0) &#123; return &#123;&#125;; &#125; int rows = matrix.size(), columns = matrix[0].size(); vector&lt;vector&lt;bool&gt;&gt; visited(rows, vector&lt;bool&gt;(columns)); // 标识数组 int total = rows * columns; vector&lt;int&gt; order(total); int row = 0, column = 0; int directionIndex = 0; // 方向索引 for (int i = 0; i &lt; total; i++) &#123; // 所有元素都访问到 order[i] = matrix[row][column]; visited[row][column] = true; // 标记标识数组 // 下一个访问的数组元素下标理论值 int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1]; // 理论值是否不合法，不合法顺时针转换方向 if (nextRow &lt; 0 || nextRow &gt;= rows || nextColumn &lt; 0 || nextColumn &gt;= columns || visited[nextRow][nextColumn]) &#123; directionIndex = (directionIndex + 1) % 4; &#125; // 下标的真实变换 row += directions[directionIndex][0]; column += directions[directionIndex][1]; &#125; return order; &#125;&#125;; 复杂度分析 时间复杂度$O(mn)$。要遍历所有的元素，m n分别为矩阵的长和宽 空间复杂度$O(mn)$。需要一个和矩阵相同大小的二维数组作为标记数组。 方法二 按层遍历思路方法一的思路是矩阵不变，标记已访问的元素避免重复访问。 事实上，我们也可以不断改变矩阵的边界，达到一层层缩小矩阵的边界的效果，按层遍历，从而可以得到顺时针遍历同样的效果。 我们用四个变量l r t b代表当前层的矩阵的左右上下边界 在左边界大于右边界、上边界大于下边界之前，我们重复四个步骤 从左到右访问上边界那一排元素 从上到下访问右边界那一列元素 如果左上边界都小于右下边界，那么我们 从右到左访问下边界这一排元素 从下到上访问左边界这一排元素 更改边界，左边界上边界自增，右边界下边界自减。 代码12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.size()==0 || matrix[0].size()==0)&#123; return &#123;&#125;; &#125; int m = matrix.size(),n=matrix[0].size(); int l=0,r=n-1,t=0,b=m-1; vector&lt;int&gt; ans; while(l&lt;=r &amp;&amp; t&lt;=b)&#123; for(int i=l;i&lt;=r;i++)&#123; ans.push_back(matrix[t][i]); &#125; for(int i=t+1;i&lt;=b;i++)&#123; ans.push_back(matrix[i][r]); &#125; if (l &lt; r &amp;&amp; t &lt; b)&#123; for(int i=r-1;i&gt;l;i--)&#123; ans.push_back(matrix[b][i]); &#125; for(int i=b;i&gt;t;i--)&#123; ans.push_back(matrix[i][l]); &#125; &#125; l++; r--; t++; b--; &#125; return ans; &#125;&#125;; 如果较难理解，还有一种写法，即在每排每列访问完后，立刻进行边界的缩小，并判断是否合法，如果不合法则说明已经遍历完毕，可以直接结束 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return &#123;&#125;; vector&lt;int&gt; res; int l = 0; //左边界 int r = matrix[0].size() - 1; //右边界 int t = 0; //上边界 int b = matrix.size() - 1; //下边界 while (true) &#123; //left -&gt; right for (int i = l; i &lt;= r; i++) res.push_back(matrix[t][i]); if (++t &gt; b) break; //top -&gt; bottom for (int i = t; i &lt;= b; i++) res.push_back(matrix[i][r]); if (--r &lt; l) break; //right -&gt; left for (int i = r; i &gt;= l; i--) res.push_back(matrix[b][i]); if (--b &lt; t) break; //bottom -&gt; top for (int i = b; i &gt;= t; i--) res.push_back(matrix[i][l]); if (++l &gt; r) break; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度：$O(mn)$。要访问矩阵种所有的元素 空间复杂度：$O(1)$。不需要标记数组。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《C++ Primer 第五版》阅读过程查漏补缺 Chapter6","date":"2021-07-11T08:50:22.000Z","path":"2021/07/11/《C++ Primer第五版》阅读过程查漏补缺 chapter6/","text":"函数部分比较难的地方在函数指针的各个概念，需要多加注意 函数基础函数的调用和返回调用相关调用运算符：调用运算符的形式是一对圆括号，作用于一个表达式，该表达式是函数或者指向函数的指针。圆括号之内是一个用逗号隔开的实参列表，我们用实参初始化函数的形参。调用运算符的类型就是函数的返回类型 函数调用完成两项工作： 使用实参初始化函数对应的形参 将控制权转移给被调函数。此时，主调函数的执行被打断，被调函数开始执行 返回相关一般的类型函数都可以进行返回，当函数不需要返回任何值时，可以返回void，当然也可以返回空语句。 但是函数返回类型不能是数组，但是可以是指向数组或函数的指针， return语句同样完成两项工作： 返回return语句中的值 将控制权从被调函数转移回主调函数。 形参与实参函数有几个参数，就必须提供相同数量的实参，因为参数的调用规定实参数量要和形参一致，所以形参一定会被初始化。 同时，形参的类型一定要被实参很好的满足。比如如果形参是int类型，实参可以是double类型，因为可以隐式转换，但却不能是const char*类型。 函数的形参列表 当一个函数没有形参时，可以书写一个空的形参列表，为了和C语言兼容，函数的形参列表可以用关键字void表示函数没有参数。 偶尔有函数的个别参数不会被使用，则此类形参通常不命名以表示在函数体内不会使用。但即便如此，函数调用时，依然应该为其提供一个实参。 局部对象在C++中，名字有作用域，对象有生命周期。 名字的作用域是程序文本的一部分，名字在其中可见 对象的生命周期是程序执行过程中该对象存在的一段时间 形参和函数体内部定义的变量统称为局部变量。局部变量会在外层作用域中同名的其他所有声明里隐藏（意思就是在外层作用域如果存在同名变量，则局部变量是无法访问到的。） 自动对象函数的控制路径经过变量定义语句时创建的对象，该对象当到达定义所在块的末尾时会进行销毁，只存在于块执行期间的对象，就是自动对象。 形参就是一种自动对象。该自动对象在函数开始时申请存储空间，由实参进行初始化，在函数结束时被销毁 对于非形参的局部变量的自动对象，如果含有初始值，则使用初始值进行初始化；否则执行默认初始化。也就是说内置类型的未初始化局部变量将产生未定义的值。 局部静态变量如果要让局部变脸的生命周期贯穿函数调用，及之后的时间，可以将局部变量定义为static类型。 局部静态变量在程序执行路径第一次经过对象定义语句时初始化，直到程序终止才被销毁，在此期间即使对象的所有函数执行也不会对他有影响。 如果局部静态变量没有显式的初始值，则将执行值初始化，内置类型的局部静态变量初始化为0. 函数声明函数的名字必须在使用前声明，函数只能定义一次，但能声明多次。 函数声明可以省去形参的名字，只要形参的类型。 函数声明也称为函数原型。 函数声明建议放在头文件中而不是源文件中，便于更改。 定义函数的源文件把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。 分离式编译C++支持分离式编译，也就是允许多个源文件共同编译，或各自编译，生成对象文件，再进行链接成可执行文件 参数传递C++的参数传递分为值传递或引用传递两大类。 值传递值传递本质就是形参和实参是完全两个不同的变量，形参只是利用实参的值进行拷贝初始化。 而对于指针传参而言，同样依然是一种“值传递”，这种值传递不过是把指针的值进行了拷贝传递，拷贝之后形参的指针和实参的指针依然是两个完全不同的指针，只是他们访问的对象是同一个对象罢了。 以前在C语言中，我们把参数传递分为按值传参和按址传参，在C++中更经常使用引用传参而不是按址传参。 引用传递引用的本质就是通过给原本的对象起一个别名，然后使用它。对引用的操作实际上是作用在引用的对象上的。引用形参是同一个道理。 最重要的是通过引用传参，可以避免变量的复制。对于大的类型（string等）还有不支持拷贝操作的类型（IO类型），我们要使用引用形参的方式来访问该类型的对象。同时，如果函数无需修改引用类型的值，最好用常量进行引用 引用是一种和指针非常类似的东西，也就是说我们也可以用引用传参的方法，返回额外的信息（因为return只能返回一个值）。 const形参和实参使用实参初始化形参时，会忽略掉顶层const（顶层const的具体含义见章节二）。也就是说，当形参有顶层的const时，传给他常量对象或者非常量对象都是合法的。 由于C++中虽然允许函数名相同的函数存在，但前提是不同函数的形参列表应该有明显区别。那么如果两个函数的唯一区别就是形参列表中有无顶层const，那么第二个函数就是错误的，因为是重复定义的函数，如下述代码所示： 12void fcn(const int i)&#123;```/*fcn可以读取i，但不可以改变i*/```&#125;void fcn(int i)&#123;```&#125; // 重复定义了 我们可以使用非常量初始化一个底层const对象，但是无法用一个底层const对象来初始化一个非const指针；同时一个普通的引用必须用同类型的对象初始化。如下述代码 1234567int i = 42;const int *cp = &amp;i; // 正确。const int &amp;r = i; // 正确const int &amp;r2 = 42; // 正确int *p = cp; // 错误，cp是指向一个底层const对象的指针，p是一个指向普通对象的指针，类型不同int &amp;r3 = r; // 错误，r是一个底层const对象的引用，我们无法用一个引用普通对象的引用来引用一个底层const对象。int &amp;r4 = 42; // 错误，无法引用一个常数。 同样这些规则也适合于函数传参。 但是当我们的形参类型是常量引用时，确实可以使用一个字面值作为实参进行初始化。 在函数不会改变形参时尽量使用常量引用 原因是：常量引用可以扩大函数所能接受的实参类型。如上文所述，顶层const可以忽略对于函数引用，不会影响非const类型的接受，但是如果是非const引用，则会导致无法接受const类型参数进行初始化——尽管那可能是我们想要的。 数组形参数组存在两个性质：不允许拷贝数组、使用数组时通常会将其转换为指针 所以当数组作为形参时，我们无法用值传递的方式使用数组参数，实际上我们是将指向数组首元素的指针传入函数 形如： 123void print(const int*);void print(const int[]);void print(const int[10]); 都是将数组传入函数的写法，且上述三种表示的含义相同——都表示传入的参数为const int*类型。编译器检查只会检查是否为这种类型。 和其他使用数组的代码一样，以数组为形参的函数也必须保证数组不越界，管理指针形参有三种常用的技术 使用标记指定数组长度。即规定数组中含有某个元素，标记数组的结束。比如C风格字符串，会以空字符作为字符串结束的标志 使用标准库规范。即传递数组的首元素和尾后元素的指针。一般可以使用标准库的begin()函数和end()函数 显示传递一个数组大小的形参。在C程序和过去的C++程序中常用，调用函数时，提前用一个变量表示函数大小，作为参数传递过去。 数组形参和const同引用一样，如果函数不需要对数组元素执行写操作，数组形参应该是指向const的指针 数组引用形参如同之前的引用传参，形参也可以是数组的引用，此时引用形参绑定到对应的实参，也就是绑定到数组上。写法如下所示： 1void print(int (&amp;arr)[10]); 其中&amp;arr两端的括号必不可少。 传递多维数组C和C++中没有真正意义的多维数组，只有存放了数组的数组。而一般多维数组的写法如下所示 123void print(int (*matric)[10],int rowSize);或者void print(int matric[][10],int rowSize); 一般来说，数组作为传参，编译器不会在乎你的数组容量，但是会在乎你的数组中元素的类型。正如前面介绍的，传入参数传入的实际只是首元素的地址，而n维函数也不过只是存放了一个(n-1)维数组的一维数组，所以编译器会优化掉你的第一个维度（也就是一维数组的长度）,但是却需要知道你的类型。这也就是为什么我们传入指针时，需要标注10，传入数组时，省略第一个括号中的值的原因。 main：处理命令行选项1int main(int argc, char* argv[])&#123;···········&#125; 其中argc为命令行传入参数数目+1，同时也代表argv数组的大小。 argv是一个存放字符串的数组，其中它的第一个元素必然是可执行文件，后面的元素即为传进来的参数。（书上说最后一个元素一定为0，事实上打印时发现如果尝试打印下个数，会段错误） 含有可变形参的函数在无法提前预支需要向函数传递多少个参数时，C++11提供了两种主要方法： initializer_list标准库类型：要求所有的实参类型都相同 可变参数模板：实参类型不同 同时C++还有一种形参类型——省略符，可以用来传递可变数量的实参，一般用于与C函数交互的接口程序 initializer_list定义在同名头文件需要引入。相关操作如图所示 需要注意的是，initializer_list对象中的元素永远是常量值，无法改变其中元素的值。 如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号里。 省略符形参使用了varargs的C标准库功能。 1void foo(...); 返回类型和return类型关于return的有无当函数的返回类型不是void，则该函数内每条return语句必须返回一个值。且返回值的类型必须与函数返回类型相同，或可以隐式转换。 同样 在含有return语句的循环后面也要有一条return语句，如果没有，该程序就是错误的。 不要反悔局部对象的引用或指针形如： 123456789const string &amp;manip()&#123; string ret //···· if(!ret.empty()) return ret; else return &quot;Empty&quot;;&#125; 这样的程序，两条返回语句都是错误的，第一条语句实际返回的是局部对象的引用，第二条语句实际返回的是局部临时量。 综上，返回局部对象的引用或指针都是错误的， 因为会在函数结束后释放掉空间，指针或引用就访问了不可用的内存空间。 返回类类型的函数和调用运算符调用运算符优先级和点运算符、箭头运算符相同，且符合左结合律。 引用返回左值函数的返回类型决定函数调用是否为左值。当函数返回引用时，得到左值，其他返回类型为右值。返回类型为引用的函数可以像其他左值一样进行使用，比如我们可以为返回类型为非常量引用的函数的结果赋值。当然如果为常量引用，我们依旧无法赋值。 列表初始化返回值（C++11）C++11规定，函数可以返回花括号包围的值的列表。此处列表也是用来对表示函数返回的临时量进行初始化。 列表为空时，临时量执行值初始化 否则，返回的值由函数的返回类型决定。 如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不能大于目标类型的空间。如果函数返回的是类类型，则需要由类本身定义初始值如何使用。 main主函数主函数可以不显示的写上return 0，编译器一般会自己隐式插入。 main函数的返回值是状态指示器。返回0表示执行成功，其他值表示失败，具体非0值的含义跟机器相关。为了机器无关，cstdlib头文件定义了两个预处理变量，分别表示成功与失败 12345678#include &lt;cstdlib.h&gt;int main()&#123; if(/···some failure···/) return EXIT_FAILURE; // 表示返回失败 else return EXIT_SUCCESS; // 表示返回成功&#125; main函数不可以调用自己 返回数组指针定义一个返回数组的指针或引用有下述几种方法： 类型别名 typedef int arrT[10]。arrt表示了一个类型别名，表示的类型为含有10个整数的数组 using arrT=int[10]。 同上 这样，就有函数arrT* func(int i)来返回一个指向含有10个整数的数组的指针。其中arrT是含有10个整数的数组的别名。 声明一个返回数组指针的函数不使用类型别名，就需要用比较繁琐的方式进行表示，函数形式如下所示 Type\\ \\ (*function(parameter_list))\\ \\ [dimension]其中$Type$表示元素类型，$dimension$表示数组大小，$ (*function(parameter_list))$的括号必须存在，如果不存在，返回的就是指针数组。 尾置返回类型（C++11）C++11中有一种简化的方法，就是尾置返回类型。这种形式对返回类型比较复杂的函数最有效。 尾置返回类型跟在形参列表后面并以一个$-&gt;$开头，同时在返回类型处，放置一个auto，如 1auto func(int i) -&gt; int(*) [10]; 这里返回了一个指针，指针指向含有10个整数的数组。 使用decltype这应用于我们提前知道了函数返回的指针将要指向哪个数组。如下所示 1234567int odd[] = &#123;1,3,5,7,9&#125;;int even[] = &#123;2,4,6,8,10&#125;;decltype(odd) *arrPtr(int i)&#123; return (i%2) ? &amp;odd : &amp;even;&#125; 但是需要注意decltype并不负责把数组类型转换成对应的指针，所以decltype的结果为数组，所以应该在arrPtr函数前加上*号。 函数重载函数名字相同，形参列表不同，称之为重载函数。重载函数允许函数形参数量和形参类型不同，但不允许两个函数除了类型外其他所有要素都相同。 形参类型究竟是否相同有些函数虽然形参类型看似不同，但是本质不是重载函数。主要指的是类型别名 重载函数和const形参参考顶层const和底层const](http://rrazz.love/2020/11/04/《C++ Primer 第五版》阅读过程查漏补缺 Chapter2/))，两者要区分开来。 顶层const作为参数时，无法影响传入函数的对象， 也就是无法进行重载。典型代表就是常量指针。 底层const作为参数时，可以理解为不同函数，是一种函数重载，包括常量引用和指向常量的指针。 重载函数和const_cast第4章介绍了const_cast，作为一种解引用的关键字，在重载函数中很有用。举例假如我们有一个函数shorterString如下所示： 1234const string &amp;shorterString(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt;= s2.size() ? s1: s2;&#125; 该函数的参数、返回值都是const string的引用，如果我们对两个非常量 调用该函数，那么显然我们返回的结果是一个const string的引用。这时我们就需要一个重载函数，他要达到的目的是：当我传入实参不是常量时，我得到的结果也应该是一个非常量的引用。重载函数如下所示： 12345string &amp; shorterString(string &amp;s1, string &amp;s2)&#123; auto &amp;r = shorterString(const_cast&lt;const string&amp;&gt; (s1), const_cast&lt;const string&amp;&gt;(s2)); return const_cast&lt;string&amp;&gt;(r);&#125; 这样写，最终返回的非常量引用显然是安全的。 函数匹配（重载确定）调用重载函数可能有三种结果 编译器找到一个最佳匹配 找不到任何一个函数与调用的实参匹配，编译器发出无匹配错误 在多余一个函数可以匹配，但每个都不是最佳选择，此时会发生错误，称为二义性调用 重载和作用域不同作用域，函数重载不生效。如果在新的子作用域中声明了某一个函数，而和他同名的其他函数未在作用域声明，则其他重载函数会被屏蔽。因为编译器会先从局部作用域中找起，当前作用域找到后就会接受该函数，并忽略外层作用域中的同名实体。 特殊用途语言特性有三种函数相关的语言特性，分别是默认实参、内联函数和constexpr函数。 默认实参我们可以为每一个形参提供默认实参，默认实参作为形参初始值出现在形参列表。一旦某个形参被赋予了默认值，形参列表中在他之后的所有形参都要赋予默认值。 tips：对于函数的声明，一般习惯放在头文件，且只声明一次。 局部变量不能作为默认实参。但表达式可以，用作默认实参的名字在函数声明所在的作用域内解析，但是求值过程发生在函数调用 内联函数和constexpr函数 内联函数 内联函数可以避免函数调用的开销。所谓内联函数就是让函数在调用点“内联”展开。 只需要在函数返回值前加上关键字inline，就可以声明为内联函数。 一般来说内联函数用于优化规模小、流程直接、频繁调用的函数 编译器一般不支持内联递归函数以及大于75行的函数。 constexpr函数 指能用于常量表达式的函数。需要遵循下列约定 函数的返回值和所有形参的类型都要是字面值类型 函数体中必须有且只有一条return语句 同时，constexpr函数一般会被隐式的指定为内联函数。 由于内联函数和constexpr函数可以在程序中多次定义，所以为了保证其多次定义完全一致，他们通常定义在头文件中。 调试帮助assert预处理宏assert宏在cassert头文件中定义。预处理名字由预处理器而非编译器管理，所以可以直接使用assert而不是std::assert assert宏用于检查“不能发生”的条件。本质类似于内联函数。 1assert(expr) NDEBUG预处理变量assert的行为依赖于NDEBUG的预处理变量的状态。如果定义了该变量，则assert什么也不做。 函数匹配重载函数的选用过程就是函数匹配，这一过程主要分为三步： 第一步 是找到重载函数集，也就是候选函数们，候选函数具备两个特征：1. 与被调用的函数同名 2. 它的声明在调用点可见。 第二步 是根据调用提供的实参，确定可行函数。可行函数具备两个特征 1. 形参数量和调用提供的实参数量相同 2. 每个实参的类型和对应形参类型相匹配 在此步骤中，两个小步骤可能存在以下两种特殊情况： 具有默认实参的函数比较特殊，在调用该函数时传入的实参数量，可能要少于其实际使用的实参数量。 实参形参匹配的含义可能是具有相同的类型，也可能是实参类型和形参类型满足转换规则（比如高精度转低精度）。 第三步 是在可行函数中寻找最匹配的函数，所谓最匹配的基本思想，就是实参和形参类型最接近。详细说来就是两点： 最匹配函数的每个实参匹配都不劣于其他可行函数需要的匹配 至少有一个实参的匹配，比其他可行函数提供的匹配都优秀。 如果这两点无法满足，则编译器将会报错二义性调用 类型转化的等级排序 下述三种情况都属于最优的精确匹配 实参与形参类型完全相同 实参从数组类型或函数类型转换为指针类型 实参添加或删除顶层const const转换实现的匹配 类型提升实现的匹配 算术类型转换、指针转换实现的匹配 类类型转换实现的匹配 函数指针函数指针是指向函数的指针。该函数的类型由返回类型和形参类型有关，和函数名无关 比如： 如有一函数为bool lengthCompare(cosnt string &amp;, const string &amp;)，则其类型为bool (const string &amp;, const string &amp;)，指向该类型函数的指针可以声明为bool (*pf) (const string &amp;, const string &amp;)。其中，*pf左右的括号必不可少，否则pf只是一个返回值为bool指针的函数，而不是一个指向函数的指针。 使用函数指针函数指针的使用和其他指针不太相同，主要有以下这些点： 函数名作为右值赋值给指针时，函数可以自动转换为指针，取地址符是可选的 123// 下面两条语句等价pf = lengthCompare;pf = &amp;lengthCompare; 指向函数的指针调用该函数时，无需提前解引用指针。 1234// 下面三条语句等价bool b1 = pf(&quot;hello&quot;,&quot;goodbye&quot;);bool b2 = (*pf) (&quot;hello&quot;,&quot;goodbye&quot;);bool b3 = lengthCompare(&quot;hello&quot;,&quot;goodbye&quot;); 不同函数类型的指针不存在转换规则，且函数指针可以赋值为nullptr。 对于重载函数的指针，指针类型必须与候选函数中的某一个精准匹配。 函数类型是无法被定义为形参的，但是我们可以使用指向函数的指针，也就是函数指针，来作为函数的形参，此时，形参看上去是函数类型，但其实实际上是被视为指针使用。 123// 下面两条语句等价void useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, cosnt string &amp;));void useBigger(const string &amp;s1, const string &amp;s2, bool (*pf) (const string &amp;, const string &amp;)); 此时我们将函数直接作为实参转入，其会自动转换为指针类型。 上面直接使用函数作为形参，使得代码很长，我们使用类型别名和decltype简化函数指针的代码： 123456// Func和Func2就是函数类型typedef bool Func(const string &amp;, const string &amp;);typedef decltype(lengthCompare) Func2;// FuncP和FuncP2是函数指针typedef bool (*FuncP) (const string &amp;, const string &amp;);typedef decltype(lengthCompare) *FuncP2; 需要注意，上面和下面是不等价的，decltype返回函数类型，在此时，是不会将函数类型自动转换为指针类型的。所以只能加上*号，才可以得到函数指针。 从而得到简单的写法： 12void useBigger(const string &amp;s1, const string &amp;s2,Func);void useBigger(const string &amp;s1, const string &amp;s2, FuncP2) 函数类型无法作为实际的参数，所以在作为形参时，可以自动转换为函数指针，但是函数类型作为返回时，却无法自动转换为函数指针，所以当我们需要返回一个函数指针时，必须显式地将函数返回类型指定为函数指针。使用类型别名可以简单的表示返回的函数指针： 12using F = int(int *, int);using PF = int(*) (int*, int); 其中，F为一个函数类型，PF为一个指向函数类型的指针。注意在定义完返回的函数指针后，正确的函数写法分别有以下两种： 12F *func1(int);PF func1(int) 前者使用了定义的函数类型，由于无法向形参那样自动转换为函数指针，所以需要显式的加上*号。后者使用了定义的函数指针，所以可以直接接到返回值。 在不使用类型别名时，上面这个返回值为函数指针的函数还可以写为下面的形式： 1int (*f1(int)) (int *, int); 首先f1具有形参列表，所以f1是一个函数，其次有*号，说明返回了一个指针，然后指针的类型包括了形参列表，所以指针指向函数，被指向的函数的返回类型是int。 或者使用尾置返回类型： 1auto f1(int) -&gt; int (*) (int*, int); 在明确知道返回函数是谁时，可以使用decltype简化上述过程，直接使用deccltype得到已知的返回的函数类型，由于decltype返回的是函数类型而非指针，所以要加上*号来返回一个指针 12string::size_type sumLength(const string&amp;, const string&amp;);decltype(sumLength) *getFun(const string&amp;); getFunc函数返回的就是指向sumLength函数类型的指针。","tags":[{"name":"C++","slug":"C","permalink":"https://zijian.wang/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zijian.wang/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"《剑指offer》 28. 对称的二叉树","date":"2021-07-06T11:33:01.000Z","path":"2021/07/06/28. 对称二叉树/","text":"note: 所谓对称二叉树，就是以根节点为轴，左右对称的二叉树。 题目描述请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 / \\ 2 2 / \\ / \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 / \\2 2 \\ \\ 3 3 示例 1： 12输入：root = [1,2,2,3,4,4,3]输出：true 示例 2： 12输入：root = [1,2,2,null,3,null,3]输出：false 限制： 10 &lt;= 节点个数 &lt;= 1000 方法 递归思路到底什么是对称二叉树，题目描述是和镜像相同，其实本质就是以根节点为轴，左右对称的一棵二叉树。 并不需要每个子树都是对称的（那样就每一层都相同了）。所以我们只需要考虑结点的情况就可以了。 所以我们只需要在使用递归时考虑出下述的递归结构 递归终止条件 要比较的两个节点都为空节点。显然此时返回true 要比较的两个节点有一个为空节点，另一个不为空节点。此时返回false 要比较的两个节点值不相同。此时返回false 递归体 这里是这道题的关键，我们每次递归都要把要进行比较的节点交给下层递归，那么需要如何比较呢？ 分析二叉树可以知道，比较的其实是左子树的左节点和右子树的右节点是否相同，以及左子树的右节点和右子树的左节点是否相同。 所以递归体为对左子树左节点、右子树右节点进行递归；对左子树的右节点、右子树的左节点进行递归。 返回结果 显然当左子树的左节点和右子树的右节点相等，且左子树的右节点和右子树的左节点相等时，我们返回真值，否则返回假值。 代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; bool dfs(TreeNode* L, TreeNode* R)&#123; if(L==NULL &amp;&amp; R==NULL) return true; if(L==NULL || R==NULL || L-&gt;val!=R-&gt;val) return false; return dfs(L-&gt;left,R-&gt;right) &amp;&amp; dfs(L-&gt;right,R-&gt;left); &#125;public: bool isSymmetric(TreeNode* root) &#123; return root==NULL ? true : dfs(root-&gt;left, root-&gt;right); &#125;&#125;; 复杂度分析 时间复杂度$O(n)$。需要遍历所有二叉树结点 空间复杂度$O(n)$。进行递归的递归栈深度。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 27. 二叉树的镜像","date":"2021-07-06T02:32:01.000Z","path":"2021/07/06/27. 二叉树的镜像/","text":"note: 非常简单的二叉树题目，常规递归就可以解决。 题目请完成一个函数，输入一个二叉树，该函数输出它的镜像。 例如输入： 4 / \\ 2 7 / \\ / \\ 1 3 6 9镜像输出： 12345 4 / \\ 7 2 / \\ / \\9 6 3 1 示例 1： 12输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1] 限制： 10 &lt;= 节点个数 &lt;= 1000 方法：递归思路经典的二叉树问题，从根节点出发，依次交换左右子树，递归进行。 递归终止条件： 到达空叶子节点 递归体： 对左右叶子进行递归镜像，然后交换位置，返回给父节点 返回 当前节点 代码12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* mirrorTree(TreeNode* root) &#123; if(root==NULL)&#123; return NULL; &#125; TreeNode* temp = root-&gt;left; root-&gt;left = mirrorTree(root-&gt;right); root-&gt;right = mirrorTree(temp); return root; &#125;&#125;; 复杂度分析 时间复杂度$O(n)$。需要遍历所有节点 空间复杂度$O(n)$。递归栈的深度和节点数相同。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 26. 树的子结构","date":"2021-07-05T07:53:01.000Z","path":"2021/07/05/26. 树的子结构/","text":"note:递归是一般求解二叉树问题最常用的手段，做好特殊判断、找到递归终止条件，写好递归体，就可以解决此类问题 题目描述输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 例如:给定的树 A: 12345 3/ \\ 4 5 / \\1 2 给定的树 B： 123 4 /1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 示例 1： 12输入：A = [1,2,3], B = [3,1]输出：false 示例 2： 12输入：A = [3,4,5,1,2], B = [4,1]输出：true 限制： 10 &lt;= 节点个数 &lt;= 10000 方法：双递归解题思路这道题要求找树的子结构，注意是要求结构相同，那么就不能简单的想着用某种遍历手段，然后判断遍历生成的字符串是否是子串这种思路来解题（这是我一开始犯下的错误）。因为要求的结构相同，单单看遍历串其实很容易出现一些巧合，导致不在一棵子树上的节点被误以为在一个节点上，从而误以为结构相同。 所以这道题应该在每一步都考虑具体的结构。所以采用两个递归函数，其中一个递归函数来判断二叉树B在当前节点的左子树还是右子树上，另一个递归函数则是判断结构是否相同。 第一个递归函数isSubStructure函数用来遍历树A。 递归终止条件：根绝题意，空节点不构成子树，所以我们可以把递归终止条件设置为两个节点中有一个节点为空节点。 递归行为：根据前文分析，大致有三种情况 树B是和当前子树的结构相同。 树B和当前子树的左子树结构相同 树B和当前子树的右子树结构相同 返回值：三种递归结果的或运算 第二个递归函数dfs函数用来遍历树B，看B的结构是否等于A的子树。 递归终止条件: 遍历B子树的指针为空时，说明前面的父节点都相同，可以返回true，表示这一支为真 遍历A子树的指针为空，但是B子树的指针还没有为空，则说明结构不同，返回false 遍历AB两棵树，如果当前节点不相同，则说明结构不同返回false 递归行为 显然，我需要分别递归左右子树看是否结构完全相同 返回值： 递归左右子树都得到返回值为真，才说明这个子树是结构相同的。 代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; bool dfs(TreeNode* A, TreeNode *B)&#123; if(B==NULL) return true; else if(A==NULL || A-&gt;val!=B-&gt;val) return false; return dfs(A-&gt;left,B-&gt;left) &amp;&amp; dfs(A-&gt;right,B-&gt;right); &#125;public: bool isSubStructure(TreeNode* A, TreeNode* B) &#123; if(A==NULL || B==NULL) return false; return dfs(A,B) || isSubStructure(A-&gt;left,B) || isSubStructure(A-&gt;right,B); &#125;&#125;; 复杂度分析 时间复杂度$O(MN)$.其中M，N分别为两棵子树的节点数。显然我们首先遍历了树A，时间复杂度应该为$O(M)$，然后在每层递归中遍历了树B，所以复杂度为O(N)。最终时间复杂度即为$O(MN)$ 空间复杂度$O(M)$.虽然我们需要遍历到每个子树的各个节点，但是显然当我们在遍历子树A时，随着递归栈的深入，对另一个递归函数的调用，结束的也越快（因为一但A的节点为空节点，就会马上返回，释放递归栈空间）。所以最终空间复杂度为$O(M)$。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 24. 反转链表","date":"2021-06-23T03:28:01.000Z","path":"2021/06/23/24. 反转链表/","text":"note: 反转链表作为一道简单题，主要考察的是对迭代法和链表数据结构的了解。 题目描述定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 限制： 10 &lt;= 节点个数 &lt;= 5000 方法一 迭代法思路首先我们需要一个指向前一个节点的指针pre，然后每次迭代做四件事 保存当前节点的下个节点 让当前节点的下一个节点指针改为指向pre指针指向的节点 让pre指针指向当前节点 让指向当前节点的指针指向下个节点。 代码123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode * pre = NULL; while(head!=NULL)&#123; ListNode* temp = head-&gt;next; head-&gt;next = pre; pre=head; head = temp; &#125; return pre; &#125;&#125;; 复杂度分析 时间复杂度$O(n)$。需要遍历每个节点 空间复杂度$O(1)$。只需要一个pre指针，常量级空间。 方法二 递归法思路递归的思路其实就是分治，将每部分都要反转的问题，转化为思考现在我有一个节点和它后续已经反转好的节点。思考到这一步就差不多能写出来了。递归终止条件为当前节点的下个节点为空（说明已经是最后一个节点）或者当前节点为空（说明链表为空），此时返回当前节点。 代码1234567891011class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head==NULL || head-&gt;next==NULL) return head; ListNode* cur = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return cur; &#125;&#125;; 复杂度分析 时间复杂度$O(n)$。需要遍历每个节点 空间复杂度$O(n)$。递归需要调用栈空间，显然需要链表长度层栈空间。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 25. 合并两个排序的链表","date":"2021-06-23T03:28:01.000Z","path":"2021/06/23/25. 合并两个排序的链表/","text":"notes：归并排序用于两个有序链表的排序很有效果，此题目重点应该是在想到需要一个额外的伪头节点 题目描述输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 示例1： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 限制： 10 &lt;= 链表长度 &lt;= 1000 方法 归并排序+伪头节点思路两个有序链表的排序很显然应该用归并排序进行解题。 我们需要一个头节点作为找到我们合并后链表的首节点的凭据，同时也是作为我们进行递归时移动的指针。 根据归并排序，当我们其中一个链表已经遍历完毕，另一个链表还没有遍历完毕时，不需要重新遍历另一个链表，利用链表的性质直接将其接在我们的新链表后面就可以了。 代码12345678910111213141516171819202122class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode *newlist = new ListNode(-1); ListNode * head = newlist; while(l1!=NULL &amp;&amp; l2!=NULL)&#123; if(l1-&gt;val &lt;= l2-&gt;val)&#123; newlist-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; newlist-&gt;next = l2; l2 = l2-&gt;next; &#125; newlist = newlist-&gt;next; &#125; if(l1) newlist-&gt;next = l1; if(l2) newlist-&gt;next = l2; return head-&gt;next; &#125;&#125;; 复杂度分析 时间复杂度$O(n)$。遍历两个链表，线性时间复杂度 空间复杂度$O(1)$。只使用了一个伪头节点，常数空间复杂度。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"概率模型检测","date":"2021-06-20T07:45:22.000Z","path":"2021/06/20/概率模型检测/","text":"对《Principles of Model Checking》一书概率模型检测部分的翻译。 未完成 先鸽了 模型检测技术一般着眼于绝对保证的正确性——“系统的失败是不可能的”——事实上，这种僵化的概念很难保证，或者说是不可能保证的。事实上，系统受制于一种随机性的多种现象，比如消息丢失或者混淆之类的，所以正确性——“99%概率上个系统不会失败”——正在变得没那么绝对。这一章节讨论了概率系统，也就是表现出概率性的系统，的自动化验证。概率层面对下面几种情况是非常至关重要的： 随机算法。 经典案例是分布式算法比如领导人选举或者共识算法（使用抛硬币实验打破过程之间的“对称性”，从而最终以概率1达成共识。） 对不可靠和不可预测系统行为的建模。比如消息丢失、处理器故障等现象可以用不确定性来进行建模。这通常适用于早期系统设计阶段，在该阶段中，系统被认为是高度抽象的，并且未明确指定有关可能性的信息（有时是故意的）。 但是，在以后的设计阶段中，内部系统的特征将变得更加占主导地位，概率是量化并改进此信息的有用工具。 基于模型的性能评估。由于性能评估旨在预测系统性能和可靠性，概率信息-消息传输延迟的分布是什么或处理器的故障率是多少？ —需要存在以评估定量属性，例如等待时间，队列长度，故障间隔时间等 为了建模随机现象，转移系统被赋予概率。这通过不同的几种方式实现。在离散时间的马尔科夫链（MCs）中，所有的选择是概率性的。马尔科夫链是最常用的用来评估信息处理系统的性能和可靠性的互操作模型。概括的讲，马尔科夫链就是对每个状态后继者的概率分布的转移系统。换句话说，下个状态会概率的进行选择，而不是不确定的进行选择。马尔科夫链不适用于随即分布式系统的建模，因为他们无法以适当的方式对并发系统的交错行为进行建模。为了这个目的，马尔科夫决策进程（Markov decision processes，MDPs）被使用。在MDPs中，不确定性和概率性选择共存。简而言之，MDPs是一个任何状态下，概率分布之间都存在一个不确定性选择的转移系统。一旦不确定性的选择了概率分布，就如同MCs中一样，将以概率方式选择了下一个状态。因此，任何MC都是在任何状态下唯一确定概率分布的MDP。随机分布算法通常都由MDP进行合适的建模，因为概率影响算法的只是一小部分，而不确定性用于进程之间进行交互的并发行为的建模。 概率系统的验证可以集中在定量性质或定性性质（或两者）上。 定量属性通常会限制某些事件的概率或期望。 定量属性的实例是，例如，要求在接下来的t个时间单位内传递消息的概率至少为0.98，或者在并发系统中寻找领导者的不成功尝试的预期次数最多为7。 另一方面，定性属性通常断言某个（好）事件几乎肯定会发生，即概率为1，或者两次断言，某个（坏）事件几乎不会发生，即概率为零。 马尔可夫模型的典型定性属性是可达性，持久性（最终是否总是会发生事件？）和重复可达性（是否可以重复达到某些状态？） 本章节目的是介绍离散时间的马尔科夫链和马尔科夫决策进程的定性和定量性质的主要验证原理。从分析可达性、持久性和重复可达性到CTL的概率性变体模型检测算法，称为概率计算树逻辑，简称为PCTL。此逻辑适用于以一种非常优雅的方式，表示一大类属性。例如属性“最终一个领导者将会以至少4/5的概率当选”在PCTL中将会被表述为： \\mathbb{P}_{\\geq0.8}(\\lozenge leader)另一种表述为： \\mathbb{P}_{\\geq0.015}(\\neg c.empty \\cup^{\\leq6} c.full)断言在所有6个中间配置c为非空的情况下，接下来6个步骤里通道被完全占用的概率被限制在0.015 除了PCTL中的分支时间属性之外，本章还介绍了线性时间属性。在PCTL中，概率是通过 $\\mathbb{P}$ 运算实现的，在线性时间设置中，概率概念仅仅出现在语义级别上。也就是说，在概率线性时间设置中，LTL公式用于指定所需的或者不好的行为，目的是建立给定的LTL公式成立的概率。因此，状态之间的满足关系不再是布尔值——公式在某个状态下是否满足——而是将一个概率值分配给了状态。本章涉及线性时间属性的验证，例如正则安全属性和$\\omega$安全属性。 与本专论的其余部分一致，我们采用了基于状态的概率模型视图。这意味着将马尔科夫链和马尔可夫决策过程视为有向图的变体。在该变体中，边（转移过程）使用随机信息进行赋值。这与许多教科书中将MC定义为随机变量序列相反。当将MCs和MDPs视作一个反应系统和时态逻辑结构的操作模型时，基于状态的方法（具有针对状态的原子命题）似乎更自然。由于马尔可夫模型的组合方法不在本专论的讨论范围之内，因此本章不涉及任何操作，因此将其省略。 马尔科夫链马尔科夫链表现为转移系统，唯一不同指出在于后继状态之间的不确定性选择被概率性选择所代替。也就是说，状态s的后继状态会根据概率分布进行选择。该概率分布仅仅取决于当前状态s，而不取决于比如从某些初始状态引导到该状态s的路径片段。因此，系统演变不取决于历史（即到目前为止已经执行的路径片段），而仅仅取决于当前状态s。这被称为无记忆属性。 定义1. （离散时间的）马尔科夫链（MC）一个（离散时间的）马尔科夫链是一个五元组$\\mathcal{M} = (S,\\mathbf{P},\\iota_{init},AP,L)$，其中 S是一个可数的、不为空的状态集合 $\\mathbf{P}$：$S \\times S \\rightarrow [0,1] $是转移概率函数，对于所有状态s，有 \\sum_{s'\\in S} \\mathbf{P}(s,s') = 1 $\\iota{init}$:$S \\rightarrow [0,1]$是初始分布，$$ \\sum\\limits{s\\in S} \\iota_{init}(s)=1 $$ AP是一个原子命题的集合，$L:S\\rightarrow2^{AP}$是一个标签函数 当$S$和$AP$是有限的时候，$\\mathcal{M}$被称为有限的。对有限的$\\mathcal{M}$,$\\mathcal{M}$的大小（表示为$size(\\mathcal{M})$)指的是状态的数量加上$(s,s’)$对的数量，其中$(s,s’)\\in S \\times S$并且$\\mathbf{P}(s,s’)&gt;0$。 转移概率函数$\\mathbf{P}$指定了每个状态s的概率$\\mathbf{P}(s,s’)$，该概率描述的是从再单独的一次转移中，状态$s$移动一步到$s’$的概率。==施加在$\\mathbf{P}$上的约束确保$\\mathbf{P}$是分布的。对于马尔可夫链的数学处理，非零的转移概率是否合理是无关就要的。==然而，处于算法目的，我们假定$\\mathbf{P}(s,s’)$的值对于所有的状态$s,s’\\in S$都是合理的。 $\\iota{init}$的值指定系统从状态s开始进行的概率。$\\iota{init}(s)&gt;0$的状态s被视作初始状态。类似的，$\\mathbf{P}(s,s’)&gt;0$的状态s‘被视为s的可能后继。对于状态$s$和$T\\subseteq S$，令$\\mathbf{P}(s,T)$表示从状态s转移一步到达某个状态$t\\in T$的概率。也就是说， \\mathbf{P}(s,T) = \\sum\\limits_{t\\in T} \\mathbf{P}(s,T).在==续集（sequel）==中，我们通常用矩阵$(\\mathbf{P}(s,t)){s,t\\in S}$来标识转移概率函数$\\mathbf{P}:S\\times S\\rightarrow [0,1]$。矩阵中状态$s$的行$\\mathbf{P}(s,·)$包含从$s$转移到其后继的概率，而状态$s$的列$\\mathbf{P}(·,s)$指定从任何其他状态进入状态$s$的概率。类似的，初始分布$\\iota{init}$通常被视作一个向量$(\\iota{init}(s)){s\\in S}$。 原子命题和标记函数$L$的使用和转移系统相同，本章的其余部分，我们通常将状态名视作原子命题，比如$AP = S$并且$L(s)={s}$。 当且仅当$\\mathbf{P}(s,s’)&gt;0$时，马尔科夫链才会产生一个底层有向图，其中状态充当顶点，并且从s到s’有一条边。在底层有向图中，马尔科夫链中的路径是最大（比如无限）路径。他们被定义为对所有$i\\geq0$下$ \\mathbf{P}(s_i,s_i+1)&gt;0$的无限状态序列$\\pi = s_0 s_1 s_2 ···\\in S^{\\omega} $。对于$\\mathcal{M}$中的路径$\\pi$ ，$inf(\\pi)$表示在$\\pi$中被无限经常次访问的状态集。对于有限马尔科夫链，$inf(\\pi)$对所有的路径$\\pi$非空。 马尔科夫链由他们的底层有向图表示，其中边上被赋予了[0,1]之间的转移概率。如果状态s有一个唯一后继s’，比如$\\mathbf{P}(s,s’)=1$，那么可以省略转移概率。 示例2. 一个简单的通信协议考虑一个使用通道的简单的通讯协议。参见图中的马尔可夫链，从消息可能会丢失的角度来看，这是非常容易出错的。在此，对于$s \\neq start$，$\\iota{init}(start)=1$并且$\\iota{init}(s)=0$，即$start$是独一无二的初始状态。在$start$状态，一条消息被生成并沿着通道被发送给独一无二的后继状态$try$。这个消息会有$\\frac{1}{10} $的概率丢失，那么消息会被重新发送，知道它最终被发送到。一但消息被正确地发送，系统会返回它的初始状态。 使用针对$start,try,lost,delivered$等状态的枚举，转移概率函数$\\mathbf{P}$被看作一个$4\\times 4$矩阵，初始分布被看作一个列向量。 \\mathbf{P} = \\begin{pmatrix} 0& 1& 0& 0\\\\ 0& 0& \\frac{1}{10}& \\frac{9}{10}\\\\ 0& 1& 0& 0\\\\ 1& 0& 0& 0 \\end{pmatrix} \\iota_{init} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}路径的一个示例为 \\pi = (start\\space try\\space lost\\space try\\space lost \\space try \\space delivered)^{\\omega}沿着这条路径，每条消息在送达之前要被重发两次。它是遵循$inf(\\pi)=S$。对于$T={lost,delivered}$,我们有$\\mathbf{P}(try,T)=1$。 示例3. 用公平硬币来模拟骰子考虑由Knuth和Yao最初提出的使用公平硬币来模拟6面骰子的行为，可以得到如图所示的马尔科夫链： 计算从初始状态$s0$开始，即对于所有状态$s\\neq s_0$，我们有$\\iota{init}(s0)=1$并且$\\iota{init}(s)=0$。底层的1，2，3，4，5和6状态表示了可能的骰子结果。每个内部节点表示扔了一个公平的硬币。如果结果为正面，左侧分支确定下一个状态，如果结果为反面，右侧分支确定为下一个状态。 如果处于状态$s0$时的抛硬币实验产生的结果为正面，则系统迁移至状态$s{1,2,3}$，再次投掷硬币以相等的概率导向状态$s{2,3}$(该状态骰子会以相等的概率产生2或者3) 或者状态$s’{1,2,3}$。从后面这种状态出发，投掷硬币会以$\\frac{1}{2}$的概率产生1，或者以$\\frac{1}{2}$的概率返回状态$s_{1,2,3}$。在初始状态下产生结果为反面的行为导致的结果是对称的。我们将会在后面对此进行确定，事实上，这个马尔科夫链可以充分地对一个骰子进行建模，即结果具有同等可能性。 示例4. 掷骰子赌博游戏游戏掷骰子时基于对两个骰子掷骰结果的投注。第一次投掷出来的结果决定是否需要再投一次。当结果投出来为7或11，游戏结束，玩家获胜，结果投出来为2，3或者12是”残次“，玩家输了。投出来的 结果为其他情况时，再投一次，但是第一次投出来的结果已经留存了（也就是点数）。如果下一轮投掷出7点或者上次投掷的点数，游戏结束，为7点时，玩家输掉，为上次投出来的点数时，玩家获胜。其他任何情况下，继续投骰子，直到最终获得7点或者那个结果位置。如图描述了掷骰子游戏行为的马尔科夫链。状态$start$是唯一的初始状态。我们有$\\mathbf{P}(start,won)=\\frac{2}{9}$,因为有8种成功的掷骰组合:$(1,6),(2,5),(3,4),(5,6)$以及相应对称的组合。其他转移概率以类似的方式确定。状态4，5，6，8，9和10处的自环回路对骰子的重新投掷进行建模。对于$T={4,5,6}$，我们有$\\mathbf{P}(s_0 ,T)=\\frac{1}{3}$。 示例5. Zeroconf协议IPv4的Zeroconf协议是为了家庭局域网应用（微波炉、笔记本电脑、VCR、DVD放映机等）设计的，每种设备都配有网络接口以实现相互通信。这样的自组织网络必须是热插拔并且可以自我配置的。覆盖所有这些应用，意味着将新设备（接口）连接到网络时，必须为其自动配置一个唯一的IP地址。Zeroconf协议以下述几种方式解决这个任务。主机需要从65024个可选地址中随机选择一个IP地址，比如说$U$进行配置，然后广播一条消息（称之为探测）“谁在使用地址$U$?”如果探测被一个已经在使用地址$U$的主机收到，它就会通过一条消息进行答复，表示$U$已经在使用了。收到此消息后，需要配置的主机重新启动：它再次随机挑选一个新的地址，广播一个探测信号······ 由于消息丢失或者主机繁忙，一个探测或者回复消息可能不能到达某些（或者所有）主机。为了增强协议的可靠性，一个主机需要发送$n$个探测信号，每个后面都要跟着一个$r$个时间单位的监听周期。因此，主机仅仅可以在n个探测都被发送，并且在$n·r$个时间单位内没有到回复之后，开始使用选择的IP地址。注意，在协议运行之后，主机仍然有可能会使用一个另外的主机正在使用的IP地址，如果说所有的探测都被丢失了。这种被称为地址冲突的情况是非常不希望的，因为他可能迫使主机终止活跃的TCP/IP链接。 单个主机的协议行为由包含$n+5$个状态的马尔科夫链进行建模（$n=4$的情况如上图所示），其中$n$时需要的探测的最大数量（如上所述）。初始状态是$s0$（标记为$start$）。在状态$s{n+4}$中（标记为$ok$），主机最终使用一个未被使用的IP地址并结束；在状态$s{n+2}$中（标记为$error$），主机使用一个正在使用的IP地址并结束，也就是地址冲突。状态$s_i(0&lt;i\\leqslant n)$在发射第$i$个探测后到达。在状态$s_0$主机随机选择一个IP地址。概率$q = m/65024$，其中m是链接入网络的主机的数量，这些地址是正在使用的。主机有$1-q$的概率选择一个未被使用的地址并且在状态$s{n+3}$结束。然后它在使用这个地址之前，要发射$n-1$个探测并且等待$n·r$个时间单元。（发送的这些探测以及等待时间从MC中抽象）。如果哦选择的IP地址已经是正在使用的了，就会进入状态$s_1$。现在两个情形是可能的。在$r$个时间单元内，有$p$概率什么回复都没有收到（因为探测信号或者应答信号已经丢失），并且下一个探测信号已经发送，那么就进入状态$s_2$。但是，如果一个应答及时被收到了，那么主机就会返回初始状态并且重新启动协议。这些状态$s_i(2\\leqslant i &lt;n)$的行为是类似的。但是如果在状态$s_n$中，没有应答在发送了第$n$个探测信号后的$r$个单元时间内被收到，那个一个地址冲突就发生了。 我们采用转移系统中的直接后继和直接前驱的概念，令$Paths(\\mathcal{M})$表示在马尔科夫链$\\mathcal{M}$中的路径，$Pahts{fin}(\\mathcal{M})$表示有限路径片段$s_0s_1···s_n$的集合，其中$n\\geqslant0$并且$\\mathbf{P}(s_i,s{i+1})&gt;0$对于所有的$0\\leqslant i0}$。同理,$Pre(s)={s’ \\in S | \\mathbf{P}(s’,s)&gt;0}$。$Post^(s)$表示所有从状态$s$通过一个有限路径片段到达的状态结合，$Pre^(s)={s’\\in S | s \\in Post^*(s’)}$。对于$B\\subseteq S$,令 Post^*(B)=\\bigcup_{s\\in B}Post^*(s)\\space\\space \\space \\space \\space \\space \\space \\space \\space \\space \\space Pre^*(B)=\\bigcup_{s\\in B}Pre^*(s)注释6. 吸收状态如果$Post^(s) = {s}$，那么马尔科夫链$\\mathcal{M}$的状态s被称为吸收*。如果$\\mathbf{P}$是一个随机矩阵，每一行的总和等于1，那么当且仅当$\\mathbf{P}(s,s)=1$并且对于所有的$t\\neq s$有$\\mathbf{P}(s,t)=0$，$s$是一个吸收状态。 备注7. 离散时间马尔科夫链示例8. 扔公平的硬币定义9. Cylinder 集定义10. 马尔科夫链的$\\sigma$-代数示例11. Cylinder 集注释12. 事件的LTL风格表示可达性概率示例13. 按无穷级数计算可达性概率示例14. 简单通信协议理论15. 最小不动点表征备注16. 膨胀法备注17. 选择$S{=0}$和$S{=1}$备注18. 几种不动点理论19. 独特的解决方案备注20. 矩阵$I-A$的非奇异性示例21. 掷骰子游戏中的可达性受到限制备注22. 暂态（Transient）概率示例23. 暂态概率的可达性定性属性备注24. 重复可达性和持久性的可测量性理论25. 概率选择作为强公平性注释26. 马尔可夫链的图形符号理论27. 马尔可夫链的极限行为示例28. Zeroconf协议（修订版）理论29. 几乎可以确定的可达性推论30. 全局几乎可以确定的可达性推论31. 定性约束可达性示例32. 定性约束可达性推论33. 定性重复可达性推论34. 定量重复可达性备注35. 无限马尔科夫链的定性性质概率计算树逻辑（Probabilistic Computation Tree Logic ）定义36. PCTL语法示例37. 在PCTL中指定属性定义38. PCTL的满足关系引理39. PCTL事件的可衡量性PCTL模型检测理论40. MC的PCTL模型检测的时间复杂度示例41. 反例PCTL的定性片段定义42. PCTL的定性片段定义43. 等价的PCTL和CTL公式引理44.引理45.引理46. 几乎可以肯定的重复可达性是PCTL定义的理论47. 重复可达概率是PCTL定义的理论48. 持久性概率是PCTL定义的线性时间性质定义49. LT属性的概率定义50. 产品马尔科夫链理论51. 安全性的定量分析理论52. DBS可定义属性的定量分析定义53. 确定性拉宾自动机（DRA）示例54. $\\square \\lozenge a$的DRA理论55. DRA和$\\omega- $正则语言理论56. 基于DRA的马尔科夫链分析备注57. $\\omega-$正则性质的可测量性理论58.PCTL* 和 概率互模拟PCTL*定义59. PCTL*语法概率互模拟定义60. 马尔可夫链的互模拟示例61. 马尔可夫链的互模拟定义62. 互模拟商示例63. 掷骰子游戏有代价的马尔科夫链成本受限的可达性长期属性马尔可夫决策过程可达性概率PCTL模型检测限制属性线性时间性质和PCTL*公平性总结","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://zijian.wang/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"模型检测","slug":"模型检测","permalink":"https://zijian.wang/tags/%E6%A8%A1%E5%9E%8B%E6%A3%80%E6%B5%8B/"}]},{"title":"《剑指offer》 21.调整数组顺序使奇数位于偶数前面","date":"2021-06-17T08:50:01.000Z","path":"2021/06/17/21. 调整数组顺序使奇书位于偶数前面/","text":"note：数组内凡是需要交换位置的题目，很容易想到双指针的解法，快慢指针、首尾指针都是常见的应用。 题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 示例： 123输入：nums = [1,2,3,4]输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 提示： 0 &lt;= nums.length &lt;= 50000 1 &lt;= nums[i] &lt;= 10000 方法一 双指针之快慢指针思路常见的快慢指针是行进速度（+1、+2）不同，不过这道题目中快慢指针则是指慢指针有时可以停下来。 这道题归根结底就是让双指针分别指向奇书偶数，如果跑得快的指针指向了奇数，跑的慢的指针指向了偶数，则进行交换。 代码1234567891011121314class Solution &#123;public: vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums) &#123; int slow=0,fast = 0; while(fast&lt;nums.size())&#123; if(nums[fast]%2==1)&#123; swap(nums[slow],nums[fast]); slow++; &#125; fast++; &#125; return nums; &#125;&#125;; 复杂度分析 时间复杂度$O(n)$。快指针要依次遍历所有的数 空间复杂度$O(1)$。没有使用额外空间 方法二 双指针之首尾指针思路同理，用两个指针找应该进行互换的元素。 不同的在于，我们让首指针去找第一个偶数，找到后不动，让尾指针去找第一个奇数，找到后进行交换，重复上述操作，直到首尾指针相遇。 代码123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums) &#123; int left = 0, right = nums.size() - 1; while (left &lt; right) &#123; if (nums[left]%2==1) &#123; left ++; continue; &#125; if (nums[right]%2==0) &#123; right --; continue; &#125; swap(nums[left++], nums[right--]); &#125; return nums; &#125;&#125;; 复杂度分析 时间复杂度$O(n)$。同理需要首尾指针遍历完所有的数 空间复杂度$O(1)$。不需要额外的空间。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 22.链表中倒数第k个节点","date":"2021-06-17T08:50:01.000Z","path":"2021/06/17/22. 链表中倒数第k个节点/","text":"notes： 链表问题优先考虑双指针 题目描述输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。 示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.返回链表 4-&gt;5. 方法：双指针思路链表和数组的最大区别就是由于存储的不连贯性，导致无法直接获取链表的长度以及根据类似下标的东西直接寻找的某个位置的值。但大多数这个问题可以用双指针来解决。 这道题寻找倒数第k个节点，我就只需要让一个指针先走k步，然后再让两个指针同时走，显然当先走的指针到达尾节点时，后走的指针刚好离尾节点还有k个位置。 代码123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* getKthFromEnd(ListNode* head, int k) &#123; ListNode* fast=head,*slow = head; while(k&gt;0 &amp;&amp; fast!=NULL)&#123; fast = fast-&gt;next; k--; &#125; while(fast!=NULL)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return slow; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$。只需要遍历一遍整个链表。 空间复杂度：$O(1)$。只需要额外一个指针。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 20.表示数值的字符串","date":"2021-06-16T16:15:01.000Z","path":"2021/06/17/20. 表示数值的字符串/","text":"note:这道题两种解法：确定有限状态自动机、if-else硬判断。前者状态机我认为是CS学生应该掌握的一种能力（编译原理中有用到），但是效率可能会有点慢。后者需要比较清晰的思维进行判断，当然基于状态机似乎也可以更好写一点。Ps.一鸽鸽一周，不愧是我！ 题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。 数值（按顺序）可以分成以下几个部分： 若干空格 一个小数或者整数 （可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个整数 若干空格 小数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-‘） 下述格式之一： 至少一位数字，后面跟着一个点 ‘.’ 至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字 一个点 ‘.’ ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-‘） 至少一位数字 部分数值列举如下： [“+100”, “5e2”, “-123”, “3.1416”, “-1E-16”, “0123”] 部分非数值列举如下： [“12e”, “1a3.14”, “1.2.3”, “+-5”, “12e+5.4”] 方法一：确定有限状态自动机（DFA）思路确定有限状态自动机是一种计算模型，对于虽然没学过编译原理，但是学过一点点形式化知识（模型检测）的我来说，是进行形式化建模分析验证的必备知识。确定有限状态自动机是一个能够实现状态转移的自动机，对于给定的属于该自动机的状态和一个属于自动机字母表$\\Sigma$。它可以根据事先给定的转移函数转移到下个状态。自动机$\\mathcal{A}$表述为五元组是： \\mathcal{A} = (Q,\\Sigma ,\\delta,s,F)其中： $Q$是一个非空有限状态的集合 $\\Sigma$是一个非空有限字符的集合 $\\delta$是一个单值映射的转移函数 $s$是一个开始状态，$s\\in Q$ $F$是一个接受状态集合，$F\\subseteq Q$ 稍微复习了自动机的知识之后，我们大概知道了自动机其实就是最重要的就是两大部分，状态和迁移，其中状态又分为开始状态、接受状态（终结状态）和其他状态，转移关系由转移字符和转移函数决定。 对于这道题，我们就要分析它都有那些状态，转移关系又是如何的： 初步分析状态可能有以下几种： 起始开头的空格 数字的符号位 数字的整数部分 小数点（左边有整数） 小数点（左边无整数） 小数部分 指数符号e\\E 指数部分的符号位 指数部分的数字部分 最后结束的空格 这里需要注意的是，上述状态中虽然有些状态内容是相同的，比如小数点（左边有整数）和小数点（左边无整数）、数字的整数部分和小数部分和指数部分的数字部分、开头和结尾的空格。但是他们依然属于不同的状态，这是因为他们的前驱状态与后继状态是完全不同的，甚至某些本身就有普通状态和接收状态的区分。所以一定要以不同的状态来看待，个人认为如何区分也是找出状态机较为复杂的一点。 接收状态也就是状态机的停止状态，分析我们可以得到5个接收状态：整数部分、小数点（左有整数部分）、小数部分、指数部分和结束状态。 总之经过对题目分析，我们可以得到最后的DFA如下图所示： 我们的转移条件抽象为了五种元素——空格、正负号、数字、小数点和指数标志E\\e 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108class Solution &#123; enum State&#123; STATE_INITIAL, STATE_SIGNAL, STATE_INTEGER, STATE_DOTPOINT, STATE_FRACTION, STATE_DOTPOINT_LEFTNONUM, STATE_EXP, STATE_EXPSIGNAL, STATE_EXPINTEGER, STATE_FINISH &#125;; enum Guard&#123; GUARD_SPACE, GUARD_NUM, GUARD_DOT, GUARD_E, GUARD_SIG, GUARD_ILLIGAL &#125;; Guard toGuard(char c)&#123; if(c==&#x27;+&#x27; || c==&#x27;-&#x27;) return GUARD_SIG; if(c==&#x27; &#x27;) return GUARD_SPACE; if(c==&#x27;.&#x27;) return GUARD_DOT; if(c==&#x27;e&#x27; || c==&#x27;E&#x27;) return GUARD_E; if(c&lt;=&#x27;9&#x27; &amp;&amp; c&gt;=&#x27;0&#x27;) return GUARD_NUM; else return GUARD_ILLIGAL; &#125;public: bool isNumber(string s) &#123; unordered_map&lt;State,unordered_map&lt;Guard,State&gt;&gt; trans&#123; &#123; STATE_INITIAL,&#123; &#123;GUARD_SPACE,STATE_INITIAL&#125;, &#123;GUARD_NUM,STATE_INTEGER&#125;, &#123;GUARD_DOT,STATE_DOTPOINT_LEFTNONUM&#125;, &#123;GUARD_SIG,STATE_SIGNAL&#125; &#125; &#125;,&#123; STATE_SIGNAL,&#123; &#123;GUARD_NUM,STATE_INTEGER&#125;, &#123;GUARD_DOT,STATE_DOTPOINT_LEFTNONUM&#125; &#125; &#125;,&#123; STATE_INTEGER,&#123; &#123;GUARD_E,STATE_EXP&#125;, &#123;GUARD_DOT,STATE_DOTPOINT&#125;, &#123;GUARD_NUM,STATE_INTEGER&#125;, &#123;GUARD_SPACE,STATE_FINISH&#125; &#125; &#125;,&#123; STATE_DOTPOINT,&#123; &#123;GUARD_E,STATE_EXP&#125;, &#123;GUARD_NUM,STATE_FRACTION&#125;, &#123;GUARD_SPACE,STATE_FINISH&#125; &#125; &#125;,&#123; STATE_DOTPOINT_LEFTNONUM,&#123; &#123;GUARD_NUM,STATE_FRACTION&#125; &#125; &#125;,&#123; STATE_FRACTION,&#123; &#123;GUARD_NUM,STATE_FRACTION&#125;, &#123;GUARD_E,STATE_EXP&#125;, &#123;GUARD_SPACE,STATE_FINISH&#125; &#125; &#125;,&#123; STATE_EXP,&#123; &#123;GUARD_SIG,STATE_EXPSIGNAL&#125;, &#123;GUARD_NUM,STATE_EXPINTEGER&#125; &#125; &#125;,&#123; STATE_EXPSIGNAL,&#123; &#123;GUARD_NUM,STATE_EXPINTEGER&#125; &#125; &#125;,&#123; STATE_EXPINTEGER,&#123; &#123;GUARD_NUM,STATE_EXPINTEGER&#125;, &#123;GUARD_SPACE,STATE_FRACTION&#125; &#125; &#125;,&#123; STATE_FINISH,&#123; &#123;GUARD_SPACE,STATE_FINISH&#125; &#125; &#125; &#125;; State state = STATE_INITIAL; for(auto c:s)&#123; Guard guard = toGuard(c); if(trans[state].find(guard)==trans[state].end()) return false; state = trans[state][guard]; &#125; return state==STATE_INTEGER || state==STATE_DOTPOINT || state==STATE_FRACTION || state==STATE_EXPINTEGER || state==STATE_FINISH; &#125;&#125;; 友情提示：在使用enum类型时，最好将state和guard进行区分，不然容易弄混。 复杂度分析 时间复杂度:$O(n)$。n为字符串长度 空间复杂度$O(1)$。我们只需要常数级别的状态转移表。 方法二：if-else分析解法思路很容易想到也很容易出错的一个想法，由于数字有四种元素组成，所以我们用四个变量来判断前面是否出现过数字、正负号、E/e以及小数点。去除掉前面的空格后，我们就可以对剩下的字符进行遍历，由于数字中间不能出现空格， 所以一但出现空格我们就可以跳出遍历，然后对剩下遍历，只需要看是否全是空格，不是则返回false。 难度就在中间如何进行循环遍历了： 如开头分析，数字由0-9整数、正负号、E/e和小数点组成，那中间的循环遍历我们需要做的就是判断每一个字符属于那种元素，而这种元素出现在这个位置是否合法。接下来逐个分析四种元素的合法出现前提： 0-9的数字：显然0-9的数字是可以连续重复并独自出现的，连续重复意味着我们可以用while循环直接遍历，直到不是数字或者到了字符串尽头；独自说明它不要求有什么前置条件。所以当这种元素出现时，我们不用在乎之前出现的字符如何，只需要在这种元素出现之后，将出现过数字的标志置为true，因为它可能会影响其他元素的合法性 正负号：正负号合法出现的位置有两个，一是在整数部分的最前面（也就是0-9数字、小数点、正负号、e/E都没出现过），二是在指数部分最前面，但是它不能出现在整数部分或者小数部分之后。那么这里就是有一个冲突就是如果正负号没有出现在整数部分的最前面，而是出现在了指数部分最前面，那么它前面的整数和小数点一定出现过了。这时就需要我们分析其他条件——e/E的存在。 e/E：e/E作为指数部分出现的前兆与底数部分的结束，必须要求前面一定至少出现过整数部分，并且一定不能出现过自身。也就是0-9的数字的标志不能是false以及e/E的标志一定不能是true。而在出现之后，我们肯定要将e/E的标志置为true。同时我们回过头考虑正负号的问题，如果我们在e/E出现之后，重置0-9数字标志、小数点标志以及正负号标志为false，就可以将正负号的第二种可能归并到第一种位置。 小数点：小数点出现的位置要求两点，第一是之前没有出现过小数点，二是之前没出现过e/E。所以要求这两个标志不能为true。 虽然到这里已经分析完了四种元素，但其实不排除输入中还有一些空格，面对这种情况，我们可以遇到空格直接跳出遍历。空格只有两种可能，一种是后面的全是空格，另一种是后面还有其他成分。那我们就可以直接单独遍历剩下元素，直到不是空格，然后判断是否到达了字符串末尾，来看是否符合要求。 最后还有一个特殊情况就是我们不允许整个字符串中没有出现一个0-9数字，所以我们在最后需要判断一下，数字是否曾经出现过。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: bool isNumber(string s) &#123; int n = s.size(); bool hasNum = false, hasE = false, hasSign = false, hasDot = false; int i = 0; /* 去除前导空格 */ while(s[i]==&#x27; &#x27; &amp;&amp; i&lt;n)&#123; i++; &#125; if(i==n) return false; while (i &lt; n) &#123; while(s[i]&gt;=&#x27;0&#x27; &amp;&amp; s[i]&lt;=&#x27;9&#x27; &amp;&amp; i&lt;n)&#123; hasNum = true; i++; &#125; if(i==n) break; if(s[i]==&#x27;e&#x27; || s[i]==&#x27;E&#x27;)&#123; if(hasE || !hasNum)&#123; return false; &#125; hasE=true; hasDot=true; hasSign=false; hasNum=false; &#125; else if(s[i]==&#x27;+&#x27; || s[i]==&#x27;-&#x27;)&#123; if(hasSign||hasNum||hasDot) return false; hasSign=true; &#125; else if(s[i]==&#x27;.&#x27;)&#123; if(hasDot || hasE) return false; hasDot = true; &#125;else if(s[i]==&#x27; &#x27;) break; else return false; i++; &#125; while(i&lt;n &amp;&amp; s[i]==&#x27; &#x27;) i++; return i==n &amp;&amp; hasNum; &#125;&#125;; 复杂度分析 时间复杂度$O(n)$。遍历完了整个字符串 空间复杂度$O(1)$。除了四个标志变量，没有使用额外空间。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 18.删除链表的节点","date":"2021-06-08T13:38:01.000Z","path":"2021/06/08/18. 删除链表的节点/","text":"note:一般在删除链表或者插入链表时，会采用一种虚假头节点的方法，来方便对头节点的处理。 题目描述给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 注意：此题对比原题有改动 示例 1: 123输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 123输入: head = [4,5,1,9], val = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明： 题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点 方法一 引入虚假头节点+双指针思路由于我们在进行删除某个特定节点时，一般选用的方法是找到它前面的一个节点，迭代着找这个节点。但是当要删除的节点正好是头节点时，本身没有前面一个节点的头节点的删除策略就不一样了。 但是如果我们引入一个虚假的头节点，就可以避免它的特殊处理。 由于我们需要记录要删除节点的前一个节点，所以我们使用双指针方法，用一个指针记录这个前一个节点。 代码12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteNode(ListNode* head, int val) &#123; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* pre = dummy; ListNode* cur = head; while(cur!=NULL &amp;&amp; cur-&gt;val!=val )&#123; cur = cur-&gt;next; pre = pre-&gt;next; &#125; if(cur!=NULL)&#123; pre-&gt;next = cur-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;; 复杂度分析 时间复杂度$O(n)$。最坏情况要遍历所有的节点 空间复杂度$O(1)$。虽然额外使用了一个虚假头节点，但是依然只是常数级复杂度。 方法二 引入虚假头节点+单指针思路事实上，我们不是一定要用两个指针分别指向要删除节点和前一个节点的。 因为虽然我们没有办法从要删除的节点倒推它的前一个节点，但是我们可以反过来使用前一个节点进行遍历判断它的后一个节点是否需要删除。 代码123456789101112131415161718class Solution &#123;public: ListNode* deleteNode(ListNode* head, int val) &#123; ListNode* dummynode = new ListNode(-1); ListNode* cur = dummynode; dummynode-&gt;next = head; while(cur-&gt;next!=NULL&amp;&amp;cur-&gt;next-&gt;val!=val)&#123; cur = cur-&gt;next; &#125; if(cur-&gt;next!=NULL) cur-&gt;next = cur-&gt;next-&gt;next; return dummynode-&gt;next; &#125;&#125;; 复杂度分析 时间复杂度$O(n)$。同理。 空间复杂度$O(1)$。同理。 方法三 不使用虚假头节点思路如果不使用虚假头节点，我们处理头节点的方法就是提前分析头节点是否是要删除的节点，如果是，就直接把头结点的下一个节点作为头节点，返回。 代码1234567891011121314151617class Solution &#123;public: ListNode* deleteNode(ListNode* head, int val) &#123; if(!head) return head; if(head-&gt;val==val) return head-&gt;next; ListNode* cur = head; while(cur-&gt;next!=NULL &amp;&amp; cur-&gt;next-&gt;val!=val)&#123; cur = cur-&gt;next; &#125; if(cur-&gt;next!=NULL) cur-&gt;next = cur-&gt;next-&gt;next; return head; &#125;&#125;; 复杂度分析 时间复杂度$O(n)$。同理。 空间复杂度$O(1)$。同理。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 19.正则表达式匹配","date":"2021-06-08T11:27:01.000Z","path":"2021/06/08/19. 正则表达式匹配/","text":"note:两个字符串匹配的问题，经典的解法就是使用二维dp数组进行动态规划求解，因为显然字符串匹配就是一个可以分解为小问题、依赖小问题来解决大问题的问题。 题目描述请实现一个函数用来匹配包含’. ‘和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但与”aa.a”和”ab*a”均不匹配。 示例 1: 12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2: 12345输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: 因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。 示例 3: 12345输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。 示例 4: 12345输入:s = &quot;aab&quot;p = &quot;c*a*b&quot;输出: true解释: 因为 &#x27;*&#x27; 表示零个或多个，这里 &#x27;c&#x27; 为 0 个, &#x27;a&#x27; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 示例 5: 1234输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;输出: false s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母以及字符 ‘.’ 和’*‘，无连续的 ‘*’。 方法一： 二维动态规划思路两个字符串的匹配问题，可以转换为二维动态规划问题。 两个字符串的匹配是非常复杂的，但是单个的字符匹配是简单的，动态规划解决字符串匹配的问题的关键就是考虑到，我们可以转化的小问题，是匹配两个字符串的各个子串。 我们考虑使用dp[m][n]数组来表示动态规划存储的匹配方案，$dp[i][j]$表示$s$前$i$个字符和$p$前$j$个字符是否可以匹配。 接下来我们分情况进行讨论 $p$的第$j$ 个字符是字母。由于$s$中都是字母，那么很显然如果当前两个字符相同，前面的子串可以匹配，那自然新的子串也可以进行匹配。这种情况的状态转移方程非常简单： dp[i][j] = \\begin{cases} dp[i-1][j-1],\\ \\ \\ \\text {if} \\ s[i]=p[j]\\\\ false,\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\text {if} \\ s[i] \\neq p[j] \\end{cases} $p$的第$j$个字符是’.’。由于’.’可以匹配任何一个字符，那它的转移方程更为简单： dp[i][j] = true $p$的第$j$个字符是’*‘。这种情况就比较复杂了，因为’*‘的匹配规则是“它前面的字符可以出现任意次（含0次）”也就是说$p$第$j$个位置出现*号时我们就要考虑第$j-1$个字符的情况。此时我们可以列出来该字符出现若干次时的状态转移 出现0次：$dp[i][j] = dp[i][j-2]$。含义就是既然我第$j-1$个字符没有出现，那么我$s$字符串中的第$i$个字符就不应该和我第$j-1$个字符进行匹配，而应该和再往前一个字符匹配，也就是第$j-2$个字符。 出现1次并且和$s$中的第$i$个元素成功匹配：$dp[i][j]=dp[i-1][j-2]$，向前匹配 出现2次并且和$s$中的第$i$个、第$i-1$个元素成功匹配：$dp[i][j] = dp[i-2][j-2]$,继续向前匹配 ········· 根据这个过程，我们可以得出一个状态转移方程 f[i][j] = \\begin{cases} dp[i-1][j]\\ || \\ dp[i][j-2], \\ \\ \\text {if} \\ s[i]=p[j-1]\\\\ dp[i][j-2], \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\text {if} \\ s[i] \\neq p[j-1] \\end{cases}理解为当$p$中第$j-1$个元素不等于$s$中第$i$个元素时（匹配失败），就将第$j-1$个元素视作出现0次处理。将$s$中的第$i$个元素和$p$中的第$j-2$个元素对比，如果匹配成功，则考虑多种情况，既有可能虽然匹配成功，但是该元素不一定要出现（0次出现），也有可能该次出现有效，往前溯源看前面是否相同。 最后的话我们总结三种状态转移方程，得到一个整体的转移方程如下： dp[i][j] = \\begin {cases} dp[i-1][j] || dp[i][j-2], \\ \\ \\ \\text{if}\\ p[j]==*\\ \\&\\&\\ match(s[i],p[j-1])\\\\ dp[i][j-2], \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\text{if}\\ p[j]==*\\ \\&\\&\\ !match(s[i],p[j-1])\\\\ dp[i-1][j-1], \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\text{if}\\ p[j]!=*\\ \\&\\&\\ match(s[i],p[j])\\\\ false,\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\text{if}\\ p[j]!=* \\ \\&\\&\\ !match(s[i],p[j-1]) \\end {cases}match(x,y)是我们做的匹配过程，为了提高程序的复用性，我们可以写成c++11标准中的lambda表达式，lambda表达式用于定义并创建匿名的函数对象，以简化编程。使用格式如下： 123[函数对象参数] (操作符重载函数参数) mutable -&gt;返回类型 &#123; 函数体&#125;； 具体介绍和使用我后面会写一篇额外的博客，这儿就不赘述了。 代码12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: bool isMatch(string s, string p) &#123; int m=s.size(),n=p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m+1,vector&lt;bool&gt;(n+1)); auto match = [&amp;](int x,int y)&#123; if(x==0) return false; if(p[y-1]==&#x27;.&#x27;) return true; else return s[x-1]==p[y-1]; &#125;; dp[0][0] = true; // 长度为0的两个子串匹配必然匹配得上 for(int i=0;i&lt;=m;i++)&#123; //s字符串从零匹配 for(int j=1;j&lt;=n;j++)&#123; //p字符串考虑从1开始，因为*号不可能出现在0位置 if(p[j-1]==&#x27;*&#x27;)&#123; dp[i][j] = dp[i][j-2]; // 加入j-2的位置的元素出现为0次。 if(match(i,j-1))&#123; dp[i][j] = dp[i][j] || dp[i-1][j]; &#125; &#125;else&#123; if(match(i,j))&#123; dp[i][j] = dp[i-1][j-1]; &#125; &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 复杂度分析 时间复杂度$O(mn)$。m、n分别为字符串长度 空间复杂度$O(mn)$。dp数组的大小为m*n","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 17.打印从1到最大的n位数","date":"2021-06-08T02:28:01.000Z","path":"2021/06/08/17. 打印从1到最大的n位数/","text":"note: 有点搞不懂这道题是为了考什么，快速幂？《剑指》上面讲的是大数问题，就把大数问题的写法也学习了一下记录下来。 题目描述输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例 1: 12输入: n = 1输出: [1,2,3,4,5,6,7,8,9] 说明： 用返回一个整数列表来代替打印 n 为正整数 方法一 普通暴力思路用10的n次幂，来循环得到值。 代码123456789101112class Solution &#123;public: vector&lt;int&gt; printNumbers(int n) &#123; vector&lt;int&gt; ans; int max_num = pow(10,n)-1; for(int i=1;i&lt;=max_num;i++)&#123; ans.push_back(i); &#125; return ans; &#125;&#125;; 复杂度分析 时间复杂度$O(10^n)$。显然需要遍历$10^n$个数 空间复杂度$O(1)$。不用什么额外空间 方法二 快速幂思路快速幂的思路，前面已经讲了几遍了，公式是 x^n= \\begin{cases} (x \\times x)^{n//2} \\ \\ \\ \\text{if}\\ \\ \\ x \\text 为偶数 \\\\ x \\times (x \\times x)^{n//2} \\ \\ \\ \\text {if}\\ \\ x \\text 为奇数 \\end{cases}代码123456789101112131415161718192021class Solution &#123; int quickPow(int x,int n)&#123; int res=1; while(n)&#123; if(n&amp;1) res = res*x; x *= x; n = n &gt;&gt; 1; &#125; return res; &#125;public: vector&lt;int&gt; printNumbers(int n) &#123; vector&lt;int&gt; ans; int max_num = quickPow(10,n)-1; for(int i=1;i&lt;=max_num;i++)&#123; ans.push_back(i); &#125; return ans; &#125;&#125;; 复杂度分析 时间复杂度$O(10^n)$。显然需要遍历$10^n$个数 空间复杂度$O(1)$。不用什么额外空间 方法三 大数情景思路假如返回值不为int数组，则有可能存在大数问题。大数问题一般只能用string类型来存储，因为无论int、long long都有可能无法满足大数的需求。 string字符串做不到+1自动进位，就需要我们进行手动判断。这无疑是非常耗时的，尤其是形如99999这样的数字+1需要判断的位数非常之多。所以换个角度，要求从1到最大n位数的所有数，其实本质上也就是求n位0~9的一个全排列问题，再将全排列可能出现的，前置0的情况去掉0，就得到了我们要的结果。 全排列我们可以利用分治算法的思想进行解决，先固定高位，再递归解决低位，一直到个位固定后，我们就可以将生成的大数进行“去除前置0”的判断和操作，并放入数组或者放入存放答案的字符串。 代码1234567891011121314151617181920212223242526272829303132class Solution &#123; string s; vector&lt;int&gt; ans; //string ans;public: vector&lt;int&gt; printNumbers(int n) &#123; s.resize(n,&#x27;0&#x27;); dfs(n,0); //return ans.substr(0,ans.length()-1); return ans; &#125; void dfs(int n,int index)&#123; if(index==n)&#123; save(); return; &#125; for(int i=0;i&lt;=9;i++)&#123; s[index] = i+&#x27;0&#x27;; dfs(n,index+1); &#125; &#125; void save()&#123; int start = 0; while(start&lt;s.size()&amp;&amp;s[start]==&#x27;0&#x27; ) start++; if(start!=s.size())&#123; // 可以帮助我们去除0 //ans = ans + s.substr() + &quot;,&quot;; ans.emplace_back(stoi(s.substr(start))); &#125; &#125;&#125;; *注释的内容为返回值为string类型时的写法。 复杂度分析 时间复杂度$O(10^n)$。因为排列数量有 $10^n$ 空间复杂度$O(n)$。返回数组的空间不算的话，额外空间就是字符串string。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 16.数值的整数次方","date":"2021-06-07T14:11:01.000Z","path":"2021/06/07/16 数值的整数次方/","text":"note:快速幂是一个常用经典需要好好掌握的知识点。另外此题中如何处理指数为负数的情况的方法值得总结 题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。 示例 1： 12输入：x = 2.00000, n = 10输出：1024.00000 示例 2： 12输入：x = 2.10000, n = 3输出：9.26100 示例 3： 123输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25 提示： $-100.0 &lt; x &lt; 100.0$ $-2^{31} &lt;= n &lt;= 2^{31}-1$ $-10^4 &lt;= x^n &lt;= 10^4$ 方法 快速幂算法思路快速幂的思想在前面几道题也有所记录，其实本质它是一种二分的思想，将复杂度为$O(n)$的循环求余的方法，复杂度精简到了$O(logn)$。 根据二分推导$x^n = x^{n/2}\\times x^{n/2}=(x^2)^{n/2}$，我们的指数显然存在两种情况： n为偶数：$x^n = (x^2)^{n//2}$（//表示整除） n为奇数:$x^n=x(x^2)^{n//2}$ 据此，我们可以通过循环$x=x^2$操作，每次幂都会从$n$降至$n//2$，直至n变为0； 那我们可以用一个变量存储出现奇数时单独计算多出的一项$x$，从而让我们的循环可以持续进行。 判断奇数偶数的办法可以用求余，也可以用位运算$n\\&amp;1$。 此题另外一个有趣的地方在于对于负指数的处理，很简单的解决方法就是将指数转换为$(-1)(-n)$，也就可以将$x^n$转换为$x^{-1}x^{-n}$。 还有一个问题就是由于n的范围在$[-2^{31},2^{31}-1]$。所以存在当$n=-2^{31}$的时候，直接取反会溢出的情况，所以最好将n转换为long long型参与计算。 代码123456789101112131415161718192021class Solution &#123;public: double myPow(double x, int n) &#123; if(x==0) return 0; long long a = n; double res = 1; if(a&lt;0)&#123; x = 1/x; a = -a; &#125; while(a)&#123; if(a%2==1) res = res*x; x = x*x; a/=2; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度$O(logn)$。快速幂的二分思想，让我们的时间复杂度变为$logN$ 空间复杂度$O(1)$。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 15.二进制中1的个数","date":"2021-06-07T02:52:01.000Z","path":"2021/06/07/15 二进制中1的个数/","text":"note:两个特质： 与运算的定义： 若$n\\&amp;1=0$，则$n$的二进制中最右一位为0 若$n\\&amp;1=1$，则$n$的二进制中最右一位为1 $n\\&amp;(n-1)$：表示二进制数字$n$最右边的1变为0，其余不变 因为$(n-1)$表示二进制数字$n$最右边的1变为0，此1右边的0都变为1 题目描述请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。 示例 1： 123输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。 示例 2： 123输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。 示例 3： 123输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。 提示： 输入必须是长度为 32 的 二进制串 。 方法一：按位遍历思路按位遍历，利用$n\\&amp;1$来判断最右边是否为1，然后进行无符号右移，直到二进制中不存在1为止。 代码1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int res=0; while(n)&#123; res += n&amp;1; n &gt;&gt;= 1; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度$O(logn)$。按位遍历的循环过程需要循环$logn$，其中$n$表示最高位1所在的位数 空间复杂度$O(1)$。 方法二：巧用$n\\&amp;(n-1)$思路利用$n\\&amp;(n-1)$能将二进制数字的最右边的1变为0的性质，循环消去最右的1，计算要几次消完，就说明有几个1 代码1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int res=0; while(n)&#123; res++; n = n&amp;(n-1); &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度$O(M)$。M为二进制中1的个数。 空间复杂度$O(1)$。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 14.剪绳子","date":"2021-06-06T13:40:01.000Z","path":"2021/06/06/14 剪绳子/","text":"note: 动态规划有四个特点 求最优解 整体问题的最优解依赖于各个子问题的最优解 大问题可以分解为若干个小问题，这些小问题之间还存在重叠的更小的子问题 从上往下分析问题，从下往上求解问题 ——摘自《剑指offer》 题目描述给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为$ k[0],k[1]…k[m-1] $。请问 $k[0]k[1]…*k[m-1] $可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例 1： 123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示： 2 &lt;= n &lt;= 58 方法一 动态规划思路分析问题，剪绳子问题，只给出了绳子的总长度，没有给要剪成几段，只是要求整数长度，以及剪完之后的所有子绳子的长度乘积最大。 分析每次剪绳子，假设我要减的绳子长度为$n$，我剪了$i$，则剩余$n-i$长度，那么他们的乘积为$i(n-i)$，此题目要求乘积最大，就是$i(n-i)$最大。但是问题是$i,j$同样是不定的，他们也要再被剪，剪的规则同样是上述的规则，所以很容易得出递推公式如下： f(n) = max(f(i)*f(n-i))显然这个递推公式如果直接用递归等做法就会有大量重复计算，所以我们可以使用动态规划的求法，反向进行求解并记录子问题的结果。 状态转移方程： dp[n] = max(dp[i]*dp[n-i]) 初始状态：分析以下我们的动态规划过程，我们为了求乘积，默认了一件事，就是长度为$i$的绳子至少分为两段。也就是说我们不考虑子绳子的长度为0——也就是不剪的情况。但是事实上我们很容易发现，在$n&lt;=3$时，不剪的情况反而是乘积最大的情况(具体推导是基本不等式)——事实上问题就在于，一刀不剪不代表产生了一个长度为0的子绳子和一个长度为i的子绳子，而是仅仅只有一个子绳子，乘积应该为绳长本身。那么根据上述分析，我们可以需要总结出4个初始状态，分别是 dp[0] = 0; dp[1] = 1; dp[2] = 2; dp[3] = 3; 返回值dp[n]。 通过上文的分析，我们会发现，本质上我们的状态转移方程还存在问题，实际上是利用了长度大于等于4的绳子的子绳子乘积比绳子本身要大这一推断，但是状态转移方程直接没有考虑可能存在的绳子本身的长度大于任何子绳子乘积的这一情况，也就是状态转移方程默认绳子必须要剪。所以我们需要4个初始状态，来完善我们的动态规划，（这也是《剑指offer》一书中提供的解法）。但实际上我们题目中有条件$m&gt;1$，也就是说第一次一定要剪，那么我们其实是需要对$n&lt;4$的情况做一个特殊处理的，这个特殊处理是 123456if(n&lt;2) return 0;if(n==2) return 1;if(n==3) return 2; 代码123456789101112131415161718192021222324252627class Solution &#123;public: int cuttingRope(int n) &#123; if(n&lt;2) return 0; if(n==2) return 1; if(n==3) return 2; vector&lt;int&gt; dp(n+1); dp[0] = 0; dp[1] = 1; dp[2] = 2; dp[3] = 3; int temp=0; for(int i=4;i&lt;=n;i++)&#123; temp=0; for(int j=1;j&lt;=i/2;j++)&#123; // 小技巧，j无需遍历[1,i)，因为剩下的和剪去的是镜像对称的。 temp = max(temp,dp[j]*dp[i-j]); dp[i] = temp; &#125; &#125; return dp[n]; &#125;&#125;; 复杂度分析 时间复杂度$O(n^2)$。从4到n的每一个整数都要计算对应的dp值，计算一个整数对应的dp值需要的是$O(n)$的时间复杂度，所以总时间为$O(n^2)$ 空间复杂度$O(n)$。其中，n是给定的正整数。创建一个数组dp，长度为n+1 方法二 另一种动态规划思路我们还有一种状态转移方程的写法可以不需要这么多初始状态与特殊处理。 状态转移方程： dp[n] = \\max\\limits_{1","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 13.机器人的运动范围","date":"2021-06-05T13:57:01.000Z","path":"2021/06/05/13 机器人的运动范围/","text":"note:此类型题目（路径搜索）一般深度优先搜索和广度优先搜索是最优解。方向数组也是常用的小技巧。 题目描述地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1： 12输入：m = 2, n = 3, k = 1输出：3 示例 2： 12输入：m = 3, n = 1, k = 0输出：1 提示： $1 &lt;= n,m &lt;= 100$ $0 &lt;= k &lt;= 20$ 方法一：深度优先搜索思路这道题和12题十分类似，也是一个矩阵，但是不同之处在于12题要求搜索一个字符串，本题确实要求你找可达范围。注意题目中，不能进入行坐标和列坐标数位之和大于k的格子这句条件。这句条件其实是帮助我们给定了一个递归边界。或者说，对于路径搜索类的题目，这句话其实是给了障碍物的所在。 先讨论这个条件如何计算，如果仅仅针对这道题，也就是$1&lt;=n,m&lt;=100$，在这种情况下，坐标$i,j$的大小在0-99之间，计算是非常方便的$i\\%10+i/10+j\\%10+j/10$就是我们需要的数位之和。 如果题目没有给出限制，我们就需要来写一个函数进行处理，比如 12345678int sumfun(int i)&#123; int sum=0; while(i&gt;0)&#123; sum += i%10; i /= 10; &#125; return sum;&#125; 最后的结果就是sumfun(i)+sumfun(j)。 然后分析我们的递归函数如何写，递归的思想就是将大问题，分解成子问题，最重要的就是如何把握递归边界，如何进行合理剪枝（访问过的不要再访问）。访问过的不要再访问这一个需求，就需要我们建立一个二维数组，来记录是否访问。不同于12题中回溯的做法，我们该题目中问的问题是所能到达的所有格子，所以我们不需要进行回退操作，那样会导致重复计算。 递归边界：显然首先是$i,j$不能超出矩阵；其次是$i,j$不能走到障碍物上；最后就是访问过的不能再访问以防止重复计算 递归过程：修改访问矩阵，表明某个格子已经访问过了；然后递归求解子问题，即向四周进行递归，这里存在一个优化，就是由于我们从（0，0）开始，所以我们开始都是向右、或者向下走，然后由于障碍物跟行列坐标息息相关，很容易发现，所有的障碍物格子，都可以由左方或上方的格子移动一步得到，因此我们可以将搜索方向缩减为向右或向下（具体参考力扣题解中的动图）；最后要在向左、向下两个子问题的结果上再加一，表示该层递归格子本身也是一个可访问的格子。 代码123456789101112131415161718192021class Solution &#123; int num=0; int dfs(vector&lt;vector&lt;int&gt;&gt; &amp;map,int i,int j,int m,int n,int k)&#123; int sum=0; if(i&lt;0 || i&gt;=m || j&lt;0 || j&gt;=n || i%10+i/10+j%10+j/10 &gt; k || map[i][j]==1) return 0; map[i][j]=1; sum = 1 + dfs(map,i+1,j,m,n,k) + dfs(map,i,j+1,m,n,k); //map[i][j]=0; return sum; &#125;public: int movingCount(int m, int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; map(m,vector&lt;int&gt;(n,0)); int ans=0; ans = dfs(map,0,0,m,n,k); return ans; &#125;&#125;; 复杂度分析 时间复杂度$O(MN)$。此处的$MN$分别表示$m$和$n$。因为显然我们整个矩阵中的每个元素都要进入递归，来看一下是否满足需求。 空间复杂度$O(MN)$。因为我们需要创建一个矩阵来记录每个格子是否访问过。 方法二：广度优先搜索思路广度优先搜索是使用队列这一数据结构进行搜索的。每次访问到一个格子，要做到以下几步操作： 从队列首取出某个格子，出队，分别访问它的右、下两个格子 如果这个格子符合要求（不超边界、非障碍、未访问），将这个格子放入队列中， 将这个格子标记为已访问 可访问格子数增加。 广度优先搜索和深度优先搜索的主要区别是一个是把同层的全部进行访问后再访问下一层，另一个是一直向下访问直到走不动再回去访问下一个。 这里还有一个小技巧是方向数组，经常用在搜索算法中，在C/C++中可以用二维数组来表示方向。例如二维数组a[x][y]含义就是方向数组中存放了x个向量，y表示每个向量有有y维（y一般为2）。比如我们要访问右边和下边的格子，就是向右方下方移动，所以可以设置二维数组d[2][2] = &#123;(0,1),(1,0&#125;)。这个由于方向简单，也可以写为dx[2] = &#123;0,1&#125;,dy[2]=&#123;1,0&#125;。 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: int movingCount(int m, int n, int k) &#123; if(!k) return 1; queue&lt;pair&lt;int,int&gt;&gt; que; que.push(make_pair(0,0)); vector&lt;vector&lt;int&gt;&gt; visited(m,vector&lt;int&gt;(n,0)); visited[0][0] = 1; int dx[2] = &#123;0, 1&#125;; int dy[2] = &#123;1, 0&#125;; int ans=1; while(!que.empty())&#123; auto [x,y] = que.front(); que.pop(); for(int i=0;i&lt;2;i++)&#123; int tx = x + dx[i]; int ty = y + dy[i]; if(tx&lt;0 || tx&gt;=m || ty&lt;0 || ty&gt;=n || tx%10+tx/10+ty%10+ty/10&gt;k||visited[tx][ty]==1) continue; que.push(make_pair(tx,ty)); visited[tx][ty] = 1; ans++; &#125; &#125; return ans; &#125;&#125;; 复杂度分析 时间复杂度$O(MN)$。同样我们需要访问数组的所有格子。 空间复杂度$O(MN)$。同样我们需要记录访问过的格子。当然还有一个空间就是队列的空间，该空间同样是$MN$的复杂度 方法三： 递推思路我们提到我们的搜索方向只有向下或者向右，那么也就是说每个格子是否可达其实依赖于它的上方或者左方是否可达，我们可以得到一个递推关系式，即： visited[i][j] = visited[i-1][j] || visited[i][j-1]当然这是在不考虑障碍物的情况，所以我们可以根据递推关系式和障碍物的条件，推出整个visited矩阵的情况，在同一时间，我们就也得到了可达的格子数目。 代码1234567891011121314151617181920class Solution &#123;public: int movingCount(int m, int n, int k) &#123; if(!k) return 1; vector&lt;vector&lt;int&gt;&gt; visited(m,vector&lt;int&gt;(n,0)); visited[0][0] = 1; int ans = 1; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(i==0 &amp;&amp; j==0 || i%10+i/10+j%10+j/10&gt;k) continue; if(i-1&gt;=0) visited[i][j] |= visited[i-1][j]; if(j-1&gt;=0) visited[i][j] |= visited[i][j-1]; ans += visited[i][j]; &#125; &#125; return ans; &#125;&#125;;= 复杂度 时间复杂度$O(MN)$。同样需要遍历所有的格子 空间复杂度$O(MN)$。同样需要同样大小的存储空间，但是此方法不需要队列的存在，也不需要递归的空间。所以空间上来说是更优的。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 12.矩阵中的路径","date":"2021-06-04T08:26:01.000Z","path":"2021/06/04/12 矩阵中的路径/","text":"note:典型的迷宫找路的问题，一般都是使用基于dfs+剪枝的回溯方法。 题目描述给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。 示例 1： 12输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;输出：true 示例 2： 12输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;输出：false 提示： 1 &lt;= board.length &lt;= 200 1 &lt;= board[i].length &lt;= 200 board 和 word 仅由大小写英文字母组成 方法：回溯法思路很显然，对于这种矩阵搜索、迷宫找路径的题目，一般必然是使用深度优先搜索+剪枝来进行解决的。 在这道题中，我们首先可以想到，我们只需要以矩阵中每个元素作为起始元素，判断以这个元素开始是否能够找到word。 然后开始设想如何以某个元素作为起始进行寻找。首先考虑的深度优先搜索，就会发现搜索过的地方会重复搜索，浪费大量时间，甚至递归无法停止，所以我们一定要标记好访问过的地方，一但访问了，就要做好标记，而一但发现此路不通，进行回溯的时候，就要把标记改回来。这就是剪枝的部分。 考虑dfs的流程是如何的。一般dfs肯定是使用递归写方便，递归的终止条件非常重要，很显而易见的终止条件有以下几个 超出矩阵边界。返回false。 访问到的元素和要找的字符串中对应的元素不相同。返回false 字符串所有字符都已经找遍，全部对应上了。完全匹配。返回true 那递归要完成什么呢？ 标记已经访问的元素 向上下左右四个方向进行探索，看往下走是否满足字符串的匹配（开启下层递归），四个方向只要有一个方向可以满足就满足情况 恢复已经访问的标记。 为什么之后要恢复已经访问的标记呢？这是因为走到这一步时，下层递归都已经完成，本层工作也已经做完，将要返回到上层递归，而所有的本层递归所做的标记，对于上层递归而言是无意义的。甚至会干扰的上层递归的访问。所以要恢复所做的标记。也就是说，标记仅影响本层以下的所有递归操作。 标记的行为可以有很多实现，比如重新建立一个等大的矩阵来记录。但是为了节省空间，我们不妨就在原数组进行更改，更改为一个不可能在字符串中出现的元素就好，然后在递归结束之后，再将元素改过来就可以了。 代码123456789101112131415161718192021222324252627282930class Solution &#123; int row,col; bool dfs(vector&lt;vector&lt;char&gt;&gt; &amp;board,string word,int i,int j,int k)&#123; if(i&lt;0||i&gt;=row||j&lt;0||j&gt;=col||board[i][j]!=word[k])&#123; // board[i][j]!word[k]一定要放在最后，避免数组越界错误 return false; &#125; if(k==word.size()-1) return true; board[i][j]=&#x27;0&#x27;; // 更改赋值 进行剪枝 bool res = dfs(board,word,i+1,j,k+1) || dfs(board,word,i-1,j,k+1) || dfs(board,word,i,j+1,k+1) || dfs(board,word,i,j-1,k+1); board[i][j] = word[k]; // 改回原值，回溯上层 return res; &#125;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; row = board.size(); col = board[0].size(); for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;col;j++)&#123; if(dfs(board,word,i,j,0)) return true; &#125; &#125; return false; &#125;&#125;; 复杂度分析 M,N 分别为矩阵行列大小， KK 为字符串 word 长度。 时间复杂度 $O(3^KMN)$： 最差情况下，需要遍历矩阵中长度为$ K $字符串的所有方案，时间复杂度为 $O(3^K)$；矩阵中共有$ MN$个起点，时间复杂度为 $O(MN)$ 。 方案数计算： 设字符串长度为 $KK$ ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 3 种选择，因此方案数的复杂度为 $O(3^K)$ 。 空间复杂度$ O(K)$ ： 搜索过程中的递归深度不超过 $K$ ，因此系统因函数调用累计使用的栈空间占用$ O(K)$ （因为函数返回后，系统调用的栈空间会释放）。最坏情况下 $K = MN$ ，递归深度为 $MN$ ，此时系统栈使用$ O(MN)$ 的额外空间。 (复杂度分析参考题解)","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 10.斐波那契数列和青蛙跳台阶","date":"2021-05-31T03:16:01.000Z","path":"2021/05/31/10 斐波那契数列和青蛙跳台阶/","text":"note: 虽然本科的时候讲递归必讲斐波那契，但是不意味着递归最适合于斐波那契，因为存在很多重复计算，且递归也需要额外空间。 还有关于求余的问题，有三个公式需要记一下 (x+y)\\%p = (x\\%p+y\\%p)\\%p \\\\ (x-y)\\%p = (x\\%p-y\\%p)\\%p \\\\ (x*y)\\%p = (x\\%p*y\\%p)\\%p 题目描述写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下： 12F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 12输入：n = 2输出：1 示例 2： 12输入：n = 5输出：5 提示： 0 &lt;= n &lt;= 100 方法一：递归（容易超时）思路简单思维，照搬公式。 需要思考的是哪里复杂了呢？原因是产生了很多重复计算，如下图所示 代码12345678910class Solution &#123;public: int fib(int n) &#123; if(n&lt;2)&#123; return n; &#125; return (fib(n-1)+fib(n-2))%1000000007; &#125;&#125;; 复杂度分析 时间复杂度$O(2^n)$。递归出来一个类似于二叉树的结构，时间复杂度近似为二叉树的节点数，根据斐波那契公式和推导，可以知道它的紧确界为$O((\\frac{1+\\sqrt5}{2})^n)$。中间掺杂有重复计算，参考Krahets的题解图 (leetcode-cn.com)](https://pic.leetcode-cn.com/25e913ab8d7a22bb017669e4a097cf51d10861f365002f2d8556ee7a64464cd8-Picture0.png)) 空间复杂度$O(n)$。二叉树的高度 方法二：递归优化，减少重复计算原理将计算后的值放入数组进行存储，需要时不用再递归计算。 代码12345678910111213class Solution &#123; int store[101] = &#123;0&#125;;public: int fib(int n) &#123; if(n&lt;2)&#123; return n; &#125; if(store[n]!=0) return store[n]; store[n] = (fib(n-1)+fib(n-2))%1000000007; return store[n]; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$。因为我们进行了存储，所以我们减少了叶子节点的数量，每个元素只需要计算一次，所以为线性复杂度 空间复杂度：$O(n)$。显然我们除了递归的空间外，还需要存储所有叶子的空间。空间开销变大了。 方法三： 动态规划（也有人说是尾递归）原理将斐波那契数列的性质$f(n+1) = f(n)+f(n-1)$为转移方程。定义一个一维数组$dp$，$dp[i]$表示斐波那契数列的第$i$个数字。 状态方程：$dp[i] = dp[i-1]+dp[i-2]$ 初始状态: $dp[0]=0,dp[1]=1$ 返回值：$dp[n]$ 代码123456789101112131415class Solution &#123; int store[101] = &#123;0&#125;;public: int fib(int n) &#123; if(n&lt;2) return n; vector&lt;int&gt; dp(n+1); dp[0]=0; dp[1]=1; for(int i=2;i&lt;=n;i++)&#123; dp[i] = (dp[i-1]+dp[i-2])%1000000007; &#125; return dp[n]; &#125;&#125;; 复杂度分析 时间复杂度$O(n)$。每个值计算一次 空间复杂度$O(n)$。需要一个数组存放计算的值。 方法四：动态规划+滚动数组（进一步减少空间，最常用）原理事实上分析方法三中的数组，我们发现其实没必要存储所有中间计算过程中的值，因为我们只用得到$n-1$和$n-2$这两个中间值。 所以我们可以使用两个变量来存储，就可以将数组省略掉，这其实是一种滚动数组的思想 代码1234567891011121314class Solution &#123; int store[101] = &#123;0&#125;;public: int fib(int n) &#123; int a=0,b=1,sum=0; for(int i=0;i&lt;n;i++)&#123; sum = (a+b)%1000000007; a = b; b = sum; &#125; return a; &#125;&#125;; 复杂度分析 时间复杂度$O(n)$。每个值计算一次 空间复杂度$O(1)$。只使用了常数级别的额外空间。 方法五：矩阵快速幂（不常用）原理注意： 本题中这种方法不可用，因为会发生溢出错误（n太大了） 进一步降低时间复杂度的方法。 建立一个递推关系如下所示 \\begin{bmatrix} 1&1 \\\\ 1&0 \\end{bmatrix} \\begin{bmatrix} F(n) \\\\ F(n-1) \\end{bmatrix} = \\begin{bmatrix} F(n)+F(n-1)\\\\ F(n) = \\end{bmatrix} \\begin{bmatrix} F(n+1) \\\\ F(n) \\end{bmatrix}因此我们有: \\begin{bmatrix} F(n+1)\\\\ F(n) \\end{bmatrix} = \\begin{bmatrix} 1 & 1\\\\ 1 & 0 \\end{bmatrix}^n \\begin{bmatrix} F(1)\\\\ F(0) \\end{bmatrix}如果令 M = \\begin{bmatrix} 1 & 1\\\\ 1 & 0 \\end{bmatrix}因此如果我们可以快速计算矩阵M的$n$次幂，就可以得到$F(n)$的值。如果直接求取$M^n$，时间复杂度不会得到改善，依然是$O(n)$。但我们可以定义矩阵乘法，用快速幂算法来加速$M^n$的求取。 代码123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int fib(int n) &#123; if (n &lt; 2) &#123; return n; &#125; vector&lt;vector&lt;int&gt;&gt; q&#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;; vector&lt;vector&lt;int&gt;&gt; res = matrix_pow(q, n - 1); return res[0][0]; &#125; vector&lt;vector&lt;int&gt;&gt; matrix_pow(vector&lt;vector&lt;int&gt;&gt;&amp; a, int n) &#123; vector&lt;vector&lt;int&gt;&gt; ret&#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;; while (n &gt; 0) &#123; if (n &amp; 1) &#123; ret = matrix_multiply(ret, a); &#125; n &gt;&gt;= 1; a = matrix_multiply(a, a); &#125; return ret; &#125; vector&lt;vector&lt;int&gt;&gt; matrix_multiply(vector&lt;vector&lt;int&gt;&gt;&amp; a, vector&lt;vector&lt;int&gt;&gt;&amp; b) &#123; vector&lt;vector&lt;int&gt;&gt; c&#123;&#123;0, 0&#125;, &#123;0, 0&#125;&#125;; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 2; j++) &#123; c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]; &#125; &#125; return c; &#125;&#125;; 复杂度分析 时间复杂度$O(logn)$ 空间复杂度$O(1)$ 剑指 Offer 10- II. 青蛙跳台阶问题题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 12输入：n = 2输出：2 示例 2： 12输入：n = 7输出：21 示例 3： 12输入：n = 0输出：1 提示： 0 &lt;= n &lt;= 100 思路没什么可说的，分析下来和斐波那契数列不能说毫无关系只能说一模一样。主要是初始状态要注意是1不是0。原地跳也是一种跳法嘛。 代码123456789101112class Solution &#123;public: int numWays(int n) &#123; int a=1,b=1,sum=0; for(int i=0;i&lt;n;i++)&#123; sum = (a + b)%1000000007; a = b ; b = sum; &#125; return a; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 11.旋转数组的最小数字","date":"2021-05-31T03:16:01.000Z","path":"2021/05/31/11 旋转数组的最小数字/","text":"note:拿到手就要意识到是二分查找。然后思考数组的特性，选定target和每次边界移动的方式。 题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1： 12输入：[3,4,5,1,2]输出：1 示例 2： 12输入：[2,2,2,0,1]输出：0 方法一 暴力思路暴力遍历，一般能过。 代码1234567891011class Solution &#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; int minN = numbers[0]; for(auto n:numbers)&#123; minN = min(n,minN); &#125; return minN; &#125;&#125;; 复杂度分析 时间复杂度$O(n)$。显然经过了一次完整的遍历 空间复杂度$O(1)$。没有需要存储的额外空间 方法二 快排思路快速排序，重新排序——优点就是太好写了（你管这叫优点？） 代码1234567class Solution &#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; sort(numbers.begin(),numbers.end()); return numbers[0]; &#125;&#125;; 复杂度分析 时间复杂度$O(nlogn)$。快排的复杂度。 空间复杂度$O(nlogn)$。快排的复杂度。 方法三 二分查找思路显然前两种方法没有用到旋转数组的性质。而且为了拥有比$O(n)$更快的时间复杂度，很显然就是二分查找的方法，最主要的是，数组本身就是一个变形的“有序数组”，所以第一时间就应该考虑二分查找法。 二分查找需要两个条件，一是数组有序，而是目标值。 旋转数组虽然不是完全有序，但是是部分有序。目标值的选取我们可以考虑左值或者右值来判断区间如何缩小。 如果时刻选取左值为target，我们会发现无法给我们带来有效的规律。但是如果我们时刻选择右值为target，有这样一个性质——最小值右侧的元素必然小于等于最右值，左侧元素必然大于等于最右值。根据这一性质，我们就可以通过二分法来找最小值了。 分析二分查找每一步中中轴元素和最右值比较的不同结果 中轴元素小于最右值。区间可以缩小为左指针到中轴元素，左闭右闭，右侧被舍去是因为他们一定比最小值大或者相等。 中轴元素大于最右值。区间可以缩小为中轴元素到右指针，左开右闭，左侧被舍去是因为左侧元素一定比最小值大或者相等。 中轴元素等于最右值。因为存在重复元素，所以这一步很困难进行区间的变动，但是由于中轴元素等于最右值，则最右值没有必要一定要在更新后的区间内，因为不会因为剪掉它，我们就错过最小值。 需要注意的是，不同于一般的二分查找，此次二分查找target是不断变化的。 代码1234567891011121314151617class Solution &#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; int left=0,right=numbers.size()-1; while(left&lt;=right)&#123; int mid = left+(right-left)/2; if(numbers[mid]&lt;numbers[right])&#123; right = mid; &#125; else if(numbers[mid]&gt;numbers[right])&#123; left = mid +1; &#125; else&#123; right --; &#125; &#125; return numbers[left]; &#125;&#125;; 复杂度分析 时间复杂度。平均时间复杂度为$O(logn)$，最坏时间复杂度为$O(n)$，此时数组全部相同。 空间复杂度$O(1)$","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 09.用两个栈实现队列","date":"2021-05-30T14:01:01.000Z","path":"2021/05/30/09 用两个栈实现队列/","text":"note: 这道题乍一看非常简单，当然做起来也很简单，但是中间过程如何简化就需要再想一想。每次删除和增加操作都需要“倒空”么？高效的回答当然是否定的。 题目描述用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 1234输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1] 示例 2： 1234输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 提示： 1 &lt;= values &lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 方法一 暴力思考思路既然双栈实现，我就搞一个删除栈一个增加栈，每次执行删除操作前都将另一个栈进行清空，来保证删除或增加的元素的次序是正确的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class CQueue &#123; stack&lt;int&gt; stk1; stack&lt;int&gt; stk2;public: CQueue() &#123; while(!stk1.empty())&#123; stk1.pop(); &#125; while(!stk2.empty())&#123; stk2.pop(); &#125; &#125; void appendTail(int value) &#123; while(!stk2.empty())&#123; stk1.push(stk2.top()); stk2.pop(); &#125; stk1.push(value); &#125; int deleteHead() &#123; while(!stk1.empty())&#123; stk2.push(stk1.top()); stk1.pop(); &#125; if(stk2.empty()) return -1; else&#123; int ans = stk2.top(); stk2.pop(); return ans; &#125; &#125;&#125;;/** * Your CQueue object will be instantiated and called as such: * CQueue* obj = new CQueue(); * obj-&gt;appendTail(value); * int param_2 = obj-&gt;deleteHead(); */ 复杂度 时间复杂度：$O(n)$。执行每次操作我都需要调整栈。所以需要线性时间复杂度 空间复杂度：$O(n)$。两个栈来存储元素 方法二思路仔细思考上面的思路，我们很快就会发现我们做了很多无用功。因为我们没有必要在添加的时候将所有的删除栈中的元素倒腾到添加栈，或者说我们没有必要时刻保证两个栈必有一个栈是空的。我们只需要在我们删除的时候，如果删除栈存在元素，直接删除删除栈中的元素，直到删除栈中的元素删除完了，我们再将添加栈中的元素捣腾到删除栈进行删除。 代码123456789101112131415161718192021222324252627282930313233class CQueue &#123; stack&lt;int&gt; stk1,stk2;public: CQueue() &#123; while(!stk1.empty())&#123; stk1.pop(); &#125; while(!stk2.empty())&#123; stk2.pop(); &#125; &#125; void appendTail(int value) &#123; stk1.push(value); &#125; int deleteHead() &#123; if(stk2.empty())&#123; while(!stk1.empty())&#123; stk2.push(stk1.top()); stk1.pop(); &#125; &#125; if(stk2.empty())&#123; return -1; &#125; else&#123; int ans = stk2.top(); stk2.pop(); return ans; &#125; &#125;&#125;; 复杂度分析 时间复杂度$O(1)$。对于插入和删除操作，时间复杂度均为$O(1)$.插入显然是常数。删除操作虽然看上去线性时间复杂度，但是实际上因为每个元素最多从stk2中被push和pop一次。所以均摊下来每个元素被删除的时间复杂度仍然是$O(1)$。 空间复杂度$O(n)$。用到两个栈来存储已有的元素。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 07.重建二叉树","date":"2021-05-27T15:30:20.000Z","path":"2021/05/27/07 重建二叉树/","text":"note: 知道任何两种遍历的方式，来重建二叉树是非常经典的数据结构题目。思路非常的简单，实现起来却没有思考时写写画画那么简单。其中重点我觉得是一种将子树看为全新的树的思想。 题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 / \\9 20 / \\ 15 7 限制： 0 &lt;= 节点个数 &lt;= 5000 方法一 递归思路一般而言针对二叉树最直白最好写的方法就是递归。 当然首先我们需要明确前序遍历和中序遍历的顺序 前序遍历： 先遍历根节点 然后遍历左子树 然后遍历右子树 中序遍历： 先遍历左子树 然后遍历根节点 然后遍历右子树 如果我们有子节点就是一棵树的概念的话，我们很容易发现，对于每棵树，前序遍历中序遍历的形式都是不变的，即： 12[root,[左子树],[右子树]] // 前序遍历[[左子树],root,[右子树]] // 中序遍历 方括号括着的部分，显然就是我们递归的函数了。这样问题就转换成了如何准确的找到要递归的部分，也就是两个遍历顺序中的，方括号的位置的问题，以及root所在位置的问题。 那我们可以考虑我们的递归函数的传参 首先肯定要有前序遍历和中序遍历的数组， 然后我们需要明确定位要递归的那部分，本来我们可能需要8个参数来确定所有的方括号，但是我们很容易发现，前序遍历左子树的右括号和右子树的左括号有关系，中序遍历的左子树右括号和右子树的左括号也有关系，所以我们的括号只需要4个参数就可以确定。 然后可能会有疑问，root不需要定位么？事实上前序遍历确实不需要遍历，每个方括号内第一个元素肯定是root，但是对于中序遍历就需要定位了。这时候一般有两种解决方案，一种是遍历找，显然很复杂，另一种是我们在开始前就用一个hash表，记录下来前序遍历中每一个元素对应在中序遍历的位置，这样就可以很快的在中序遍历中对root进行定位。 代码123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; unordered_map&lt;int,int&gt; dic;public: TreeNode* buildMyTree(vector&lt;int&gt;&amp; preorder,vector&lt;int&gt;&amp; inorder,int p_left,int p_right,int i_left,int i_right)&#123; if(p_left&gt;p_right) return NULL; int p_root = p_left; int i_root = dic[preorder[p_root]]; int size = i_root-i_left; TreeNode* node = new TreeNode(preorder[p_root]); node-&gt;left = buildMyTree(preorder,inorder,p_left+1,p_left+size,i_left,i_root-1); node-&gt;right = buildMyTree(preorder,inorder,p_left+size+1,p_right,i_root+1,i_right); return node; &#125; TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; int n=preorder.size(); for(int i=0;i&lt;n;i++)&#123; dic[inorder[i]] = i; &#125; return buildMyTree(preorder,inorder,0,n-1,0,n-1); &#125;&#125;; 复杂度 时间复杂度$O(n)$。n是树的节点数目。我们在定位时没有使用遍历等复杂的手段，如果我们定位中序遍历的root没有使用hash的话，可能就要$O(n^2)$的复杂度了 空间复杂度$O(n)$。首先我们使用了hash映射，额外使用了$O(n)$的空间来存储每个结点的位置，当然递归本身也有$O(h)$的栈开销，但是显然$h&lt;n$。所以额外使用的空间为$O(n)$ 方法二 迭代思路二叉树的迭代法一直我看来要比递归难写，这道题尤其是这样子。 这道题的迭代写法主要是利用了前序遍历和中序遍历结果的部分一致性，以及他们的部分相反性。主要考察的还是对前序遍历 中序遍历的了解熟悉程度。 整理知识点我觉得可以有以下几个重点 前序遍历的相邻节点的关系。前序遍历中任何相邻的两个节点，隐藏着一个关系：后一个节点要么是前一个节点的左子树，要么就是前一个节点的某个祖先节点的右子树（此时说明前一个节点没有左子树）。这其实是一个很好理解的性质，一会儿会有所帮助 中序遍历最前面的节点。表示的时当前的二叉树最左边（指的是从不选择右子树）的节点。这个也很好理解。 我们使用栈这种数据结构，维护在前序遍历中还没有考虑右子树情况的节点。为什么要用栈呢？因为有这样一个性质，在剔除掉二叉树中的任何一个右子树后，前序遍历的顺序和中序遍历的顺序必然是相反的。这样利用先进后出的的栈的性质，我们就可以将前序遍历和中序遍历进行对应。 前三点都有一个共性，那就是我们想方设法不考虑右子树的存在。但是右子树终究避免不了，那么右子树在哪里呢？就是在我们在第三点中剔除掉的位置。只要能找到这些位置，我们就可以将右子树的节点找到，并根据它和栈中元素的关系，接到右分支上。 那么右子树节点对应栈中哪个元素呢？当我们利用出栈操作来和中序遍历进行对应时，一但栈顶元素和中序遍历第index个元素不对应了，那么就说明index个元素是一个右子树节点，而且必然是上一个弹出的节点是它的父节点——只有这个原因，才会导致栈顶元素不再是中序遍历中index个元素。 实现步骤分为以下几步 建立存放节点的栈，将前序遍历的第一个元素放进去（因为这个必定是树的根节点） 建立index变量，指向中序遍历的第一个元素，作为“当前树最左节点” 遍历前序遍历元素，每个元素先建立为一个节点，根据当前栈顶元素是否和index所指元素相等，来执行不同的操作 如果当前栈顶节点的值和index所指元素相同，说明还没有碰到右子树，那么当前前序遍历的元素，即为栈顶节点的左子树。栈顶节点左子树指针指向新节点 如果当前栈顶节点的值和index所指元素不同，说明碰到了右子树，那么当前前序遍历的元素，应该是栈中某个节点的右子树。那么移动index并不断出栈节点，并记录下来刚刚出栈的节点，直到index所指向的元素不等于栈顶节点的值，那么前一个出栈的节点就是该元素的父节点，该元素所生成的节点就是出栈节点的右子树，出栈节点右子树指针指向新节点。如果移动中栈空了，那就停止移动index。进行下一步操作 将新节点进行入栈，因为新节点我们并没有考虑它自身的左右子树。 代码12345678910111213141516171819202122232425262728293031class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; int n = preorder.size(); if(n==0) return NULL; stack&lt;TreeNode*&gt; stk; TreeNode* root = new TreeNode(preorder[0]); int index=0; stk.push(root); for(int i=1;i&lt;n;i++)&#123; TreeNode* curnode = new TreeNode(preorder[i]); if(inorder[index] != stk.top()-&gt;val)&#123; stk.top() -&gt; left = curnode; &#125;else&#123; TreeNode* pnode; while(!stk.empty() &amp;&amp; inorder[index]==stk.top()-&gt;val)&#123; pnode = stk.top(); stk.pop(); index++; &#125; pnode-&gt;right = curnode; &#125; stk.push(curnode); &#125; return root; &#125;&#125;; 复杂度分析 时间复杂度$O(n)$。同样我们只是遍历了所有的树的节点一次。 空间复杂度$O(n)$。虽然尽管我们没有使用递归空间，但是我们使用了栈空间来保存树，所以依然还是线性复杂。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 06.从尾到头打印链表","date":"2021-05-26T03:30:20.000Z","path":"2021/05/26/06 从尾到头打印链表/","text":"note: insert方法虽然好写但是时间复杂度一般很高，反转链表虽然不错但是需要问清楚是否可以改动原链表 题目描述输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1： 12输入：head = [1,3,2]输出：[2,3,1] 限制： 0 &lt;= 链表长度 &lt;= 10000 解法一： vector的insert方法思路vector容器类定义了insert方法，可以在任意位置插入元素。显然我们可以在遍历链表时，把每个元素插入最前面。就能得到反转的链表的数值了。 代码12345678910111213141516171819/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; reversePrint(ListNode* head) &#123; vector&lt;int&gt; ans; while(head!=NULL)&#123; ans.insert(ans.begin(),head-&gt;val); head = head-&gt;next; &#125; return ans; &#125;&#125;; 复杂度 时间复杂度$O(n)$。实际上vector容器insert函数在STL中的实现是每次插入时，将插入位置后的东西整体向后挪动，再在空的位置放入元素，实际时间是非常多的。 空间复杂度$O(1)$。没有额外使用空间 解法二：使用栈思路对于链表、反转关键字，其实很容易想到栈这一数据结构，利用其先进后出的特性，我们遍历链表时进行入栈，完毕后边出栈边存入数组。 代码12345678910111213141516class Solution &#123;public: vector&lt;int&gt; reversePrint(ListNode* head) &#123; vector&lt;int&gt; ans; stack&lt;int&gt; stk; while(head!=NULL)&#123; stk.push(head-&gt;val); head = head-&gt;next; &#125; while(!stk.empty())&#123; ans.push_back(stk.top()); stk.pop(); &#125; return ans; &#125;&#125;; 复杂度 时间复杂度$O(n)$。遍历了链表和栈，依然是$O(n)$级别 空间复杂度$O(n)$。额外使用了栈空间。 解法三： 链表反转思路在链表相关专题中，一般会要求我们不适用额外空间，那一般我们使用的方法就是直接的链表反转。链表反转都是通过一个指向前一个结点的指针、一个临时节点来达到目的。 注意的是需要提前问清楚链表是否可以更改！ 代码12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; reversePrint(ListNode* head) &#123; vector&lt;int&gt; ans; ListNode* pre = NULL; ListNode* temp = NULL; while(head!=NULL)&#123; temp = head-&gt;next; head-&gt;next = pre; pre = head; head = temp; &#125; while(pre!=NULL)&#123; ans.push_back(pre-&gt;val); pre = pre-&gt;next; &#125; return ans; &#125;&#125;; 复杂度 时间复杂度$O(n)$。遍历两次链表 空间复杂度$O(1)$。没有使用额外空间 解法四：反转数组思路既然链表可以反转，那么数组必然也可以反转，甚至写起来更简单 代码123456789101112131415class Solution &#123;public: vector&lt;int&gt; reversePrint(ListNode* head) &#123; vector&lt;int&gt; ans; while(head!=NULL)&#123; ans.push_back(head-&gt;val); head = head-&gt;next; &#125; reverse(ans.begin(),ans.end()); return ans; &#125;&#125;; 复杂度 时间复杂度$O(n)$。遍历链表。 空间复杂度$O(1)$。不需要额外空间。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 05.替换空格","date":"2021-05-26T03:20:20.000Z","path":"2021/05/26/05. 替换空格/","text":"Note： 可能在面试的时候需要问清楚原字符串是否可以改动，可以的话我们利用c++ string的特性原地操作，不可以的话就需要重新new一个string。总之是一个很简单的题目，可能需要注意的是string的resize方法可以扩充string的大小 题目描述请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例 1： 12输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot; 限制： 0 &lt;= s 的长度 &lt;= 10000 解法一：不可修改原字符串思路new一个新的字符串，进行填充。 代码12345678910111213141516171819202122class Solution &#123;public: string replaceSpace(string s) &#123; int len=s.length(),size; int count=0; for(auto c:s)&#123; if(c==&#x27; &#x27;) count++; &#125; string ans = string(count*2+len,&#x27; &#x27;); for(int i=0,j=0;i&lt;len;i++,j++)&#123; if(s[i]!=&#x27; &#x27;)&#123; ans[j] = s[i]; &#125;else&#123; ans[j++] = &#x27;%&#x27;; ans[j++] = &#x27;2&#x27;; ans[j] = &#x27;0&#x27;; &#125; &#125; return ans; &#125;&#125;; 复杂度 时间复杂度$O(n)$。一定要遍历整个字符串的。 空间复杂度$O(n)$。姑且将新建的字符串当作额外空间吧。如果不算那就$O(1)$ 解法二：利用C++特性在原字符串上进行修改思路主要借助c++的string中的resize函数，来重新调整字符串大小，然后利用双指针，从后往前遍历填充，不会造成读写冲突。 代码12345678910111213141516171819202122232425class Solution &#123;public: string replaceSpace(string s) &#123; int len=s.size(),size; int count=0; for(auto c:s)&#123; if(c==&#x27; &#x27;) count++; &#125; size = len+count*2; s.resize(size); for(int i=len-1,j=size-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--)&#123; if(s[i]!=&#x27; &#x27;)&#123; s[j] = s[i]; &#125;else&#123; s[j] = &#x27;0&#x27;; s[j-1] = &#x27;2&#x27;; s[j-2] = &#x27;%&#x27;; j -= 2; &#125; &#125; return s; &#125;&#125;; 复杂度 时间复杂度$O(n)$。需要遍历整个字符串两次。 空间复杂度$O(1)$。原地扩展字符串s。所以应该是$O(1)$的时间","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 04.二维数组中的查找","date":"2021-05-25T07:45:22.000Z","path":"2021/05/25/04 二维数组中的查找元素/","text":"Note：比遍历时间更优的除了二分，还有减治，当然二分就是一种减治的思想，但是减治不一定必须二分。 题目描述在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例： 现有矩阵 matrix 如下： 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 120 &lt;= n &lt;= 10000 &lt;= m &lt;= 1000 解法一：暴力思路不考虑任何特性，直接遍历每个元素，在限制的条件下，显然也是完全可以接受的。 代码12345678910111213class Solution &#123;public: bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; for(const auto &amp;row : matrix)&#123; for(const auto &amp;el : row)&#123; if(el==target) return true; &#125; &#125; return false; &#125;&#125;; 复杂度 时间复杂度O(MN)。要遍历整个二维数组 空间复杂度 O(1)。没有使用额外空间 解法二：二分查找思路由于二维数组是有序的，所以很容易想到二分查找的方法。但是同时我们也很容易发现，一般的二分查找很难满足二维的需求。 我们可以沿着对角线进行二分查找 ，每到一个新的位置，我们可以以当前位置为起始，分别向右、向下进行二分查找。 这样我们可以在一个维度上实现二分，另一个维度上进行遍历，时间效率上会有所改善。 代码12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: bool binarySearch(vector&lt;vector&lt;int&gt;&gt;&amp; matrix,int target,int start,bool x)&#123; int m = matrix.size(); int n = matrix[0].size(); int fixed = start; int end = x ? n-1 : m-1; while(start&lt;=end)&#123; int mid = start+(end-start)/2; int num = x ? matrix[fixed][mid]:matrix[mid][fixed]; if(num==target) return true; else if(num&lt;target)&#123; start = mid+1; &#125;else&#123; end = mid-1; &#125; &#125; return false; &#125; bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int m = matrix.size(); if(m==0) return false; int n = matrix[0].size(); if(n==0) return false; for(int i=0;i&lt;min(m,n);i++)&#123; bool foundx = binarySearch(matrix,target,i,true); bool foundy = binarySearch(matrix,target,i,false); if(foundx || foundy) return true; &#125; return false; &#125;&#125;; ps. 这种写法为了提高代码的复用，做了两次if，所以可能会对时间性能有所影响。 复杂度 时间复杂度$O(lg(n!))$。参考leetcode题解，具体推导过程略。 空间复杂度$O(1)$。没有使用额外空间 解法三：减治线性查找思路观察矩阵，矩阵的行列从左到右从上到下分别有序，那么我们可以发现，如果从矩阵的右上角或左下角来看整个矩阵的话，这个矩阵就是一个“二叉搜索树”。以右上方开始为例，我们可以做这样的操作：如果指向的值大于目标值，那么就将指针向左移动，如果指向的值小于目标值，我们就可以将指针向下移动。不断移动指针，直到我们找到目标值，或者指针移出整个矩阵。 代码实现1234567891011121314151617181920212223class Solution &#123;public: bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int m = matrix.size(); if(m==0) return false; int n = matrix[0].size(); if(n==0) return false; int row = 0,col = n-1; while(row&lt;m &amp;&amp; col&gt;=0)&#123; if(matrix[row][col]==target) return true; if(matrix[row][col]&lt;target) row++; else if(matrix[row][col]&gt;target) col--; &#125; return false; &#125;&#125;; 复杂度 时间复杂度$O(n+m)$。指针移动访问，向左移动最多m次，向下移动最多n次。 空间复杂度$O(1)$。没有使用额外空间","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"《剑指offer》 03.数组中重复的数组","date":"2021-05-24T02:20:22.000Z","path":"2021/05/24/03 数组中重复的元素/","text":"题目描述找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 解法一：hash表思路最简单直接的想法就是hash表：一个空白数组，数组中的元素作为空白元素的下标，进行加一操作，一但某个空白元素中的某个元素在加一操作前已经不为0，那么就找到了一个重复的元素，直接返回就好。 代码123456789101112class Solution &#123;public: int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; hash(100000); for(auto n : nums)&#123; if(hash[n]!=0) return n; hash[n]++; &#125; return -1; &#125;&#125;; 复杂度 时间复杂度O(n)。因为最坏情况下可能要遍历完整个数组才能找到是否有重复元素。 空间复杂度O(n)。因为需要一个空白数组，这属于额外空间。 解法二：原地交换思路题目中有一个条件是长度为n的数组nums里的所有数字都在0~n-1之间。这个条件告诉我们数组中最大元素的大小必然是小于等于最大下标的。我们可以考虑不再创建额外数组，在原数组中，将每个元素，放置在以他作为下标的位置上。而一但发现该位置已经放置了和下标相等的元素，那就说明数组中出现了重复元素，重复的元素就是这个元素。 代码12345678910111213141516class Solution &#123;public: int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123; int i=0; while(i&lt;nums.size())&#123; // 开始遍历 if(nums[i] == i)&#123; // 如果索引和索引指向的数字相等，则移动指针 i++; continue; &#125; if(nums[nums[i]]==nums[i]) // 如果索引所指的元素和以此元素为索引的元素相等，则重复，返回该元素 return nums[i]; swap(nums[i],nums[nums[i]]); // 交换索引所指的元素和与该元素作为索引时所指的元素（将该元素放到以他为索引的位置。） &#125; return -1; &#125;&#125;; 复杂度 时间复杂度O(n)。同理，最坏情况下依然需要将数组进行彻底的遍历 空间复杂度O(1)。不需要额外数组，我们是在原数组上进行原地交换。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zijian.wang/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"二分查找的区间选择问题（不断更新中）","date":"2021-05-21T09:46:27.000Z","path":"2021/05/21/二分查找的区间选择问题/","text":"二分查找是一种十分基础重要的搜索方法。一般多用于数组结构的搜索查找问题中。虽然思路简单，但是边界条件却很容易让人迷糊。这里对二分查找做一个总结。 首先以35题简单题做一个示范： 35 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/))题目描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 做题思路这道题的思路非常简单，就是利用二分查找，不断更新边界，最后锁定到某个插入位置。下面介绍两种具体写法中边界的不同考虑。 写法一123456789101112131415161718192021222324class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int size = nums.size(); int left = 0, right = size-1; // 右指针指在最后一个元素上 while (left &lt;= right) // 因为左右指针都指在一个确定的数字上，所以存在两个指针指在同一个数字的情况 &#123; int mid = left + (right-left)/2; // 这种方式避免溢出 if(nums[mid]==target) return mid; else if (nums[mid]&lt;target) &#123; left = mid+1; // 左右指针都指向确切的元素，所以当mid不满足时变换左右指针应该变到下一个位置 &#125;else&#123; right = mid-1; // 同理。 &#125; &#125; return left; // 这种情况下left靠后 &#125;&#125;; 这种写法的关键在于左右边界所指的元素都在要考虑的区间内，也就是一种闭区间的写法，每次考虑的是[left,right]的情况，为了避免考虑过的区间重新考虑，我们就要在更新边界时将mid+1或者-1来赋值区间边界。 写法二1234567891011121314151617181920212223class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int size = nums.size(); int left = 0,right = size; //右指针指在不存在的元素 while (left &lt; right) // 不存在左右指针指在同一个元素的情况 &#123; int mid = left + (right-left)/2; if(nums[mid]==target)&#123; return mid; &#125; else if (nums[mid]&lt;target) &#123; left = mid+1; // 左指针指在确切元素，所以+1 &#125; else &#123; right = mid; // 右指针所指的元素不会考虑，所以mid &#125; &#125; return right; // 这种情况下right靠后 &#125;&#125;; 这种写法的关键在于右边界所指的元素并不在要考虑的区间内，是一种半开闭的区间状态，每次考虑的是[left,right)的情形。所以此时在更新状态时，更新右边界时直接让右边界等于mid就好，因为mid已经考虑过了。 当然在很多时候，像这样直白地告诉你我就是二分查找的题目并不是很多，再举一个二分查找解决的简单题，leetcode第69题，据说是一个常见的面试题目。 69 x-的平方根题目描述实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1： 输入：4 输出：2 示例 2： 输入：8 输出：2 说明：8的平方根是2.82842…… 由于返回类型是整数，所以小数部分将会被舍去。 做题思路本题其实是一个二分查找的典型应用场景，虽然看不到数组，但是显然自然数本身就是一个单调有序的排列，而x就是上界，0就是下界。这是因为因为题中提到小数部分会被舍去，同时，如果一个数的平方大于x，则它必然不可能是x的平方根。 这样这道题可以转换为，在数组[0,1,···,x]中，查找其中某个数的平方等于x，如果没有数的平方等于x，则找出平方小于x中最接近x的数。 这样看就是一个显然的二分查找了。 解法12345678910111213141516171819202122class Solution &#123;public: int mySqrt(int x) &#123; int right=x; // 右边界，因为任何一个数的平方根必然小于等于某个数 int left=0; // 左边界 while (left&lt;=right) // 同前，闭区间边界条件有数 &#123; int mid = left + (right-left)/2; if ((long long)mid*mid==x) //需要强转一下，因为可能溢出 &#123; return mid; &#125; else if ((long long)mid*mid &lt; x) // 强转防止溢出 &#123; left = mid+1; &#125;else&#123; right = mid-1; &#125; &#125; return right; // 不同于上面我们需要的是偏前的位置，此时right在左left在右，所以返回right &#125;&#125;; 以上两道题可以理解为二分查找找一个数的题目，接下来是一道二分查找找两个数的题目 34. 在排序数组中查找元素的第一个和最后一个位置题目描述给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶： 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1： 输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4] 示例 2： 输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1] 示例 3： 输入：nums = [], target = 0输出：[-1,-1] 提示： $ 0 &lt;= nums.length &lt;= 105$ $-10^9 &lt;= nums[i] &lt;= 10^9$ nums 是一个非递减数组 $-10^9 &lt;= target &lt;= 10^9$ 做题思路思路上没有特别新鲜的地方，这道题的题解有趣之处在于函数的复用。具体思考见注释。 解法123456789101112131415161718192021222324252627282930313233class Solution &#123;public: // 二分过程 // 输入：数组、目标元素、目标元素重复出现的左右边界标志变量 true--左边界 false--右边界 int binarySearch(vector&lt;int&gt;&amp; nums, int target, bool lower) &#123; // 二分的左右边界赋值。边界值初始化为数组大小（不是数组最后一位） int left = 0, right = (int)nums.size() - 1, ans = (int)nums.size(); while (left &lt;= right) &#123; int mid = (left + right) / 2; //// 当mid指的数大于target，说明目标区域在左侧 // 而当mid指的数等于target，且同时要找的是左边界时，就不排除当前mid所指的数就是目标区域左边界（此时是有可能左右边界重合） if (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] == target)) &#123; right = mid - 1; ans = mid; &#125; else &#123; // 当mid指的数小于target，或者找的是右边界且mid等于target，则不需要调整ans位置，因为ans本来就处在目标区域的最右边。 left = mid + 1; &#125; &#125; return ans; &#125; vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int leftIdx = binarySearch(nums, target, true); // 使用二分查找找第一次出现 int rightIdx = binarySearch(nums, target, false) - 1; // 使用二分查找找最后一次出现 // 如果第一次出现小于等于第二次出现、最后一次出现小于数组大小、并且两次出现确实都是target，则可以返回 if (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.size() &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123; return vector&lt;int&gt;&#123;leftIdx, rightIdx&#125;; &#125; // 否则返回[-1,-1] return vector&lt;int&gt;&#123;-1, -1&#125;; &#125;&#125;;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}]},{"title":"《C++ Primer 第五版》阅读过程查漏补缺 Chapter5","date":"2021-05-11T08:50:22.000Z","path":"2021/05/11/《C++ Primer 第五版》阅读过程查漏补缺 Chapter5/","text":"这一章前半部分好像没有什么好说的，略过总结了就。主要说一下try-catch部分。 条件语句else悬垂这种问题是当我们嵌套使用if分支时，会出现if分支多于else分支的情况，此时else和if的匹配问题就是我们常说的悬垂问题。 C++规定，else与离他最近的尚未匹配的if进行匹配。 解决else悬垂的最好办法就是使用花括号，成块来进行匹配。 switch语句 case关键字和它对应的值一起被称为case标签（case label）。case标签必须是整型常量表达式。 default标签即使不打算做任何事情，也一定要定义这个标签。同时标签不能孤零零存在，必须跟上一条语句，或者另外一个case标签。如果switch中出现了一个空的default作为结束，那么这个default标签后面必须跟上空语句或者空块。 迭代语句while语句12while (condition) statement 在while结构中，只要condition求值结果为真，则一直执行statement。condition不能为空，如果condition第一次求值就是false，则statement不执行。 while的条件部分可以是一个表达式，也可以是一个带初始化的变量声明。通常应该有条件本身、或者循环体改变表达式的值，否则循环无法终止。 传统for语句传统格式： 12for (init-statement; condition ； expression) statement 每次循环流程为： init-statement 初始化（开始时执行，只执行一次） 判断condition是否满足，如果不满足，马上结束循环。 如果满足，执行statement 将init-statement初始化的变量进行修改 init-statement也可以定义多个对象，但是只能有一个声明语句，因此所有变量的基础类型都必须相同。 当然我们也可以省去expression，这样需要在条件部分或循环体中改变迭代变量的值。 范围for语句12for (declaration:expression) statement expression表示一个序列。包括不限于花括号括起来的初始值列表、数组、vector和string等类型的对象。这些对象公共特点是拥有能返回迭代器的begin和end成员 do while语句123do statementwhile (condition) 在该种语句中，求condition前要限制性statement，condition不能为空。condition使用的变量必须定义在循坏体外，因为如果允许在条件部分定义，则不合理。 跳转语句continue语句终止最近循环中的当前迭代开始下一次迭代。 对于范围for语句来说，就是用序列中的下一个元素初始化循环控制变量。 try-catch语句块和异常处理c++中，异常处理包括： throw表达式。异常检测部分使用throw表达式来表示他遇到了无法解决的问题。throw 引发（raise） 异常 try语句块和catch子句，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个catch子句结束。try语句块中代码抛出的异常通常会被某个catch子句处理，因为catch子句处理异常，他们也被称作异常处理代码 一套异常类，用于在throw表达式和相关的catch字句之间传递异常的具体信息 try-catch语句块1234567try &#123; program-statements&#125; catch (exception-declaration) &#123; handler-statements&#125; catch (exception-declaration) &#123; handler-statements&#125; // ``` try关键字后是一个块，这个块是可能存在异常的行为 try块之后是一个或多个catch子句，catch子句包括三部分：cath关键字、括号中的对象的声明（异常声明）、以及一个块。 当选中某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳到try语句块最后一个catch子句之后的语句继续执行。 复杂系统中，程序遇到异常代码前，执行路径可能已经经过了多个try语句块，就是当try语句块中调用了另一个包含有try语句块的函数，层层包含、层层嵌套的情况。 寻找处理代码和函数调用链相反，异常抛出时，首先搜索该异常的函数，如果没有匹配的catch，则终止该函数，并在调用该函数的函数中继续寻找，如果还是没有找到匹配的catch子句，新的函数也会被终止，一直搜索到找到合适类型的catch子句为止 如果最终没找到合适的catch子句，程序会转到terminate的标准库函数，该函数和系统相关，一般情况是导致程序非正常退出。 对于没有try语句块定义的异常，同样就是会转到terminate的标准库函数。 能够在异常发生期间正确执行“清理”工作的程序被称为异常安全代码，编写异常安全代码是非常困难的。 标准异常c++标准库定义了一组类，用于报告标准库函数遇到的问题，这些异常类分别定义在4个头文件： exception头文件定义了最通用的异常类。只报告异常发生，不提供额外信息 stdexcept头文件定义了几种常用的异常类 new头文件定义了bad_alloc异常类型 type_info头文件定义了bad_cast异常类型。 标准库异常类只定义了很少的运算，包括创建、拷贝异常类型的对象、以及为异常类型对象赋值。 我们只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。 其他异常类型则应该使用string或C风格字符串初始化这些类型的对象，但不允许使用默认初始化。当创建此类对象时，必须提供初始值，即错误相关的信息。 异常类型只定义了一个what成员函数，返回值是一个C风格字符串的const char*，其目的是提供关于异常的文本信息。","tags":[{"name":"C++","slug":"C","permalink":"https://zijian.wang/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zijian.wang/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"安装FastDDS中遇到的问题","date":"2021-04-12T03:00:00.000Z","path":"2021/04/12/安装fastDDS中遇到的问题/","text":"最近在安装FastDDS，按照官网教程以为很简单，结果却踩了不少的坑，记一下，其中有一些问题在ROS1、ROS2以及Micro-ROS中都有出现，可以作为一些参考。 问题一：’vcs’ not found问题表现 问题解决官方的教程问题，pip3 install -U colcon-common-extensions vcstool命令前加上sudo。否则安装的东西不会加到路径中 问题二：pytest版本不对问题表现 问题解决运行命令强制安装一下 sudo pip3 install pytest-rerunfailures 如果这一步忽略了，那么下面问题四就会出现。再安装也不晚。 问题三：vcs import src &lt; fastrtps.repos 很慢、并且失败主要原因是因为懂得都懂的存在，但问题就在于你打开了小飞机都没有用。 问题表现在执行了命令vcs import src &lt; fastrtps.repos后，会出现若干个E，以及红字报错，如图所示。 问题分析与解决vcs命令是一个版本控制命令，这句命令的主要功能是把fastrtps.repos中记录的一些命令进行执行，并将获得的文件放入src文件中。 我们打开fastrtps.repos，可以发现里面的内容如下所示： 123456789101112131415161718192021repositories: foonathan_memory_vendor: type: git url: https://github.com/eProsima/foonathan_memory_vendor.git version: master fastcdr: type: git url: https://github.com/eProsima/Fast-CDR.git version: master fastrtps: type: git url: https://github.com/eProsima/Fast-DDS.git version: master fastrtpsgen: type: git url: https://github.com/eProsima/Fast-DDS-Gen.git version: master fastrtpsgen/thirdparty/idl-parser: type: git url: https://github.com/eProsima/IDL-Parser.git version: master 其本质就是创建一个文件夹，然后使用git clone命令，将url中的东西下载到这个文件夹，五个部分分别下载五个文件夹。报错信息中E的数量和该文件中的部分数目是对应的。 所以本质是github的问题，仓库在墙外，所以导致访问超时失败。 当然有很多解决办法，个人觉得百分百成功的应该就是翻墙大法。但是VPN开启后还是相同的问题，主要是因为git没有走代理的端口，所以我们应该设置一下git走代理端口。 一般我们使用的翻墙工具是ss嘛，是基于socks协议的，所以我们需要这两个命令行： 12git config --global http.proxy &#x27;socks5://127.0.0.1:1080&#x27;git config --global https.proxy &#x27;socks5://127.0.0.1:1080&#x27; 然后再执行一遍（记得打开小飞机）vcs import src &lt; fastrtps.repos 显然已经有四个成功了！没成功那个我感觉可能是因为第三个、第四个都是往目录fastrtpsgen中git东西，然后可能它是先有thirdparty这个文件夹，所以因为fastrtpsgen路径非空的原因，导致git失败。事实上后来发现这种问题是小概率时间，大概率是一遍成功的。看一下此时fastrtpsgen的目录结构 果然只有第五部分git成功了。我的解决方案是删掉fasrtrtpsgen，然后重新执行vcs import src &lt; fastrtps.repos，这次就会比较快，因为很多已经git过了，没再报错。 重新看一下fastrtpsgen的目录结构，没有问题。 当然这部分具体原因应该涉及vcs对repo进行解释的具体过程，我还不甚清楚。后面我会再调查一下。 对了，最后记得把git代理关掉，否则访问国内资源会很慢，以及万一vpn没关就会啥都访问不到。关闭命令是 12git config --global --unset http.proxygit config --global --unset https.proxy 问题四：colcon build失败（如果问题二解决了这个问题不会再发生）主要问题是依赖问题，pytest下载的版本问题。 问题表现上一步安装完毕后，进入src目录，执行colcon build命令，colcon是基于CMake的工具，是用来构建软件包的，也是ROS2开发工具。本来以为前面按照教程装好了依赖应该没问题了，结果还是发生了报错，报错很长，但是都差不多，截取一部分放在下面： ········· ERROR:colcon.colconcore.entrypoint:Exception loading extension ‘colconcore.environmentvariable.allshells’: (pytest 4.6.9 (/usr/lib/python3/dist-packages), Requirement.parse(‘pytest&gt;=5.0’), {‘pytest-rerunfailures’})Traceback (most recent call last): File “/home/wzj/.local/lib/python3.8/site-packages/colconcore/entry_point.py”, line 120, in load_entry_points extension_type = load_entry_point(entry_point) File “/home/wzj/.local/lib/python3.8/site-packages/colcon_core/entry_point.py”, line 168, in load_entry_point return entry_point.load() File “/usr/lib/python3/dist-packages/pkg_resources/__init\\.py”, line 2444, in load self.require(args, *kwargs) File “/usr/lib/python3/dist-packages/pkg_resources/__init\\.py”, line 2467, in require items = working_set.resolve(reqs, env, installer, extras=self.extras) File “/usr/lib/python3/dist-packages/pkg_resources/__init\\.py”, line 792, in resolve raise VersionConflict(dist, req).with_context(dependent_req)pkg_resources.ContextualVersionConflict: (pytest 4.6.9 (/usr/lib/python3/dist-packages), Requirement.parse(‘pytest&gt;=5.0’), {‘pytest-rerunfailures’}) ········· 问题分析与解决一看就知道是pytest版本没跟上，虽然不知道啥原因，但是不妨碍我重新安装一下试试。执行命令sudo pip(pip3) install pytest-rerunfailures（ps. 网上抄的） 虽然有一大堆can&#39;t uninstall XXX.No files were fount to uninstall但是最后看到了Successfully installed iniconfig-1.1.1 py-1.10.0 pytest-6.2.3 toml-0.10.2,说明缺少的pytest高版本已经有了， 重新执行colcon build就开始跑了。 问题五：colcon build失败（二）问题表现东西挺多，我直接贴log Cloning into ‘foo_mem-ext’…Note: switching to ‘c619113’. You are in ‘detached HEAD’ state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by switching back to a branch. If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -c with the switch command. Example: git switch -c Or undo this operation with: git switch - Turn off this advice by setting config variable advice.detachedHead to false HEAD is now at c619113 Whitespace clean up (#70)Submodule ‘cmake/comp’ (https://github.com/foonathan/compatibility.git) registered for path ‘cmake/comp’Cloning into ‘/home/wzj/Fast-DDS/build/foonathan_memory_vendor/foo_mem-ext-prefix/src/foo_mem-ext/cmake/comp’…CMake Error at cmake/comp/comp_base.cmake:288 (message): error downloading feature file cpp11_lang/constexpr.cmake: “Failure when receiving data from the peer”. Check spelling of feature. Trying 185.199.108.133:443... TCP_NODELAY set connect to 185.199.108.133 port 443 failed: Connection refused Trying 185.199.109.133:443... TCP_NODELAY set connect to 185.199.109.133 port 443 failed: Connection refused Trying 185.199.110.133:443... TCP_NODELAY set Connected to raw.githubusercontent.com (185.199.110.133) port 443 (#0) ALPN, offering h2 ALPN, offering http/1.1 successfully set certificate verify locations: CAfile: /etc/ssl/certs/ca-certificates.crt CApath: /etc/ssl/certs [5 bytes data] TLSv1.3 (OUT), TLS handshake, Client hello (1): [512 bytes data] [5 bytes data] TLSv1.3 (IN), TLS handshake, Server hello (2): [122 bytes data] [5 bytes data] [5 bytes data] [1 bytes data] TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8): [19 bytes data] [5 bytes data] [1 bytes data] TLSv1.3 (IN), TLS handshake, Certificate (11): [3067 bytes data] [5 bytes data] [1 bytes data] TLSv1.3 (IN), TLS handshake, CERT verify (15): [264 bytes data] [5 bytes data] [1 bytes data] TLSv1.3 (IN), TLS handshake, Finished (20): [52 bytes data] [5 bytes data] TLSv1.3 (OUT), TLS change cipher, Change cipher spec (1): [1 bytes data] [5 bytes data] [1 bytes data] TLSv1.3 (OUT), TLS handshake, Finished (20): [52 bytes data] SSL connection using TLSv1.3 / TLS_AES_256_GCM_SHA384 ALPN, server accepted to use h2 Server certificate: subject: C=US; ST=California; L=San Francisco; O=GitHub, Inc.; CN=www.github.com start date: May 6 00:00:00 2020 GMT expire date: Apr 14 12:00:00 2022 GMT subjectAltName: host “raw.githubusercontent.com” matched cert’s “*.githubusercontent.com” issuer: C=US; O=DigiCert Inc; OU=www.digicert.com; CN=DigiCert SHA2 High Assurance Server CA SSL certificate verify ok. Using HTTP2, server supports multi-use Connection state changed (HTTP/2 confirmed) Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0 [5 bytes data] [1 bytes data] [5 bytes data] [1 bytes data] [5 bytes data] [1 bytes data] Using Stream ID: 1 (easy handle 0x5575f191ae80) [5 bytes data] [1 bytes data] GET /foonathan/compatibility/master/cpp11_lang/constexpr.cmake HTTP/2 Host: raw.githubusercontent.com user-agent: curl/7.66.0 accept: / [5 bytes data] [1 bytes data] TLSv1.3 (IN), TLS handshake, Newsession Ticket (4): [193 bytes data] OpenSSL SSL_read: Connection reset by peer, errno 104 Failed receiving HTTP2 data [5 bytes data] [1 bytes data] OpenSSL SSL_write: Broken pipe, errno 32 Failed sending HTTP2 data Connection #0 to host raw.githubusercontent.com left intact Call Stack (most recent call first): cmake/comp/comp_base.cmake:347 (_comp_fetch_feature) cmake/comp/comp_base.cmake:369 (_comp_handle_feature) cmake/compatibility.cmake:13 (comp_target_features) CMakeLists.txt:50 (include) make[2]: [CMakeFiles/foo_mem-ext.dir/build.make:108: foo_mem-ext-prefix/src/foo_mem-ext-stamp/foo_mem-ext-configure] Error 1make[1]: [CMakeFiles/Makefile2:76: CMakeFiles/foo_mem-ext.dir/all] Error 2make: * [Makefile:130: all] Error 2 问题分析和解决中间的几次try是我将raw.githubusercontent.com域名解析出来的四个ip写到了/etc/hosts里，显然在尝试185.199.110.133的时候应该成功了，并且已经有了一部分数据交换，但是在后来http2 data的接受时候又失败了。 解决办法目前是没有很好的解决办法，运气好的话换网络，用手机热点有一定几率成功（？？？经典ROS），至于原因还不清楚。 ···· 在github上提了issue，大佬给了回复，但是还没有解决我的问题，哎。 ····· 已经在看计算机网络了，辣鸡gayhub。","tags":[{"name":"DDS","slug":"DDS","permalink":"https://zijian.wang/tags/DDS/"},{"name":"工具","slug":"工具","permalink":"https://zijian.wang/tags/%E5%B7%A5%E5%85%B7/"},{"name":"研究方向","slug":"研究方向","permalink":"https://zijian.wang/tags/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/"}]},{"title":"《C++ Primer 第五版》阅读过程查漏补缺 Chapter4","date":"2021-04-10T15:22:22.000Z","path":"2021/04/10/《C++ Primer 第五版》阅读过程查漏补缺 Chapter4/","text":"这一章名为表达式，其实讲了C++中的一些运算符。大部分其实跟其他编程语言都很类似，在这里把C++11标准的一些特性以及之前不是特别清楚的记录一下。 基本概念重载运算符当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了营外一层含义，所以称之为重载运算符。IO库的&gt;&gt;和&lt;&lt;运算符以及string对象、vector对象和迭代器使用的运算符都是重载运算符。 左值和右值这两个名词虽然是由C语言中继承过来，但是由于常量对象的存在等原因，不再那么简单。简单归纳为：当一个对象被用作右值的时候，用的是对象的值（内容），当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。 优先率和结合律如果可以尽量加括号 求值顺序某些运算符没有指定执行顺序，如果表达式中指向并修改了同一个对象，将会导致错误并产生未定义行为。比如&lt;&lt; 运算符没有明确规定何时以及如何对运算对象求值，所以下述代码是未定义的。 12int i = 0;cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ++i &lt;&lt; endl; 有四种运算符明确规定了运算对象的求值顺序，即”&amp;&amp;(逻辑与)“，”||（逻辑或）“，” ? :（三目条件运算符） “以及”,（逗号运算符）” 经验：所以如果拿不准尽量使用括号来强制组合关系。如果改变了某个运算对象的值，在表达式的其他地方尽量不要使用这个表达对象。 算术运算符主要是除法和取余（%）运算，c++11标准规定商一律向0取整，即直接删除小数部分 对于取余运行算，如果m和n是整数且n非0，则表达式(m/n)*n+m%n的求值和m相同.隐含的意思是，如果m%n不等于0，则它的符号和m相同. 逻辑和关系运算符逻辑与和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为短路求值（short-circuit evaluation） 对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值 对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值 赋值运算符赋值运算符满足右结合律，如： 12int ival, jval;ival = jval = 0; // 正确，都被赋值为0 但是只能在两种变量类型相同或者允许转换时如此使用。 递增和递减运算符递增递减运算符有两种形式：前置版本和后置版本 前置版本：运算符首先将运算对象进行+1或-1操作，然后将改变后的对象作为求值结果 后置版本：运算符也会将运算对象进行+1或-1操作，但是求值结果是运算对象改变之前的那个值的副本。 除非必要，建议不要用后置版本： 因为前置版本的递增递减运算符避免了不必要的工作，它把值+1或-1后直接返回了改变的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们并不需要修改前的值，那么后置版本的操作就是一种浪费。对于整数或指针类型，这种额外工作编译器可以给出优化，但是对于复杂的迭代器类型，这种额外的工作开销就大了。 在一条语句中混用解引用和递增运算符我们在一条复合表达式种既将变量+1或-1，又能使用他原来的值，这就是后置版本的使用情景。 注意后置递增运算符的优先级高于解引用运算符。如例子： 1234auto pbeg = v.begin();// 输出元素直至遇到第一个负值为止while(pbeg != v.end() &amp;&amp; *beg&gt;=0) cout &lt;&lt; *pbeg++ &lt;&lt; endl; //输出当前值并将pbeg向前移动一个元素。 这里面的pbeg++ 等同于 (pbeg++)。解释就是pbeg++将指针pbeg的值+1，然后返回pbeg指针的原始值的副本作为求值结果，然后对这个副本指针进行解引用。最终这条语句输出的时pbeg开始时指向的元素的值，同时将指针向后移动一个位置。 运算对象可按任意顺序求值由于大多数运算符没有规定运算对象的求值顺序，所以如果一条子表达式改变了某个运算对象的值，另一个子表达式又要使用该值的话，运算对象的求值顺序就很关键了。因为递增运算符和递减运算符会改变运算对象的值，所以要提放在复合表达式中错用两个运算符。 成员访问运算符箭头运算符作用于一个指针类型的运算对象，结果是一个左值。 点运算符分为两种情况： 如果成员所属的对象是左值，则结果为左值 如果成员所属的对象是右值，则结果为右值 条件运算符嵌套条件运算符条件运算符满足右结合律，意味着运算对象一般按照从右向左的顺序组合，所以对于下述代码，靠右的条件运算构成了靠左条件运算的：分支 1finalgrade = (grade&gt;90) ? &quot;high pass&quot; : (grade&lt;60) ? &quot;fail&quot; : &quot;pass&quot;; 在输出表达式中使用条件运算符条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通常需要在它两端加上括号。 123cout &lt;&lt; ((grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;); //输出fail或者passcout &lt;&lt; (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;; //输出1或者0cout &lt;&lt; grade &lt; 60 ? &quot;fail&quot; : &quot;pass&quot;; // 错误，试图比较cout和60 在第二条表达式中，grade和60的比较结果是&lt;&lt;运算符的运算对象，如果grade&lt;60为真输出1，否则为0。然后&lt;&lt;运算符的返回值是cout，然后cout会作为条件运算符的条件。换言之，第二条语句等价于： 12cout &lt;&lt; (grade &lt; 60); //输出0 或者 1cout ? &quot;fail&quot; : &quot;pass&quot;; // 根据cout的值来产生fail或pass，但无法输出 第三条表达式等价于： 12cout &lt;&lt; grade ; // 小于运算符的优先级低于移位运算符，所以先输出gradecout &lt; 60 ? &quot;fail&quot; : &quot;pass&quot;; // 比价cout和60 位运算符位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。 一般来说，如果运算对象是”小整型“，它的值会被自动提升到较大的整数类型。 移位运算符右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会出现未定义行为。 左移运算符（&lt;&lt;）在右侧插入值为0的二进制位。右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值位0的二进制位，如何选择要视具体环境而定。 位与、位或、位异或运算符对于位异或运算符（^）来说，如果两个运算对象的对应位置有且只有一个为1，则运算结果中该位位1，否则为0。 使用位运算符12quiz1 |= 1UL &lt;&lt; 27; //在不改变其他位的前提下将第27位置为1quiz1 &amp;= ~（1UL&lt;&lt;27）; //在不改变其他位的前提下将第27位置为0 sizeof运算符sizeof运算符返回一个表达式或者一个类型名字所占的字节数。sizeof运算符满足右结合律，得到的是一个size_t类型的常量表达式。运算符的运算对象有两种形式： 12sizeof (type)sizeof expr 在第二种形式中，sizeof返回的是表达式的结果类型的大小。注意sizeof并不实际计算其运算对象的值。 表达式sizeof *p比较特殊，特殊在两个方面 由于sizeof满足右结合律并且和运算符优先级一样，所以等价于```sizeof (p)```。 因为sizeof不会实际求运算对象的值，所以即使p是一个无效的指针也不会有什么影响。也就是说在sizeof的运算对象中解引用一个无效指针依旧是一个安全行为。因为指针实际上并没有被解引用，sizeof不需要真正的解引用就可以知道他所指的对象的类型。 sizeof运算符的结果部分依赖于其作用的类型，比较特殊的是以下几个： 对引用类型执行sizeof运算得到是被引用对象所占空间的大小。 对指针执行sizeof运算得到指针本身所占空间的大小 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有元素各执行一次运算并将结果求和。注意，sizeof运算不会把数组转换成指针来处理 对string对象和vector对象执行sizeof运算只返回该类型固定部分的大小，而不会计算对象中的元素占用了多少空间。。 因此我们可以用数组大小除以单个数组元素的大小得到元素的个数 1constexpr size_t sz = sizeof(ia)/sizeof(*ia); 类型转换算术类型之间的隐式转换被设计得尽可能避免损失精度。很多时候，如果表达式中既有整数类型的运算对象也有浮点数类型的运算对象，整型会转换成浮点型。 何时发生隐式类型转换 大多数表达式中，比int类型小的整型值首先提升为较大的整数类型 在条件中，非布尔值会被转换成布尔类型 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型 函数调用也会发生类型转换 算术转换整型提升对于bool、char、signed char、unsigned char、short和unsigned short等类型来说，只要它们所有可能的值都存在int里，他们就会提升成int类型；否则，提升成unsigned int类型。 较大的char类型（wchar_t、char16_t、char32_t）提升成int、unsigned int、long、unsigned long、long long和unsigned long long中最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。 无符号类型的运算对象如果一个运算对象是无符号的，另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算转换成无符号的。 如果带符号类型大于无符号类型，此时转换的结果依赖于机器。 其他隐式类型转换数组转换成指针大多数用到数组的表达式，数组可以自动转换成指向数组首元素的指针 但是当数组被用作decltype关键字的参数，或者作为取地址符(&amp;)、sizeof以及typeid等运算符的运算对象时，上述转换不会发生。同样的，如果用一个引用来初始化数组，上述转换也不会发生。 指针的转换c++规定了几种指针转换方式，包括 常量整数值0或者字面值nullptr可以转换成任意指针类型 指向任意非常量的指针能转换成void* 指向任意对象的指针能转换成const void* 具有继承关系的类型间还有另外的指针转换方式 转换成布尔类型一种从算术类型或指针类型向布尔类型自动转换的机制。如果指针或算术类型的值为0，转换结果为false，否则转换结果为true。 转换为常量允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。但是相反的转换并不存在，因为它试图删掉底层const 类类型定义的转换类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。 常见的类类型转换比如： 在需要标准库string类型的地方使用C风格字符串 在条件部分读入sitream 123const char *str = s.c_str(); //s是一个string类型string s,t = &quot;a value&quot;; //字符串字面值转换成string类型while(cin&gt;&gt;s) //while的条件部分把cin转换成布尔值 IO库定义了从istream向布尔值的转换规则。所得的布尔值到底是什么由输入流的状态决定，如果最后一次读入成功，转换得到的布尔值为true，相反失败则为false。 显示转换显示转换即强制类型转换。我在C语言中经常看到的强转都是直接的要转换的类型+expr。c++则有一些规定 命名的强制类型转换命名的强制类型转换形式是： cast-name(expression) type为转换的目标类型 expression是要转换的值。如果type是引用类型，则结果是左值。cast_name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。cast_name指定了执行的哪种转换。 static_cast ——用于非常量的类型强转当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时强制类型转换告诉程序读者和编译器：我们知道并且不在乎潜在的精度损失。 我们还可以使用static_cast来找回存在于void*指针中的值，如： 12void* p = &amp;d; // 正确：任何非常量对象的地址都能存入void*double* dp = static_cast&lt;double*&gt; (p); //正确：将void*转换回原来的指针类型 但是在此过程中，我们必须严格保证转换后所得的类型就是指针所指的类型。类型一旦不符，会产生未定义的后果。 const_cast ——非常量对象解const的类型强转const_cast只能改变运算对象底层const，如： 12const char *pc;char *p = const_cast&lt;char*&gt;(pc); //正确，但是通过p写值是未定义行为 对于将常量对象转换成非常量对象的行为，我们一般称其为“去掉const性质”。一旦我们去掉了某个对象的const性质，编译器将不会再阻止我们对改对象进行写操作。如果对象不是一个常量，使用强制类型转换获得写权限是合法的行为。否则，就会发生未定义的后果。 只有const_cast能改变表达式的常量属性，但是const_cast不能改变表达式的类型。 常用于函数重载的上下文 reinterpret_cast ——将内存中的值重新解释的类型强转reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。 123int *ip;char *pc = reinterpret_cast&lt;char*&gt;(ip);string str(pc); //导致异常，因为pc实际上指的真实对象是一个int而不是字符","tags":[{"name":"C++","slug":"C","permalink":"https://zijian.wang/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zijian.wang/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"XRCE-DDS协议分析","date":"2021-04-08T10:18:00.000Z","path":"2021/04/08/XRCE-DDS协议分析/","text":"对XRCEDDS协议的阅读理解和分析 关于睡眠周期的相关问题嵌入式设备，尤其是资源受限的嵌入式设备一般都会有能耗管理的相关模块，可以让设备在空闲或等待状态时进入睡眠模式来减少能耗。XRCE-DDS声称对具有睡眠周期的嵌入式设备有很好的考虑，这里了细致对specification进行分析看都有哪些举措。 检索specification中跟sleep相关的语句，发现协议出现sleep有15处，总结有7处谈及对睡眠周期的处理，下述是详细的列举和介绍。 Scope中的概述和XRCE Object Model中General The XRCE protocol is a client-server protocol between resource-constrained devices (clients) and an XRCE Agent (server). The protocol allows the resource constrained devices with sleep/wake cycles to have access to the DDS Global Data Space over limited-bandwidth networks. ​ 这里就是协议的第一章节以及对象模型的概述章节，点明了该协议是一个资源受限设备和代理之间的客户端-服务器协议。该协议允许拥有睡眠/清醒周期的资源受限设备在受限带宽网络上拥有访问DDS全局数据空间的能力 XRCE Client一节中对XRCE-DDS规范中的XRCE Object Model不同于DDS Object Model的三个原因描述的第二条 ··· The XRCE Client connectivity is assumed to be inherently intermittent due to potentially aggressive use of lowpower mode and deep sleep to conserve battery or loss of radio connectivity. The DDS-XRCE DDS Object Model must overcome intermittent connectivity by introducing a “session,” which can exist across repeated sleep-wakeup cycles by a device. ··· ​ 这里是介绍XRCE对象模型的第二小节XRCE Client处的一个原因解释，主要是区分DDS对象模型。这里XRCE Client的链接被认为本质是间歇性的，主要是因为有可能很积极的使用低功耗模式或者深度睡眠来节省电池，或者说是因为无线电链接的经常丢失。所以提到该对象模型引入了session来克服间歇性链接，且session是可存在于设备的重复睡眠唤醒周期中的。 ​ 这里非常重要，首先介绍了Client中一个非常重要的概念session的定义的原因和用途，就是为了克服间歇性链接，其次强调session可以在睡眠唤醒周期中存在，这一点似乎对我们建模非常重要，然后就是介绍了间歇性链接产生的原因，是很合理的。 介绍read操作所携带的参数的定义，有一个参数叫做min_pace_period The setting of the min_pace_period configures the minimum interval in milliseconds between the sample messages sent from the Agent to the Client. This period makes it possible for the client to go into a sleep cycle between messages. ​ 这里是在介绍XRCE DataReader对象模型的read操作时，对其一个名为min_pace_period的参数的介绍，顾名思义，这个参数是控制从Agent发往Client端的多个消息间的最小时间间隔的。这个时间间隔使得Client可以在消息接收间也可以进入一个睡眠状态。 ​ 也就是说，Client有可能的睡眠周期发生的时间，就是在定期接收Agent发来的消息之间。这是一种命令Agent控制消息发送频率的手段。我们在建立模型时，可以考虑将睡眠周期放在这里？ XRCE Protocol的概述部分，介绍该协议主要为了解决哪些设备带来的挑战，其中第二条、第七条、第12条和第13条有所涉及 ​ ······· Work with devices that undergo sleep cycles. These devices may be active once every few minutes, days, months, or even years. ​ ······ Support receiving information both reliably and in a best effort manner, even if the information was sent while the Client was undergoing a sleep cycle. ​ ······ Cannot operate without infrastructure support. They need an XRCE Agent to be reachable to them. This is a necessary consequence of the need for XRCE Clients to undergo deep sleep cycles. Do not communicate directly peer-to-peer. All communications are brokered (relayed) by one or more DDSXRCE Agents. This is also a necessary consequence of the need for Clients to undergo deep sleep cycles. ​ 其中第2条只是一个简单的陈述，就是设备具有睡眠周期，可能只会隔几分钟、几天、几个月甚至几年才是活跃的。第7条表示协议应该支持Best Effort方式的信息传输，即便是针对睡眠周期内的client。第12条则是强调XRCE Agent的重要性，表明因为Client会进入睡眠周期，所以必须要靠Agent来访问Client。第13条则是在否定直接的P2P通信，依然是强调所有的通信都应该依靠Agent实现，因为Client可能会进入睡眠周期中。 ​ 这个其实主要只是一个概述，给我们带来的有价值的东西不是很多，但有3点需要注意，第一点是睡眠周期应该是可长可短的，第二点是如果我们采用BestEffort方式进行消息传输，似乎不需要考虑Client是否处于睡眠周期内，第三点就是P2P通信无疑对于有睡眠周期的设备来说是不现实的。 介绍READ_DATA这一submessage的部分，重申了read操作的作用 The read operation also allows an XRCE Client to control when data may be sent by the XRCE Agent so that the Agent does not unnecessarily wake up the Client during its sleep cycle ​ read操作可以允许一个XRCE Client来控制由Agent发送的数据何时被送达，这样Agent就不会将Client从睡眠周期中进行唤醒 ​ 注意这里的表述似乎在说Agent的消息可以将Client从睡眠周期中唤醒，但是那是不被希望的。这能否为我们的模型带来一些有趣的东西呢？ 介绍ACKNACK这一submessage的部分。 The ACKNACK submessage is used to enable a transport independent reliability protocol to be implemented. If the transport used for a session is able to reliably send messages in case of disconnection or a wakeup/sleep cycle then these messages may not be required. This specification does not dictate whether ACKNACK messages shall be sent only in response to HEARTBEAT. messages or can also be sent whenever one side detects message loss. However, in general it is expected that it is the XRCE Client that initiates any synchronization, and therefore,the XRCE Agent will only send ACKNACK messages in response to HEARTBEAT messages. This is because an XRCE Client may not be continually available as it goes on sleep cycles. ​ ACKNACK 子消息被用来实现一个独立于可靠协议的传输实现，如果session代表的传输能够在断开连接或者一个清醒睡眠周期中保持可靠的话，这个消息可能就不需要了。 ​ 规范并没有表明ACKNACK消息是应该作为HEARTBEAT消息的响应被发送，还是在无论何时任何一边发现消息丢失后就被发送。通常情况下，应该有XRCE Client来发起任何的同步，因此，XRCE Agent将仅仅在回应HEARTBEAT消息时发送ACKNACK，因为XRCE Client在进入睡眠周期后可能是不可持续使用的。 ​ 第一段话其实表明了XRCE-DDS在不可靠通信协议的基础上，实现的可靠的一种手段，即ACKNACK子消息。所以也表明如果有一个可靠的底层协议可以满足断开连接以及睡眠情况下的可靠传输的话，ACKNACK子消息不是必要的。 ​ 第二段话则是阐明了重点，首先是ACKNACK发送的两种情景，一种是仅仅作为HEARTBEAT的回应，另一种是发现消息丢失后告知对方。根据后面的描述，对于XRCE Agent来说，为了防止在Client睡眠期间持续发送ACKNACK造成不必要唤醒或者说不必要的持续发送，仅仅适用于第一种情景，而对于XRCE Client来说，尽管协议里没有明确指出，但应该是在大多数情况下，周期性的检查消息是否丢失，丢失后立即告知对方。 ​ （PS：这里其实如果考虑细节非常头疼，就是对于XRCE Client来说，是应该在每收到一个消息就检测是否是丢失消息呢？还是应该有一个区间，允许乱序发送呢？但是结合specification中好像有介绍按序接收，但是按序接收会不会是指上层对消息进行的重组呢？总之就非常头疼。） 介绍HEARTBEAT这一submessage的部分 This specification does not limit a session to use a particular type of transport. If a session transport is able to reliably send messages in case of disconnection or a wakeup/sleep cycle then these messages may not be required. This specification does not dictate the timing of HEARTBEAT messages. However, in general it is expected that it is the XRCE Agent will only send HEARTBEAT messages when it has some indication that the XRCE Client is active and not in a sleep cycle. This is to avoid awakening the XRCE Client unnecessarily. ​ 规范并没有限制一个session使用一个特定类型的传输。如果一个session的传输可以在断开连接或者清醒睡眠周期的条件下可靠地发送消息，那么HEARTBEAT也是不需要的。 ​ 规范也并没有表明HEARTBEAT消息的时间，通常来说希望Agent可以在得知XRCE Client是活跃的时候发送心跳消息，这是为了避免不必要的唤醒XRCE Client。 ​ 第一点没什么好解释的，跟ACKNACK相同，因为两者本来就是一对的。第二点可能就就需要我们考虑HEARTBEAT是否应该在XRCE Agent 和 XRCE Client端有不同的建模方式 client应用间的直接P2P通信 An additional drawback of the direct peer to peer communication is that the applications cannot easily go into sleep cycles as the XRCE Agents they contain need to be active in order to process the messages from the XRCE Clients. Therefore, is not suitable for many resource-constrained scenarios. ​ 直接的P2P通信的额外缺点是应用不能轻易进入睡眠周期，因为它们包含的XRCE代理需要保持活跃状态才可以处理XRCE CLients的消息，所以不适用于资源受限的环境。 ​ 大意就是分析了P2P通信在资源受限设备的不可行性。 对于时间相关的注意Read消息中含有ReadSpecification消息，该消息中含有一个结构体名为DataDeliveryControl，用来传输控制，其中包括了最大经过时间、最小传输间隙(min_pace_period)、每秒钟最大传输字节数(max_bytes_per_sec)以及最大消息数（max_sample）。其中最大经过时间(max_elapsed_time)表示将读取操作配置为在从进行读取操作的那一刻起经过指定的时间后终止。为0时表示没有最大值。 client_representation消息中含有client_timestamp，应该是用来指示ProxyClient当前Client的时间。agent_representation同理。两者通过这两个时间戳来进行时间同步。 如果存在continuous_read_options 成员，则代理应多次调用读取操作。 调用周期不能快于pace_period。 因此，返回的数据可能包含将来到达 DDS DataReader 的数据。 一旦 max_total_samples 已返回，或 max_total_elapsed_time 已过，代理应停止调用读取操作。 整体模型框架整体来说我们的系统就是一个由Client、Agent和Session、Stream以及Message组成的系统。 client和Agent通过一次握手建立链接，通过此链接，可以初始化形成session。 根据session本身默认的可靠stream流，发送create_client子消息，就可以在Agent处创建或重用ProxyClient 确认Agent处ProxyClient的存在后，就可以使用create子消息，利用ProxyClient来创建各种实体资源，包括Participate、Topic、Publisher\\Subscriber、DataWriter\\DataReader。 完成配置（包括预配置和自行配置）的客户端，可以进行收发消息。通过ClientKey来标识所要使用的ProxyClient，通过DataWriter或者DataReader来进行读写消息。 建模思考关于Channel与消息类型打算Client与Stream、Stream与Agent交互之间使用msg变量，使用的channel是write_msg和read_msg msg变量内部存在很多submsg，Agent到Root、ProxyClient由若干个不同的channel传递不同的变量，比如create_client、create、writedata、readdata","tags":[{"name":"DDS","slug":"DDS","permalink":"https://zijian.wang/tags/DDS/"},{"name":"研究方向","slug":"研究方向","permalink":"https://zijian.wang/tags/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/"},{"name":"协议阅读","slug":"协议阅读","permalink":"https://zijian.wang/tags/%E5%8D%8F%E8%AE%AE%E9%98%85%E8%AF%BB/"}]},{"title":"DDS Specification和DDSI-RTPS协议阅读理解","date":"2021-04-08T10:18:00.000Z","path":"2021/04/08/DDS/","text":"最近在研究XRCE-DDS的时候，被师兄问了两个关于DDS的问题，一个都没答上来，很惭愧，所以想回过头普及一下DDS的相关知识，很幸运找到了Paul大佬的《DDS与FastRTPS》一文，受益匪浅，在这里结合自己搜集到的其他资料和对协议原文的阅读，做一些总结。 DDS（数据分发服务）是一套通信协议和API标准，以数据为中心是他的特点，它基于发布-订阅模型进行设计。而FastRTPS是eProsima公司对DDS的一个开源实现。 DDS是一套中间件，提供介于操作系统和应用程序之间的功能，提供了低延迟、高可靠的通信以及可扩展的架构。 DDS其实分为两部分，一部分是DDS规范，一部份则是DDSI-RTPS协议，是一个互操作性协议，也就是真正实现通讯机制的部分，在ROS2中，也正是这部分，取代了ROS1的TCPROS和UDPROS。 所谓互操作性协议，就是为了满足互操作性而产生的一个协议，互操作性就是指两个实体的通信能力，如果两个实体之间能够在任何情况下都无误解的进行通信，那么我们就说这两个实体可以正确的互操作。 DDS的架构是这个样子的： 或者说是这个样子的： 在DDS规范中，有两个描述标准的文档 DDS Specification DDSI-RTPS DDS SpecificationDDS规范主要是描述了用于分布式应用程序通信和集成的以数据为中心的发布-订阅（DCPS模型）。定义了应用程序接口（API）和通信语义（行为和服务质量），他们可以有效地将信息从信息生产者传递给匹配的消费者。DDS规范的目的可以概括为”在正确的时间将正确的信息有效且稳健地传递到正确的位置“。 DCPS定义应用程序用于发布和订阅数据对象值地功能，它允许： 发布应用程序以标识要发布的数据对象，然后为这些对象提供值 订阅应用程序以识别他们感兴趣的数据对象，然后访问其数据值 应用程序用于定义主题，将类型信息附加到主题，创建发布者、订阅者实体，将QoS策略附加到所有这些实体，使所有这些实体运行。 主要包括两部分 平台无关模型（PIM） 基于PIM地OMG IDL平台的平台特定模型（PSM） DDSI-RTPSDDSI_RTPS主要描述了RTPS（Real Time Publish Subscribe Protocol）协议。该协议通过UDP等不可靠传输，实现最大努力（Best-Effort）和可靠的发布-订阅通信。RTPS是DDS实现的标准协议，它的目的和范围是确保基于不同DDS供应商的应用程序可以实现互操作。 RTPS协议旨在能够在多播和无连接的尽力传输方式（例如UDP/IP）上运行。 RTPS协议的主要特点包括： 性能和服务质量属性，通过标准IP网络为实时应用程序提供尽力而为和可靠的发布订阅通信。 容错，允许创建没有单点故障的通信网络。 可延展性，允许使用新服务来扩展和增强协议，同时不破坏向下兼容性和互操作性。 即插即用连接，以便自动发现新的应用程序和服务，应用程序可以随时加入和离开网络，无需重新配置。 可配置性，平衡数据传输的可靠性和及时性需求。 模块化，允许简单设备实现协议的子集并加入网络。 可扩展性，使系统可以扩展到非常大的网络。 类型安全，以防止应用程序编程错误影响远程节点的运营。 RTPS协议主要包括三部分 RTPS平台无关模型（PIM） RTPS平台有关模型（PSM） RTPS传输模型 RTPS PIM包括四个模块：结构模块、消息模块、行为模块和发现模块 结构模块定义通信端点 所有RTPS实体都与RTPS域相关联，RTPS域表示包含一组参与者（Participants）的单独通信平面。 参与者包含本地端点（Endpoints）。 有两种类型的端点：读取者（Readers） 和写入者（Writers）。读取者和写入者是通过发送RTPS消息来传达信息的参与者。写入者告知数据的存在并将数据域（Domain）上的本地可用数据发送给读取者，读取者可以请求和确认数据。 RTPS协议中的活动者和DDS实体一一对应，这是通信产生的原因。 消息模块定义这些断电可以交换的消息集合 消息模块定义RTPS写入者和读取者之间的原子信息交换的内容。消息（Message）由一个报文头（Header）后跟一些子消息（Submessage）组成。每个消息都是由一系列元素构建的。选择此结构是为了允许扩展子消息的内容和每个子消息的组成，同时保持向下兼容性。 行为模块定义了合法交互集以及他们如何影响通信端点的状态。 行为模块描述了可以在RTPS写入者和读取者之间交换的消息序列，以及时间和每条消息引起的写入者和读取者状态的变化。 互操作性所需的行为是根据实现必须遵循的最小规则集来描述的，以便实现互操作。实际实现可能表现出超出这些最低要求的不同行为，具体取决于他们希望如何权衡扩展性，内存要求和带宽使用。 为了说明这个概念，行为模块定义了两个参考实现。一个参考实现基于有状态写入者（StatefulWriters）和有状态读取者（StatefulReaders），另一个基于无状态写入者（StatelessWriters）和无状态读取者（StatelessReaders）。两种参考实现都满足互操作的最低要求，因此可以互操作，但由于它们存储在匹配的远程实体上的信息不同，因此表现出略微不同的行为。 RTPS协议的实际实现的行为可以是参考实现的完全匹配或组合。 发现模块定义如何自动发现和配置实体 发现模块描述了使参与者（Participants）能够获取域中所有其他参与者（Participants）和端点（Endpoints）的存在和属性信息的协议。这种元通信（metatraffic）使每个参与者（Participant）能够获得域中所有参与者（Participants），读取者（Readers）和写入者（Writers）的完整信息，并配置本地写入者与远程读取者进行通信，以及本地读取者与远程写入者进行通信。 发现是一个单独的模块。发现的独特需求，即写入者和读取者进行匹配所需的所有信息需要通过透明地即插即用传播，使得单个架构或协议不可能满足各种各样的可扩展性，性能和将部署DDS的异构网络的嵌入性需求。从此以后，引入多种发现机制是有意义的，这些机制从简单和有效（但不是很可扩展）到更复杂的分层（但更具可扩展性）机制。 RTPS平台特定模型（PSM）特定于平台的模型将RTPS PIM映射到特定的底层平台。它定义了所有RTPS类型和消息的位和字节的精确表示以及专属于平台的其他信息。可能支持多个PSM，但是DDS的所有实现必须是在UDP/IP之上实现PSM。 RTPS传输模型RTPS支持各种传输方式和传输QoS。该协议旨在能够在多播和尽力而为的传输方式（例如UDP/IP）上运行，并且只需要该传输方式提供非常简单的服务。实际上传输方式提供能够最大限度地发送数据包的无连接服务就足够了。也就是说传输方式不需要保证每个数据包会到达其目的地或者数据包按顺序传送。如果需要，RTPS在传输接口以上实现数据传输和状态的可靠性。这并不排除RTPS在可靠的传输方式之上实现。它使得支持更广泛的底层传输方式成为可能。 如果可以的话，RTPS还可以利用传输机制的多播功能，来自发送方的一条消息可以到达多个接收方。RTPS旨在促进底层通信机制的确定性。该协议提供了确定性和可靠性之间的公开权衡。RTPS对底层传输方式的一般要求可归纳如下： 传输具有单播地址（长度应在16字节以内）的通用概念。 传输具有端口（长度应在4字节以内）的通用概念，例如可以是UDP端口或者共享存储器段中的偏移等。 传输可以将数据报（未解释的八位字节序列）发送到特定的地址/端口。 传输可以在特定地址/端口接收数据报。 如果传输过程中消息不完整或已损坏，传输将丢弃消息（即RTPS假定消息已完成且未损坏）。 传输提供推断接收消息大小的方法。 DDSI-RTPS之PIM发现模块RTPS行为模块（前一章讲了行为模块）假定已正确配置RTPS端点，并与匹配的远程端点配对。 它不对如何进行此配置进行任何假设，仅定义如何在这些端点之间交换数据。 为了能够配置端点，实现必须获取有关远程端点的存在及其属性的信息。 为了获取此信息是发现模块的主题，发现模块定义了RTPS发现协议。 发现协议的目的是允许每个RTPS参与者发现其他相关参与者及其端点。 一旦发现远程端点，实现可以相应地配置本地端点以建立通信。 DDS规范同样依赖于发现机制的使用，以在匹配的DataWriter和DataReader之间建立通信。 DDS实现必须在加入和离开网络时自动发现远程实体的存在。 用户可以通过DDS内置topic访问此发现信息。 本模块中定义的RTPS发现协议为DDS提供了必需的发现机制。 概述RTPS规范将发现协议分为两个独立的协议： 参与者发现协议（Participant Discovery Protocol ，PDP） 端点发现协议（Endpoint Discovery Protocol ，EDP） 参与者发现协议（PDP）指定参与者如何在网络中彼此发现。一旦两个参与者发现彼此，他们就会使用端点发现协议（EDP）在其包含的端点上交换信息。除了这种因果关系，可以考虑两种协议是相互独立的。 实现可以选择支持多个PDP和EDP，可能是特定于供应商的。只要两个参与者至少具有一个共同的PDP和EDP，他们就可以交换所需的发现信息。 为了实现互操作性，所有RTPS实施都必须至少提供以下发现协议： 简单参与者发现协议（Simple Participant Discovery Protocol，SPDP） 简单端点发现协议（Simple Endpoint Discovery Protocol，SEDP） 两者都是基本的发现协议，适用于中小型网络。面向更大网络的其他PDP和EDP可能会添加到该规范的未来版本中。 最后，发现协议的作用是提供有关发现的远程端点的信息。参与者如何使用此信息来配置其本地端点取决于RTPS协议的实际实现，而不是发现协议规范的一部分。例如，对于8.4.7中引入的参考实现，在远程端点上获得的信息允许实现配置： 与每个RTPS StatelessWriter关联的RTPS ReaderLocator对象。 与每个RTPS StatefulWriter关联的RTPS ReaderProxy对象。 与每个RTPS StatefulReader关联的RTPS WriterProxy对象。 发现模块的组织方式如下： SPDP和SEDP依靠预定义的RTPS内置Writer和Reader端点进行交换发现信息。 8.5.2引入了这些RTPS内置端点。 在8.5.3中讨论了SPDP。 在8.5.4中讨论了SEDP RTPS内置发现端点DDS规范指定使用带有预定义主题和QoS的“内置” DDS DataReader和DataWriter进行发现。 有四个预定义的内置主题：“ DCPSParticipant”，“ DCPSSubscription”，“ DCPSPublication”和“ DCPSTopic”。 与这些主题相关联的数据类型也由DDS规范指定，并且主要包含实体QoS值。 对于每个内置主题，都有一个对应的DDS内置DataWriter和DDS内置DataReader。内置的DataWriter用于向网络其余部分通告本地DDS参与者和其包含的DDS实体（DataReaders，DataWriters和Topics）的存在和QoS。同样，内置的DataReader从远程参与者收集此信息，然后DDS实现将其用于标识匹配的远程实体。内置的DataReader充当常规DDS DataReader，并且用户也可以通过DDS API对其进行访问。 RTPS简单发现协议（SPDP和SEDP）采用的方法类似于内置实体概念。 RTPS将每个内置DDS DataWriter或DataReader映射到关联的内置RTPS端点。这些内置端点充当常规的Writer和Reader端点，并提供了使用行为模块中定义的常规RTPS协议在参与者之间交换所需发现信息的方法。 SPDP涉及参与者之间如何发现对方，它为“ DCPSParticipant”主题映射了DDS内置实体。 SEDP指定了如何交换有关本地主题，DataWriters和DataReader的发现信息，它为“ DCPSSubscription”，“ DCPSPublication”和“ DCPSTopic”主题映射了DDS内置实体。 SPDPPDP的目的是发现网络上其他参与者的存在及其属性。 参与者可以支持多个PDP，但是出于互操作性的目的，所有实现都必须至少支持简单参与者发现协议。 一般方法RTPS简单参与者发现协议（SPDP）使用一种简单方法来宣布和检测域中参与者的存在。 对于每个参与者（Participant），SPDP将创建两个RTPS内置端点：SPDPbuiltinParticipantWriter和SPDPbuiltinParticipantReader。 SPDPbuiltinParticipantWriter是RTPS尽力而为的StatelessWriter。 SPDPbuiltinParticipantWriter的HistoryCache包含一个类型为SPDPdiscoveredParticipantData的数据对象。该数据对象的值是从参与者的属性中设置的。如果属性更改，则数据对象为更换。 SPDPbuiltinParticipantWriter会定期将此数据对象发送到预先配置的定位器列表，以宣布参与者在网络上的存在。这是通过定期调用StatelessWriter :: unsent_changes_reset来实现的，它使StatelessWriter将其HistoryCache中存在的所有更改重新发送给所有定位器。SPDPbuiltinParticipantWriter发送SPDPdiscoveredParticipantData的周期速率默认为PSM指定的值。此时间段应小于在SPDPdiscoveredParticipantData中指定的leaseDuration（另请参见8.5.3.3.2）。 预先配置的定位器列表可以包括单播和多播定位器。端口号由每个PSM定义。这些定位器仅代表网络中可能的远程参与者，实际上不需要参与者。通过定期发送SPDPdiscoveredParticipantData，参与者可以以任何顺序加入网络。 SPDPbuiltinParticipantReader从远程参与者接收SPDPdiscoveredParticipantData公告。所包含的信息包括远程参与者支持哪些端点发现协议。然后使用正确的端点发现协议与远程参与者交换端点信息。 通过响应于从先前未知的参与者接收到此数据对象而发送附加的SPDPdiscoveredParticipantData，实现可以将任何启动延迟最小化，但是此行为是可选的。 实施方式还可以使用户选择是否使用来自新发现的参与者的新定位器自动扩展定位器的预配置列表。 这将启用非对称定位器列表。 最后两个功能是可选的，出于互操作性的目的不是必需的。 SEDP端点发现协议（EDP）定义了两个参与者之间必需的信息交换，以便发现彼此的Writer端点和Reader端点。 参与者可以支持多个EDP，但是出于互操作性的目的，所有实现都必须至少支持简单端点发现协议。 一般方法与SPDP相似，简单端点发现协议使用预定义的内置端点。使用预定义的内置端点意味着，一旦一个参与者知道另一个参与者的存在，它就可以假设存在由远程参与者提供的内置端点，并建立与本地匹配的内置端点的关联。 内置端点之间进行通信的协议与应用程序定义的端点所使用的协议相同。因此，通过读取内置的读取器端点，协议虚拟机可以发现属于任何远程参与者的DDS实体的存在和QoS。同样，通过编写内置的Writer端点，参与者可以将本地DDS实体的存在和QoS通知其他参与者。 因此，在SEDP中使用内置主题将整个发现协议的范围缩小到确定系统中存在哪些参与者以及与这些内置端点相对应的ReaderProxy和WriterProxy对象的属性值参加者。一旦知道了，其他一切都将由RTPS协议的应用到内置RTPS读取器和写入器之间的通信产生。","tags":[{"name":"DDS","slug":"DDS","permalink":"https://zijian.wang/tags/DDS/"},{"name":"研究方向","slug":"研究方向","permalink":"https://zijian.wang/tags/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/"},{"name":"协议阅读","slug":"协议阅读","permalink":"https://zijian.wang/tags/%E5%8D%8F%E8%AE%AE%E9%98%85%E8%AF%BB/"}]},{"title":"经典面试题——接雨水的四种解法","date":"2021-04-05T13:46:27.000Z","path":"2021/04/05/接雨水/","text":"接雨水这道题目是非常经典的面试题，师兄字节面试的时候似乎就碰到了，所以把它抽出来研究了一下，主要是学习参考Leetcode上的各种评论和题解，总结了四种方法，其中三种是按列计算，还有一种是按区域行计算。最后一种方法虽然复杂度上没有双指针法简单，但是如果给我们的数组是流式输入，无法从后往前进行遍历的话，就只有最后一种方法有用了。 42 接雨水题目描述给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例1： 输入： height = $[0,1,0,2,1,0,1,3,2,1,2,1]$ 输出： 6 解释： 上面是由数组 $[0,1,0,2,1,0,1,3,2,1,2,1] $表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例2： 输入： height = $[4,2,0,3,2,5]$ 输出： 9 提示： $n == height.length$ $0 &lt;= n &lt;= 3 \\times 10^4$ $0 &lt;= height[i] &lt;= 10^5$ 解法一：暴力法核心思路仔细思考每一个单位的雨水高度的特点，可以发现对于每个单位而言，雨水的高度就是该单位左右最高高度中的较小值和自己高度的差(注意要从自己本身找起)。所以用暴力法，找到每一个单位左右最高高度，然后用两者中较小的高度减去自己的高度，然后将所有高度的水的高度相加，就得到了能接的雨水的总量。 关键就在于发现单位处的雨水高度就是左右最高处较小值和自己高度的差。 代码123456789101112131415161718class Solution&#123;public: int trap(vector&lt;int&gt; &amp;height)&#123; int ans = 0; int n = height.size(); for(int i=1;i&lt;n-1;i++)&#123; int left_high=0 , right_high=0; for(int j=i;j&gt;=0;j--)&#123; left_high = max(left_high,height[j]); &#125; for(int j=i;j&lt;n;j++)&#123; right_high = max(right_high,height[j]); &#125; ans += min(left_high,right_high)-height[i] &#125; return ans; &#125; &#125;; 复杂度分析 时间复杂度： $O(n^2)$。数组中的每个元素都需要向左向右扫描。 空间复杂度：$O(1)$ 的额外空间 解法二：双指针核心思路在暴力法中，之所以称“暴力”是因为我们在遍历数组中的每个高度时，都要在左右找最高的格子。时间复杂度一下子就上来了。那么有没有一种方法可以让我们不用在遍历中再进行遍历找最高值呢？双指针法就是针对一次遍历进行设计的算法。 上一种解法我们还可以这样理解： 当我们从左往右进行遍历高度时，我们很容易得到到目前为止，我的左侧最高的高度，而如果此时我们知道了我们的右侧，无论哪个位置，出现了一个比我的左侧最高高度还高的高度，那显然我目前所在的位置如何填充就也知道了。 同理，那我们如果从右往左进行遍历时，也是知道右侧最高高度，而不知道左侧高度。一旦知道左侧高度，我们同样也就知道了右侧该如何填充。 那我们使用两个指针，从左右两端往中间进行扫描，是不是可以一次遍历解决问题呢？ 当然会存在一个问题，因为我们左右指针分别找的是指针当前所在位置的最高高度，当前位置的最高高度显然不一定是对方所需要的左/右侧最高高度。但注意的是，我们也没有必要一定找到最高高度，我们只需要知道另一侧存在比自己已知那一侧的最高高度还要高的高度就可以了。 所以我们的思路就是用两个指针分别从两端进行遍历，用两个变量分别记录左右侧最高的高度。我们需要保证每次移动的指针所在这一侧的最高高度必然是小于等于另一侧最高高度的，只有这样，我们才可以保证我们的指针在走动时，可以知道当前位置会不会积攒雨水。 代码123456789101112131415161718192021class Solution&#123;public: int trap(vector&lt;int&gt;&amp; height)&#123; int left=0,right=height.size()-1; int left_max=0,right_max=0; while(left&lt;right)&#123; left_max = max(left_max,height[left]); right_max = max(right_max,height[right]); if(left_max&lt;right_max)&#123; ans += left_max-height[left]; left++; &#125;else&#123; ans += right_max-height[right]; right--; &#125; &#125; return ans; &#125;&#125;; 复杂度分析 时间复杂度： $O(n)$。一次遍历解决问题 空间复杂度：$O(1)$ 的额外空间 解法三：动态规划核心思路在解法一中我们介绍了这道题的最直接的想法，也就是每个元素都要向两边进行扫描找最大值，所以就会有$O(N^2)$的时间复杂度。那么我们可以考虑使用额外的空间来存储最大值的话，就不需要遍历每个元素都要扫描了。而且，显然相对于数组部分元素的最大值，最大值是动态变化的，这是符和动态规划的思想的。 我们创建两个长度为n的数组$leftdp$和$rightdp$，对于$leftdpi$表示下标i及其左侧最大的高度，对于$rightdpi$表示下标i及其右侧最大的高度。 很容易看出来$leftdp[0]==rightdp[0]$,$leftdp[n-1]==rightdp[n-1]$。 然后其余数组元素计算遵循下列规则： 当$1&lt;=i&lt;=n-1$时，$leftdp[i]==max(leftdp[i-1],height[i])$ 当$0&lt;=i&lt;=n-2$时，$rightdp[i]==max(rightdp[i+1],height[i])$ 所以我们可以正向遍历数组得到$leftdp$的每个元素值，反向遍历数组得到数组$rightdp$的每个元素值。 得到两个动态规划数组后，能接的水的量就是$min(leftdp[i],rightdp[i])-height[i]$。然后一遍遍历就可以得到接水总量。 代码1234567891011121314151617181920212223242526272829class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); if (n == 0) &#123; return 0; &#125; vector&lt;int&gt; leftdp(n); vector&lt;int&gt; rightdp(n); leftdp[0] = height[0]; rightdp[n-1] = height[n-1]; for(int i=1;i&lt;n;i++)&#123; leftdp[i] = max(leftdp[i-1],height[i]); &#125; for(int i=n-2;i&gt;=0;i--)&#123; rightdp[i] = max(rightdp[i+1],height[i]); &#125; int ans = 0; for(int i=0;i&lt;n;i++)&#123; ans += min(leftdp[i],rightdp[i])-height[i]; &#125; return ans; &#125;&#125;; 复杂度分析 时间复杂度：$O(n)$，其中 n 是数组 $height$的长度。计算数组$leftdp$和$rightdp$的元素值各需要遍历数组$height$一次，计算能接的水的总量还需要遍历一次。 空间复杂度：$O(n)$，其中 n 是数组 $height$的长度。需要创建两个长度为 n 的数组$leftdp$和$rightdp$ 解法四：单调栈核心思路为什么这道题可以想到使用单调栈呢？我们知道单调栈是一种很特殊的数据结构，他要求栈中存放的数据是有序的，分为单调递增栈和单调递减栈。 单调栈的特性要求它一定要在每次入栈操作时对栈内元素进行一个调整，总的来说就是要保证最大/最小元素一定要在栈底的位置，然后向栈顶依次递减。我们以单调递增栈为例，当第一个元素要入栈是可以随便入栈，但是当第二个元素来入栈时，我们就要考虑把上一个元素进行出栈才可以让第二个元素入栈。而假如栈中元素为两个，此时来了一个元素，比栈顶大而比栈底小，比如三个元素为5 1 3，我们就需要把第二个元素出栈，才可以把第二个元素入栈。 形如[5 1 3]这样的构造的元素组，和我们在这个题中需要填充雨水的数组完全一致，所以我们就可以考虑利用单调栈的调整过程，计算会积攒雨水的位置以及积攒雨水的多少。 那么到底是怎么计算雨水的呢？前面我们介绍的三种方法都是按列进行计算，但是此方法中确是以区域行的计算模式进行计算。比如形如[2,1,0,1,3]的数组，我们是当第四个数字来的时候，将第三个数字填充了1格雨水，然后再第五个数字来的时候，才将第二、第三和第四格各自填充了一单位雨水也就是三单位雨水进行计算的。 也就是说我们在计算雨水时，不仅仅需要height的值，也需要有下标的值，因为我们需要$长\\times宽$才能计算出来区域行的雨水数量。那么我们的栈中可以考虑不存放height值，而是存放下标值，通过数组来得到height值。这样就可以看到长和宽的值。 具体单调栈的处理逻辑，如下所示： 遍历所有的柱子，并尝试入栈，入栈条件是当前遍历的元素小于栈顶元素的高度。如果当前遍历的元素等于栈顶元素，那么我们就需要更新栈顶元素，因为相同高度的柱子，需要下标最大的那个来计算宽度。 如果当前遍历的元素大于栈顶元素，类似于我们上面所说的5 1 3的情况，我们就要取栈顶元素，将栈顶元素弹出，作为要求水量的宽度以及长度的决定因素。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); if(n&lt;=2) return 0; stack&lt;int&gt; stk; stk.push(0); for(int i=1;i&lt;n;i++)&#123; if(height[i]&lt;height[stk.top()]) stk.push(i); if(height[i]==height[stk.top()])&#123; stk.pop(); stk.push(i); &#125;else&#123; while(height[i]&gt;height[stk.top()] &amp;&amp; !stk.empty())&#123; int mid = stk.top(); stk.pop(); if(!stk.empty())&#123; int h = min(height[stk.top()],height[i])-height[mid]; int w = i-stk.top()-1; sum += h*w; &#125; &#125; stk.push(i); &#125; &#125; return sum; &#125;&#125;;// 整理后class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int ans = 0; stack&lt;int&gt; monstk; for(int i=0;i&lt;height.size();i++)&#123; while(!monstk.empty() &amp;&amp; height[i]&gt;height[monstk.top()] )&#123; int top = monstk.top(); monstk.pop(); if(monstk.empty()) break; int left = monstk.top(); int width = i-left-1; int heigh = min(height[left],height[i])-height[top]; ans += width * heigh; &#125; monstk.push(i); &#125; return ans; &#125;&#125;; 复杂度分析时间复杂度：$O(n)$，其中 n 是数组 $height$ 的长度。从 0 到 n-1 的每个下标最多只会入栈和出栈各一次。 空间复杂度：$O(n)$，其中 n 是数组 $height$ 的长度。空间复杂度主要取决于栈空间，栈的大小不会超过 n。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}]},{"title":"C++视频课笔记（一）","date":"2021-04-05T04:12:22.000Z","path":"2021/04/05/C++视频课/","text":"在百度网盘上找到的c++视频资源，感觉讲的非常棒，做一下笔记 123456789101112131415template&lt;typename T&gt; class complex // class head&#123; // class bodypublic: complex (T r=0, T i=0) // : re(r), im(i) // initialization list 初值列 &#123; &#125; // 上述三行为构造函数 //complex () :re(0),im(0) &#123;&#125; // 第二个构造函数，但是这个构造函数和上面的构造函数冲突了 complex&amp; operator += (const complex&amp;); // 声明 T real () const &#123; return re; &#125; // 内部定义的inline函数 T imag () const &#123; return im; &#125; // 内部定义的inline函数 private: T re, im; friend complex&amp; __doapl (complex*,const complex&amp;)&#125; inline(内联）函数 直接在类内（class body内）进行定义的函数，一般来说执行效率更高，但是具体能否编译为inline函数，由编译器决定。（简单的区分是如果函数过于复杂，编译器也无法将其编译为inline） 12345inline doubleimag(const complex&amp; x)&#123; return x.imag();&#125; inline关键字可以建议编译器将类外的函数编译成inline函数。 access level（访问级别） public、private限制了是否可以从外部直接访问，一般来说数据都要是private，通过public中的函数来进行获取。private中定义的函数是外部无法访问的 123456constructor （ctor 构造函数）&#123; complex c1(2,1); complex c2; complex* p = new complex(4); &#125; 构造函数名称一定要和类的名称相同构造函数可以有参数构造函数的参数可以拥有默认值构造函数没有返回值类型构造函数可以有多个（overloading 重载）ps. 函数重载在编译器编译后其实名称也是不同的,所以说从编译器层面来看，确实没有完全同名的函数。构造函数在特殊情况下也可以放在private区中，比如设计模式中的单例模式，会把构造函数放在private中。 12345678910111213141516171819// Singletonclass A&#123;public: static A&amp; getInstance(); setup() &#123;```&#125;private: A(); A(const A&amp; rhs); ...&#125;;A&amp; A::getInstance()&#123; static A a; return a;&#125;// 调用时A::getInstance().setup(); ==注意构造函数专业的写法不会在大括号中进行执行赋值操作，而是使用初值列/初始列进行初始化设值。这是构造函数独有的初始化方法。== 1234567// 不专业的写法complex(double r=0,double i=0)&#123; re = r; im=i; &#125;// 专业的写法complex(double r=0,double i=0):re(r),im(i)&#123;&#125; const 常量成员函数 类中的函数可以分为会改变数据内容的和不会改变数据内容的，对于不会改变数据内容的函数，可以加上const进行限制。 ==参数传递时，拷贝值传递造成堆栈浪费，所以应该尽量避免使用值传递，而是使用引用传递，引用传递速度快也美观。但是为了防止原数据被修改，应当对不想要被更改的变量加const关键字进行限制。== ==函数返回时，也要尽量返回引用。== 123456ostream&amp;operator &lt;&lt; (ostream&amp; os,const complex&amp; x)&#123; return os &lt;&lt; &#x27;(&#x27; &lt;&lt; real (x) &lt;&lt; &#x27;,&#x27; &lt;&lt; imag (x) &lt;&lt; &#x27;)&#x27;;&#125; friend（友元） 1234567inline complex&amp;__doapl (complex* ths, const complex&amp; r)&#123; ths-&gt;re += r.re; ths-&gt;im += r.im; return *ths;&#125; ==相同class的各个objects互为friends（友元）== 12345678910111213141516171819class complex&#123;public: complex (double r=0, double i=0) : re(r), im(i) &#123; &#125; int func(const complex&amp; param) &#123; return param.re + param.im; &#125;private: double re, im;&#125;;// 例如：&#123; complex c1(2,1); complex c2; c2.func(c1);&#125; class body 外的各种定义（definitions） 区分清楚哪些情况引用传递，哪些情况返回引用 ==被改动的参数不能使用引用传递，不会被改动的参数可以使用引用传递。== ==函数运算结果需要创建空间存放，此时申请的空间时local的，函数结束会释放，所以不能使用引用返回。== ==函数运算结果可以直接放在已有的空间，就看可以返回引用== 12345678910111213inline complex&amp;__doapl (complex* ths, const complex&amp; r)&#123; ths-&gt;re += r.re; ths-&gt;im += r.im; return *ths;&#125;inline complex&amp;complex::operator += (const complex&amp; r)&#123; return __doapl(this,r);&#125;","tags":[{"name":"C++","slug":"C","permalink":"https://zijian.wang/tags/C/"}]},{"title":"经典DP问题——最长公共子序列","date":"2021-04-03T04:12:22.000Z","path":"2021/04/03/最长公共子序列/","text":"典中典的动态规划 1143 最长公共子序列题目描述给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回 0 。 一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。 两个字符串的公共子序列是这两个字符串所共同拥有的子序列。 示例 1： 输入： text1 = “abcde”, text2 = “ace” 输出： 3 解释： 最长公共子序列是 “ace” ，它的长度为 3 。 示例 2： 输入： text1 = “abc”, text2 = “abc” 输出： 3 解释： 最长公共子序列是 “abc” ，它的长度为 3 。 示例 3： 输入： text1 = “abc”, text2 = “def” 输出： 0 解释： 两个字符串没有公共子序列，返回 0 。 提示： $1 &lt;= text1.length, text2.length &lt;= 1000$ text1 和 text2 仅由小写英文字符组成。 解法——动态规划拿到这道题如果没有意识到动态规划，就会感觉似乎是一个NP问题，但事实上这是一道十分经典的二维动态规划问题。动态规划问题的特征就是我们可以将问题进行拆分，然后可以通过定义问题状态和状态之间的关系，使得问题可以以递推的方式来解决。 两个字符串找最大公共子串，其实就可以先转换为一个字符串和另一个不断增长的字符串找公共子串，再进一步转换为两个不断增长的字符串找公共子串。 我们假设两个字符串$test1，test2$长度为m、n，我们创建一个$m+1$行$n+1$列的二维数组$dp$，而$dp[i][j]$表示的就是第一个字符串从第0个字符到第$i-1$个字符所组成的字符串和第二个字符串从第0个字符到第$j-1$个字符所组成的字符串的最大公共子串的长度。换句话说就是两个字符串长度为$i，j$的前缀字符串的最大公共子串。 然后对于$dp$数组的边界情况：显然无论$i==0还是j==0$,他们的最大公共子串都为0。因此$dp$数组的第0行和第0列的所有值必然都为0。也即当$i==0||j==0$时，$dp[i][j]=0$. 当$i&gt;0||j&gt;0$时，对$dp$数组进行计算： 如果$test1[i-1]=test2[j-1]$,那么这两个字符就是公共字符，这说明我们可以把前缀字符串中的最大公共字符串长度+1了，所以$dp[i][j]=dp[i-1][j-1]+1$。为什么这里时$i-1$和$j-1$呢，因为这里的$i$和$j$并不是代表字符串数组下标，而是代表$dp$数组的下标，$dp$数组为了考虑字符串长度为0的情况是有单独一行一列下标，所以$dp$数组的下标要比真实的字符串的下标大1 如果$test1[i-1]!=test2[j-1]$，那么这两个字符串就不是公共字符，那么显然对于$dp[i][j]$而言，它的取址就应该是前一个状态的取址，所以就要看$dp[i-1]$[j]和$dp[i][j-1]$的取值，较大的就是$dp[i][j]$的取值 综上所述，我们可以得到状态转移方程： $$dp[i][j]=\\left\\&#123;\\begin&#123;aligned&#125;dp[i-1][j-1]+1,text1[i]==text2[j]\\\\max(dp[i-1][j],dp[i][j-1]),text1[i]!=text2[j]\\end&#123;aligned&#125;\\right.$$ 代码1234567891011121314151617181920class Solution &#123;public: int longestCommonSubsequence(string text1, string text2) &#123; int m = text1.size(), n = text2.size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1)); for(int i=1;i&lt;=m;i++)&#123; char c1 = text1[i-1]; for(int j=1;j&lt;=n;j++)&#123; char c2 = text2[j-1]; if(c1==c2)&#123; dp[i][j] = dp[i-1][j-1]+1; &#125;else&#123; dp[i][j] = max(dp[i-1][j],dp[i][j-1]); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 复杂度分析 时间复杂度：$O(m\\times n)$，其中m和n分别是字符串$text1$,$text2$ 的长。我们根据m和n遍历了长宽为$m+1$ $n+1$的$dp$数组 空间复杂度：$O(m\\times n)$，其中m和n分别是字符串$text1$,$text2$ 的长。我们根据m和n建立了长宽为$m+1$ $n+1$的$dp$数组","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}]},{"title":"经典NP问题——子集问题","date":"2021-04-01T13:53:27.000Z","path":"2021/04/01/子集问题/","text":"枚举子集问题毫无疑问是一个NP问题。对于这个问题一般两种解法，一种是利用位运算巧妙地进行枚举，另一种是利用递归进行枚举 78 子集题目描述：给你一个整数数组 nums ，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。你可以按任意顺序返回解集。 示例 1： 输入：$nums = [1,2,3]$输出：$[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]$ 示例 2： 输入：$nums = [0]$输出：$[[],[0]]$ 提示： $1 &lt;= nums.length &lt;= 10$$-10 &lt;= nums[i] &lt;= 10$nums 中的所有元素互不相同 解法一 :位运算核心思路结合位运算，用一个n位的二进制数来表示一个子集中各元素的存在与否，每一位代表一个元素是否包含在子集中，正好也有$2^n$个不同大小的二进制数可以代表$2^n$个子集。 比如整数数组为$[1,2,3,4,5]$，我们用5位的二进制数代表1个子集，具体某一位为0还是1代表某个子集包含还是不包含这个元素。10101代表了子集[1,3,5],00000代表了子集$[]$，11111代表了子集$[1,2,3,4,5]$。 代码1234567891011121314151617181920212223242526class Solution&#123;public: vector&lt;int&gt; t; //t容器，作用是存放每一个临时数组，放到ans里 vector&lt;vector&lt;int&gt;&gt; ans; //ans容器，结果 vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; //取到给的nums的大小 int n = nums.size(); // 子集的数量为2^n个。这个循环就是为了生成这些子集 // mask可以理解为二进制数，一个mask就是一个子集，1、0代表了子集中哪个数存在不存在 for (int mask = 0; mask &lt; (1 &lt;&lt; n); ++mask) &#123; // 清空临时容器 t.clear(); // 循环遍历nums for (int i = 0; i &lt; n; ++i) &#123; // mask是子集，1&lt;&lt;i可以代表某个数在的情况 // 通过位与运算，如果mask和某个数与的结果为0 则说明这个数不在子集中，就不用加到临时容器里，否则就加进来。 if (mask &amp; (1 &lt;&lt; i)) &#123; t.push_back(nums[i]); &#125; &#125; ans.push_back(t); &#125; return ans; &#125;&#125; 复杂度时间复杂度：$O(n\\times 2^n)$。一共 $2^n$个状态，每种状态需要$O(n)$的时间来构造子集。 空间复杂度：$O(n)$。即构造子集使用的临时数组$t$的空间代价。 解法二：递归核心思路枚举子集其实最核心的思想就是考虑子集对每个元素的取舍问题。当前元素的取舍都会产生两类不同的子集。所以另一个解法就是利用递归，对每个元素进行取舍，递归的进行接收某个元素或放弃某个元素。 代码1234567891011121314151617181920class Solution&#123;public: vector&lt;int&gt; t; vector&lt;vector&lt;int&gt;&gt; ans; dfs(int pos,vector&lt;int&gt; &amp;nums)&#123; if(pos==nums.size())&#123; ans.push_back(t); return ; &#125; t.push_back(nums[pos]); dfs(pos+1,nums); t.pop_back(); dfs(pos+1,nums); &#125; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums)&#123; dfs(0,nums); return ans; &#125;&#125; 复杂度分析时间复杂度：$O(n\\times 2^n)$。一共 $2^n$个状态，每种状态需要$O(n)$的时间来构造子集。 空间复杂度：$O(n)$。即构造子集使用的临时数组$t$的空间代价是$O(n)$,递归时栈空间的代价为$O(n)$。 90 子集II题目描述：给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。子集可以按任意顺序返回解集。 示例 1： 输入：$nums = [1,2,2]$输出：$[[],[1],[1,2],[1,2,2],[2],[2,2]]$ 示例 2： 输入：$nums = [0]$输出：$[[],[0]]$ 提示： $1 &lt;= nums.length &lt;= 10$$-10 &lt;= nums[i] &lt;= 10$ 解法一 :位运算核心思路子集II和子集这两道题相比而言，就是多出了重复元素这种情况。显然对于示例数组$[1,2,2]$而言第一个元素与第二个元素组成的子集$[1,2]$和第一个元素与第三个元素组成的子集$[1,2]$其实并没有区别，这也就是如果我们直接用子集I来做这道题的话显然就会出错误。 显然对于上述出现的这种情况，之所以出现重复子集，是因为第三种元素和第二种元素的重复，我们舍弃了第二种元素，却接收了第三种元素，结果上看我们没有舍弃第二种元素。那解决办法就显而易见：首先我们将数组变得有序，然后当我们在对每个元素进行取舍的时候，看看前一个元素是否和它相同且是否舍去——如果前一个元素已经决定舍弃这个元素，那么我们显然也应当舍去这个元素。 代码123456789101112131415161718192021222324252627class Solution&#123;public: vector&lt;int&gt; t; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); sort(nums.begin(),nums.end()); for(int mask=0;mask&lt;(1&lt;&lt;n);mask++)&#123; t.clear(); bool flag=true; for(int i=0;i&lt;n;i++)&#123; if(mask &amp; (1&lt;&lt;i))&#123; // i!=0 因为第0位没有前面的位；nums[i]==nums[i-1] 相同元素； mask&gt;&gt;(i-1) mask的第i-1位 也就是前一位，&amp;1==0 是否舍弃 if(i!=0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; mask&gt;&gt;(i-1)&amp;1==0 )&#123; flag=false; //如果舍弃了，我们也要舍弃这个选择。 break; &#125; t.push_bcak(nums[i]); &#125; &#125; if(flag) // ans.push_back(t); &#125; return ans; &#125;&#125;; 复杂度分析时间复杂度：$O(n \\times 2^n)$，其中 n 是数组$nums $的长度。排序的时间复杂度为 $O(nlogn)$。一共 $2^n$个状态，每种状态需要$O(n)$\\ 的时间来构造子集，一共需要$O(n \\times 2^n)$ 的时间来构造子集。由于在渐进意义上$ O(n \\log n)$ 小于 $O(n \\times 2^n)$，故总的时间复杂度为 $O(n \\times 2^n)$ 空间复杂度：O(n)。即构造子集使用的临时数组 t 的空间代价。 解法二： 递归核心思路和上述差不多，在递归的做法中就需要多传递一个参数来让当前函数判断是否和前一个函数相同。 代码12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; t; vector&lt;vector&lt;int&gt;&gt; ans; void dfs(bool choosePre, int cur, vector&lt;int&gt; &amp;nums) &#123; if (cur == nums.size()) &#123; ans.push_back(t); return; &#125; dfs(false, cur + 1, nums); if (!choosePre &amp;&amp; cur &gt; 0 &amp;&amp; nums[cur - 1] == nums[cur]) &#123; return; &#125; t.push_back(nums[cur]); dfs(true, cur + 1, nums); t.pop_back(); &#125; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt; &amp;nums) &#123; sort(nums.begin(), nums.end()); dfs(false, 0, nums); return ans; &#125;&#125;; 复杂度分析时间复杂度：$O(n \\times 2^n)$，其中 n 是数组$nums $的长度。排序的时间复杂度为 $O(nlogn)$。一共 $2^n$个状态，每种状态需要$O(n)$\\ 的时间来构造子集，一共需要$O(n \\times 2^n)$ 的时间来构造子集。由于在渐进意义上$ O(n \\log n)$ 小于 $O(n \\times 2^n)$，故总的时间复杂度为 $O(n \\times 2^n)$ 空间复杂度：O(n)。即构造子集使用的临时数组$t$的空间代价是$O(n)$,递归时栈空间的代价为$O(n)$。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zijian.wang/tags/Leetcode/"},{"name":"算法题","slug":"算法题","permalink":"https://zijian.wang/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}]},{"title":"DDS-XRCE协议阅读翻译","date":"2021-04-01T06:18:00.000Z","path":"2021/04/01/XRCE-DDS/","text":"最近在研究Micro-ROS的底层通讯机制的时候，了解到使用的是DDS-XRCE协议，所以转而来研究阅读这个协议的相关内容。这部分国内还没有多少人重视，鲜有人对相关部分进行翻译，所以准备将这个协议进行一下翻译理解。 DDS-XRCE1 scopeXRCE协议是一个用于资源受限低能耗设备（作为客户端）和一个Agent（作为服务端）之间的协议。XRCE协议允许设备通过一个中间服务（XRCE Agent）来和一个DDS网络进行通信并且在一个DDS域中发布、订阅话题。（XRCE协议是一个资源受限设备（client）和一个XRCE Agent（server）之间的客户端-服务器协议。协议允许周期性睡眠唤醒的资源受限设备在有限带宽网络上访问DDS全局数据空间） 4 术语和定义 DDS数据分发服务，独立于实现语言 DDS Domain全局数据空间，是主题和类型定义的逻辑范围，每一个域由唯一的域id标识，域之间相互独立，两个DDS应用只有加入相同域才可以通信 DDS DomainParticipant应用程序用于加入DDS域的DDS实体.采用工厂模式生成实体，一个实体可以加入一个域。 DDS Global Data Space由通过DDS进行通信的双方以及他们的可见数据组成 GUID全局唯一标识 5 符号解释 DDS数据分发服务 IDL接口定义语言 RTPS实时发布订阅 XRCE极端受限资源环境 7 XRCE Object Model7.1 General如上文所言，DDS-XRCE协议是一种用于XRCE Client 和 XRCE Agent之间的有线协议。XRCE Agent是一个DDS全局数据空间中的DDS参与者。DDS-XRCE协议允许客户端通过XRCE Agent作为一个代理从而可以在DDS全局数据空间中产生和消费数据。 为了对XRCE Client和XRCE Agent之间的交互关系进行建模，规范定义了XRCE的UML模型，也就是DDS-XRCE Object Model，来定义agent需要实现的对象、接口和操作，同时还定义了Agent和DDS规范中的标准DDS Object Model的操作的关联。 由于目标环境是资源受限设备，DDS-XRCE Object Model并不完全等同于Standard DDS Object Model。它更关注其使能DDS-XRCE客户端以一种有意义的方式参与DDS数据空间的需求。除了标准DDS对象模型中的公开对象外，DDS-XRCE对象模型还定义了管理断开连接的客户端以及启用访问控制和访问权限所需的新对象。 为了在资源受限设备上运行，XRCE-DDS Object Model主要是在Standard DDS Object Model上做减法，但是它也增加了一些支持远程客户端的特性，如访问控制模型（access control model）和应用程序管理模型（application management model） 总之尽管更简单，DDS-XRCE Object Model仍为客户端提供了对DDS全局数据空间完整的访问。任何DDS上的DDS Topic都可以使用任何QoS策略被发布或者订阅。 7.2 XRCE ClientDDS-XRCE客户端（XRCE客户端）向DDS-XRCE对象模型和façade object公开。 出于以下三种原因，DDS Objectg Model和它的操作没有直接运用在本协议 DDS Object Model的设计初衷是和本地编程API一起使用，所以包含了很多具有强类型参数的对象和方法以及通过应用程序向中间件注册的侦听器对象的直接回调接口。这种是不适用于资源受限的低功耗客户端，这些客户端需要的是一个没有回调简单接口，并且希望使用文本方式编码的参数 ==由于可能会使用低功耗模式和深度睡眠来节省电池或失去无线电连接，因此XRCE客户端连接先天性间断的特性。 DDS-XRCE DDS Object Model必须通过引入“session”来克服间歇性连接，“会话”可以存在于设备重复的睡眠-唤醒周期中。== xrce客户端可以在任何地方访问dds服务 所以一个来证明验证每个客户端的应用/主体的访问控制模块是很有必要的。这个模型控制主体是否可以访问DDS全局数据空间以及每个主体可以执行哪些操作（可以往哪个topic进行发布订阅） XRCE-DDS为4种不同需求的客户端提供支持。 设备 功能 简单设备 简单设备可能不需要与XRCE Agent执行任何发现交互，除了（a）由Agent检测到它们的存在，（b）在DDS数据空间中建立，以及（c）能够使用DDS QoS策略发布已知的DDS主题的数据。这样的客户机不需要DDS的任何QoS配置和动态实体创建功能。 更有能力的设备 更有能力的设备可能需要发布和订阅已知的主题；然而，XRCE Client可能不希望数据在任意时间由XRCE Agent推送，例如由于网络限制。因此，将数据从作者“推”给读者的DDS模型可能无法很好地工作。本规范通过允许设备从Agent激活/停用“数据推送”来解决此限制 进一步的客户端 高级Client可以选择利用DDS概念并创建自己的XRCEAgent资源，这些资源映射到DDS对象。这些Client还可能希望控制DDS对象的Qos。此规范通过公开一组动态创建/更新/删除代理对象的操作来启用这些类型的Client。Agent/Client的这种处理方式与前两种情况形成对比，在前两种情况下，所有资源都是预先知道的，并且在Agent上预先配置好的 复杂设备 最后，复杂Client可能需要了解高级概念，例如序列号（或样本id）、时间戳和DDS源。 7.3 XRCE AgentDDS-XRCE Agent的目的就是建立并维护XRCE Client在DDS数据空间的存在。本规范描述了在对象模型上的一系列操作 一个重要的性质就是简化了和XRCE Agent的互动。Agent表示了一个描述resources的对象模型。在一个高的层次，资源是可以用名称访问的对象，并且具有属性和行为。资源可以用都知道的名字提前定义，或者被XRCE Client动态创建。这些XRCE Agent中的资源比如XRCE Type、XRCE DataWriter、XRCE DataReader。任何被允许与XRCE Agent通信并具有所需访问权限的XRCE Client都可以按名称引用这些资源进行使用，而不用自己再创建这样一个资源。 DDS-XRCE Object Model的一个重要特性就是Client能够查询Model的能力，而不是像Standard DDS Object Model中的典型行为，后者可以实时更新、推送修改。那样的模型可能不适用于设备经常性断开的目标环境。==该协议使Client能够负责何时数据接收，并且请求XRCE Agent来返回符和一系列约束的数据。如此，一个XRCE Client就不会在断开期间被一个XRCE Agent唤醒，相反，Client会在唤醒后查询XRCE Agent== XRCE Agent不必暴露任何编程API，它使用DDS-XRCE协议和XRCE Client进行标准交互，同时使用DDS-RTPS协议和其他DDS域进行交互。 7.4 Model Overview从一个比较高的层面来看，DDS-XRCE Object Model包括五个类：Root单例、ProxyClient、Application、AccessController和DomainParticipant RootRoot单例是服务的入口点。它用作由XRCE Agent管理的所有对象的工厂 ProxyClientProxyClient类对使用XRCE协议与XRCE Agent进行交互的XRCE Client应用程序进行建模。 每个Application对象都与单个XRCE ProxyClient关联，并从分配给XRCE Client的访问权限中获取其访问权限。 ApplicationApplication类对与XRCE客户端连接，并管理在一个或多个DDS域上发布和订阅数据所需的DDS对象进行管理的软件应用程序进行建模。 XRCE应用程序可以与零个或多个DomainParticipant对象相关联 AccessControllerAccessController负责做出有关允许特定XRCE ProxyClient执行的资源和操作的决策。 它包含将客户端与特权相关联的规则，这些规则确定代表客户端执行的应用程序可以加入哪个DDS域，该应用程序可以读取和写入的DDS主题，等等。 DomainParticipantDDS-XRCE DomainParticipant是DDS DomainParticipant的代理，对与DDS域的关联以及应用程序在该域上发布和订阅主题的能力进行建模。 7.5 XRCE DDS Proxy Objects几个DDS-XRCE对象充当相应DDS对象的代理。委派实际的DDS行为和DDS-RTPS协议实现给DDS对象的代理，从而允许Client的应用程序以一级用户的身份参与DDS网络。 7.6 XRCE Object Identification代表特定XRCE客户端的XRCE代理管理的每个XRCE对象都通过ObjectId进行标识，也就是说，ObjectId和ClientKey的范围应该是统一的，在代理中。特定对象的ObjectId值应在XRCE代理上配置或者由XRCE客户端在创建代理时确定。 两个ObjectId被保留了，分别是无效的对象（OBJECTID_INVALID），值为{0x00,0x00}，以及XRCE ProxyClient对象（OBJECTID_CLIENT），值为{0xFF,0xFF}。 对象也可以被字符串resourceName所标识，这个名称的格式由资源决定，并且提供了一种使用配置文件或其他在代理上配置资源的方式。 7.7 对XRCE Object上的操作进行建模所用到的数据类型XRCE object上的操作接收参数，这些参数的格式由一套IDL数据类型进行描述。这些IDL描述不仅在XRCE Object操作的描述上被使用，也同样用来定义clilent和agent之间信息交换的有线表示。 数据类型的IDL定义在Annex A IDL Types中明确。当把这些类型序列化为二进制表示时，编码应该遵循在《DDS-XTYPES》中的规则 7.7.1 Data and Samples当XRCE Agent发送数据给XRCE Client时，他会使用1-5种可能的格式，这些格式根据是否数据仅仅自己单独发送还是伴随着元数据如时间戳、序列号等等发送而有所不同。 当然这些可以合并为一个形如联合（union）类型，但这样做会给序列化带来更大的开销，在带宽受限的环境下，这种开销是不希望有的。 5种可能的描述为：SampleData, Sample, SampleDataSeq, SampleSeq和SamplePackedData 。它们分别是变量FORMAT_DATA,FORMAT_DATA_SEQ, FORMAT_SAMPLE, FORMAT_SAMPLE_SEQ和FORMAT_PACKED的格式。 所有这些表示形式都使用[DDS-XTYPES]中定义的XCDR表示形式对数据进行序列化。 例如，SampleData的定义由IDL给出： 1234@extensibility(FINAL) struct SampleData &#123; XCDRSerializedBuffer serialized_data;&#125;; 在这个结构中，XCDRSerializedBuffer结构表示了通过序列化使用DDS-XTYPES条款7.4中定义的XCDR版本2规则发送的特定于应用程序的数据类型而得到的字节。 其他的格式可能包含有其他信息，但是他们都依赖于SampleData来保存序列化特定于应用程序的数据。比如数据格式FORMAT_SAMPLE使用了Sample的定义如下所示： 123456789101112131415161718@bit_bound(8)bitmask SampleInfoFlags &#123; @position(0) INSTANCE_STATE_UNREGISTERED, // @position(1) INSTANCE_STATE_DISPOSED, // @position(2) VIEW_STATE_NEW, // @position(3) SAMPLE_STATE_READ, //&#125;; @extensibility(FINAL)struct SampleInfo &#123; SampleInfoFlags state; //结合了SampleState, InstanceState, ViewState unsigned long sequence_number; unsigned long session_time_offset; // 上限到53天的毫秒计时&#125;;@extensibility(FINAL)struct Sample &#123; SampleInfo info; SampleData data;&#125;; 包含示例信息的最紧凑的DataFormat是FORMAT_PACKED。 此格式使用以下定义的IDL类型PackedSamples： 1234567891011121314151617typedef unsigned short DeciSecond; // 1/10 秒@extensibility(FINAL)struct SampleInfoDelta &#123; SampleInfoFlags state; // 结合了 SampleState, InstanceState, ViewState octet seq_number_delta; DeciSecond timestamp_delta; // 1/10秒为单位&#125;;@extensibility(FINAL)struct SampleDelta &#123; SampleInfoDelta info_delta; SampleData data;&#125;;@extensibility(FINAL)struct PackedSamples &#123; SampleInfo info_base; sequence&lt;SampleDelta&gt; sample_delta_seq;&#125;; 7.7.2 DataRepresentationDataRepresentation类型用于保存data samples的值以及附加sample信息，例如序列号或时间戳。 XRCE ProxyClient的write操作使用它。 DataRepresentation定义为由DataFormat区分的联合。 根据区分符，它选择第7.7.1节中定义的格式之一。 下表1中介绍了DataFormat的可能值和所得表示形式 DataFormat 选择的DataRepresentatoin FORMAT_DATA 包含单个sample的信息，没有附加sample信息 FORMAT_DATA_SEQ 包含一系列data sample。 每个data sample仅包含data，而没有附加sample信息 FORMAT_SAMPLE 包含单个sample的信息，也包含附加sample的信息（SampleInfo）。SampleInfo包含相应DDS Sample的DDS InstanceState，SampleState和ViewState。 它还包含样本序列号和时间戳。 时间戳表示为相对于创建会话时建立的会话时间戳的偏移量。 会话时间戳对应于CLIENT_Representation中的client_timestamp属性； FORMAT_SAMPLE_SEQ 包含一系列的samples，每个data sample包含了data和附加的sample信息 FORMAT_PACKED 包含一系列样本，每个样本同时包含数据和其他样本信息，但使用的样本比SampleSeq更为紧凑。此表示仅限于序列号（相距不超过256个）和时间戳（100分钟）接近的样本。 它还使用较低分辨率（1/10秒）的时间戳。PackedSamples类型包含一个公共的SampleInfo（info_base）和一个SampleDelta序列。 每个SampleDelta包含一个SampleData以及一个关联的SampleInfoDelta（info_delta）每个样本的SampleInfo应通过将公共info_base与对应于该sample的info_delta相结合来计算。 所得的SampleInfo（resulting_info）定义为：$resulting_info.state := info_delta.stateresulting\\_info.sequence\\_number := info\\_base.sequence\\_number + info\\_delta.seq\\_number\\_deltaresulting_info.session_time_offset := info_base.session_time_offset + info_delta.timestamp_delta$ DataRepresentation类型被定义为： 12345678910111213@extensibility(FINAL)union DataRepresentation switch(DataFormat) &#123; case FORMAT_DATA: SampleData data; case FORMAT_SAMPLE: Sample sample; case FORMAT_DATA_SEQ: SampleDataSeq data_seq; case FORMAT_SAMPLE_SEQ: SampleSeq sample_seq; case FORMAT_PACKED_SAMPLES: PackedSamples packed_samples;&#125;; @@@ 7.7.4 ObjectIdXRCE ObjectId用于保存XRCE对象的唯一标识。 每个ObjectId的作用域都是XRCE客户端和代理对。 因此，由代理管理的ObjectId值仅对于每个XRCE客户端都是唯一的。 XRCE客户端通常连接到单个XRCE代理。 在这种情况下，XRCE客户端可以将ObjectId视为全局唯一。 ObjectId在A IDL类型中定义为： 1typedef octet ObjectId [2]; 7.7.5 ObjectKindXRCE ObjectKind用于枚举和标识XRCE Object的类型。 XRCE对象分为14种。 可能的种类在A IDL类型中定义为： 1234567891011121314typedef octet ObjectKind;const ObjectKind OBJK_INVALID = 0x00;const ObjectKind OBJK_PARTICIPANT = 0x01;const ObjectKind OBJK_TOPIC = 0x02;const ObjectKind OBJK_PUBLISHER = 0x03;const ObjectKind OBJK_SUBSCRIBER = 0x04;const ObjectKind OBJK_DATAWRITER = 0x05;const ObjectKind OBJK_DATAREADER = 0x06;const ObjectKind OBJK_TYPE = 0x0A;const ObjectKind OBJK_QOSPROFILE = 0x0B;const ObjectKind OBJK_APPLICATION = 0x0C;const ObjectKind OBJK_AGENT = 0x0D;const ObjectKind OBJK_CLIENT = 0x0E; 7.7.6 ObjectIdPrefixObjectIdPrefix用于保存特定ObjectKind的XRCE对象的唯一标识。 对象的ObjectId由来自ObjectIdPrefix的12位和来自ObjectKind的4位组成。 ObjectIdPrefix在A IDL Types中定义为: 1typedef octet ObjectIdPrefix [2]; 假设XRCE对象具有objectid_prefix，object_kind和object_id，则满足下列关系： object\\_id[0] = objectid\\_prefix[0] object\\_id[1] = (objectid\\_prefix[1] \\& 0xF0) + object\\_kind7.7.7 ResultStausResultStatus用于保存XRCE对象操作的返回值。它包括了包括了表示操作（operations）成功或者失败、以及失败原因的StatusValue。还包括了一个针对不同操作特殊定制的状态，用于返回供应商和一些特殊的定制消息。 StatusValue和ResultStatus在附录A中定义为： 1234567891011121314151617@bit_bound(8)enum StatusValue &#123; @value(0x00) STATUS_OK, @value(0x01) STATUS_OK_MATCHED, @value(0x80) STATUS_ERR_DDS_ERROR, @value(0x81) STATUS_ERR_MISMATCH, @value(0x82) STATUS_ERR_ALREADY_EXISTS, @value(0x83) STATUS_ERR_DENIED, @value(0x84) STATUS_ERR_UNKNOWN_REFERENCE, @value(0x85) STATUS_ERR_INVALID_DATA, @value(0x86) STATUS_ERR_INCOMPATIBLE, @value(0x87) STATUS_ERR_RESOURCES&#125;;struct ResultStatus &#123; StatusValue status; octet implementation_status;&#125;; 特殊定制的StatusValue解释如下： StatusValue 解释 STATUS_OK 表示操作的执行成功了 STATUS_OK_MATCHED 表示针对一个resource的create或者update操作执行成功了。该resource已经存在于Agent上，并且该resource的状态已经和该操作请求的resource状态匹配。因此没有对资源进行任何实际上的修改。 STATUS_ERR_DDS_ERROR 表示操作的执行失败了，是由与该操作相关的DDS资源创建或操作时的错误引起的 STATUS_ERR_MISMATCH 表示针对一个resource的create或者update操作执行成功了。该resource已经存在于Agent上，但是该resource的状态和该操作请求的resource状态不匹配。而且无法修改resource的状态。 STATUS_ERR_ALPEADY_EXISTS 表示操作的执行失败了，因为这个resource客观上已经存在了 STATUS_ERR_DENIED 表示操作的执行失败了，因为没有权限 STATUS_ERR_UNKNOWN_REFERENCE 表示操作的执行失败了，因为引用的resource并不为Agent所知。 STATUS_ERR_INVALID_DATA 表示操作的执行失败了，因为传入的参数数据不合法 STATUS_ERR_INCOMPATIBLE 表示操作的执行失败了，因为Client和Agent不兼容 STATUS_ERR_RESOURCES 表示操作的执行失败了，因为Agent上的资源错误 7.7.8 BaseObjectRequestBaseObjectRequest用来保存从XRCE Client发送给Agent的request的公共参数。他在附录中被定义为： 12345@extensibility(FINAL)struct BaseObjectRequest &#123; RequestId request_id; ObjectId object_id;&#125;; 这个类型的成员说明如下： request_id(RequestId):用于标识每个请求。用来将回复和请求进行相关联。适用于每对XRCE Client与Agent。注意，只要Client和Agent知道具有该值的历史请求不再活跃时，才可以为将来的请求重用request_id的值。 object_id(ObjectId):这就是request的目标。对于创建对象的request来说，object_id给创建的object传达了ObjectIdPrefix信息 7.7.9 BaseObjectReplyBaseObjectReply类型用来保存从XRCE Agent返回给Client的reply的公共参数。它在附录中被定义为： 123456789struct ResultStatus &#123; StatusValue status; octet implementation_status;&#125;;@extensibility(FINAL)struct BaseObjectReply &#123; BaseObjectRequest related_request; ResultStatus result;&#125;; 类型的成员说明如下： related_request包含了发送这次reply所响应的request的request_id和object_id， request_id（RequestId）用于标识request。它用来表述request和reply的联系 object_id（ObjectId）是request的目标，对于创建objects的requests来说，object_id将创建的对象所需要的objectId进行传递，在这种情况下， implementation_status（8位字节）提供特定于实现（特定于供应商）的返回状态。 该值由代理的 XrceVendorId 限定。 它只能由理解返回它的代理的 XrceVendorId 的实现状态值的客户端解释。 7.8 XRCE 对象操作7.8.1 ClientKey 的使用所有操作都是在 ClientKey 的上下文中执行的，它用于验证和识别Client： ClientKey 被分配给每个Client。 ClientKey 向特定Agent唯一标识Client。 ClientKey 与代理内Client的一组权限相关联。 ClientKey 应被视为机密。 它必须在Client和Agent中进行配置。 创建和配置超出了本规范的范围。 ClientKey无法被解释 除了 XRCE Root 上的 create_client 和 get_info 操作之外，所有其他操作都期望 ClientKey 引用一个已经存在的 XRCE ProxyClient。 如果不是这种情况，操作将失败。 为避免可能危及安全的信息泄漏，在某些情况下，无法找到 ClientKey 可能会导致 returnValue 具有 STATUS_ERR_NOCLIENT，而在其他情况下，它可能会默默地断开与客户端的连接。 ==代理应维护一个计数器，记录在已建立的连接上发送 STATUS_ERR_NOCLIENT 的次数，一旦超过某个阈值，它将关闭连接。 代理随后可能会拒绝或限制源自先前关闭的同一客户端传输端点的新连接。== 此行为的具体细节是特定于实现的，不在本规范的范围内。 7.8.2 XRCE RootXRCE Root 对象代表Agent。 XRCE Agent是所有代理都应实例化的单例对象。 XRCE Root 负责验证客户端应用程序并创建与每个客户端关联的 XRCE ProxyClient 对象。 XRCE Root 上的逻辑操作如表所示。 操作 参数 调用 create_client ResultStatus object_representation CLIENT_Representation out:agent_info AGETN_Representation get_info ResultStatus info_mask InfoMask client_info ObjectInfo out:agent_info ObjectInfo delete_client ResultStatus 7.8.2.1 create_client输入 client_representation(CLIENT_Representation) : Client的代表 输出 returnValue(ResultStatus): 表示操作是否成功以及XRCE ProxyClient对象的当前状态。 agent_info(AGENT_Representation)：Agent的代表 client_representation 应包含用于初始化 XRCE ProxyClient 的 CLIENT_Representation。 该类型在附件 A，IDL 类型中定义为： 12345678910@extensibility(FINAL)struct CLIENT_Representation &#123; XrceCookie xrce_cookie; // XRCE_COOKIE XrceVersion xrce_version; XrceVendorId xrce_vendor_id; Time_t client_timestamp; ClientKey client_key; SessionId session_id; @optional PropertySeq properties;&#125;; agent_representation 应包含一个 AGENT_Representation，它通知客户端有关代理的配置。 该类型在附件 A，IDL 类型中定义为： 12345678@extensibility(FINAL)struct AGENT_Representation &#123; XrceCookie xrce_cookie; // XRCE_COOKIE XrceVersion xrce_version; XrceVendorId xrce_vendor_id; Time_t agent_timestamp; @optional PropertySeq properties;&#125;; XRCE Agent应根据在 client_representation 中找到的信息执行以下检查和操作： 检查xrce_cookie 以确保它匹配预定义的XRCE_COOKIE 常量。如果它不匹配，则创建将失败并将返回值 StatusValue 设置为 STATUS_ERR_INVALID_DATA。 检查主要版本 (xrce_version[0]) 是否与 XRCE_VERSION_MAJOR 匹配。如果不匹配，则创建将失败并将返回值 StatusValue 设置为 STATUS_ERR_INCOMPATIBLE。 检查由client_key 标识的客户端是否有权连接到XRCE Agent。如果此检查失败，操作将失败并将 returnValue StatusValue 设置为 STATUS_ERR_DENIED。 检查Client属性（如果存在）。这些可能包含特定于供应商的信息，这些信息可能会阻止代理接受来自Client的连接。属性字段可能包括额外的身份验证令牌（例如用户名和密码）或其他配置信息。如果此检查失败，操作将失败并将 returnValue StatusValue 设置为适当的值。 检查是否存在与相同 client_key 关联的现有 XRCE ProxyClient 对象，如果是，则将现有 ProxyClient 的 session_id 与 client_representation 中的进行比较： 如果 ProxyClient 存在且具有相同的 session_id，则操作不应执行任何操作，并将返回值 StatusValue 设置为 STATUS_OK。 如果 ProxyClient 存在且具有不同的 session_id，则操作应删除现有的 XRCE ProxyClient 对象，随后采取与没有与 client_key 关联的 ProxyClient 相同的操作。 检查是否有足够的内部资源来完成创建操作。 如果没有，则操作将失败并将返回值 StatusValue 设置为 STATUS_ERR_RESOURCES。 XRCE Client和 XRCE Agent之间的通信状态由关联的 ProxyClient 管理。 因此，删除现有的 ProxyClient 会重置Client和Agent之间的任何先前通信状态。 任何缓存未决确认的消息都将被丢弃。 如果Agent创建了一个ProxyClient，它应该： 初始化它的状态来拥有特定的 session_id 使用序号0初始化内置流 设置 returnValue StatusValue为 STATUS_OK 使用agent_info返回XRCE Agent的表示 Agent和Client可以使用 client_timestamp和 agent_timestamp来检测 XRCE Client和 XRCE Agent之间的时间同步差异。此信息的使用不在本规范的范围内。 Agent和Client可以使用 XrceVersion 和 XrceVendorId 来进一步配置他们的协议 7.8.2.2 get_info输入： info_mask(InfoMask):选择需要返回的信息类别 client_info(ObjectInfo)：Client的代表 输出： returnValue(ResultStatus)：表示操作是否成功，以及XRCE ProxyClient的当前状态 agent_info(ObjectInfo)：Agent的代表 其中 client_info和 agent_info使用的类型 ObjectInfo定义如下所示： 12345@extensibility(FINAL)struct ObjectInfo &#123; @optional ActivityInfoVariant activity; @optional ObjectVariant config;&#125;; 操作 get_info 返回有关 XRCE Agent的信息，并且可以在与 XRCE Agent建立Session之前使用，即在 XRCE Root上调用操作 create_client 之前。 操作 get_info 可用于不同的传输或连接，允许Client搜索和发现 XRCE Agent对象的存在，并选择一个（或多个）具有合适配置和可用性的对象。 client_info 中的 ObjectVariant 成员应包含 CLIENT_Representation，它提供有关发出请求的 XRCE Client的信息。 CLIENT_Representation 的client_key 字段应设置为值CLIENTKEY_INVALID（见附件A，IDL 类型），以免不必要地公开ClientKey。 agent_info 中的 ObjectVariant 成员应包含 AGENT_ActivityInfo，其中包含有关 XRCE Agent的活动信息。 agent_info 中的 ActivityInfoVariant 成员应包含 AGENT_Representation，其中包含有关 XRCE Agent的信息。 ActivityInfoVariant 成员 address_seq 将用于通知 XRCE Client可以到达的传输地址并可以接收对 create_client 的调用。 在 CLIENT_Representation 和 AGENT_Representation 中都可用的 PropertySeq 类型的属性字段可用于实现 XRCE Agent的身份验证协议。 具体机制超出了本规范的范围。 7.8.2.3 delete_client输出 returnValue（ResultStatus）： 表示操作是否成功以及对象的当前状态 XRCE Agent会检查ClientKey来定位是否存在XRCE::ProxyClient。 如果对象并没有找到，操作就会失败，并且 returnValue状态值会被设置为STATUS_ERR_UNKNOWN_REFERENCE。如果找到了对象，对象会被删除，returnValue的状态值会被设置为STATUS_OK。 7.8.5 XRCE DataReader操作如下表定义 操作 参数 调用 read ResultStatus out:read_data DataRepresentation object_id ObjectId read_specification ReadSpecification 7.8.5.1 read输入： object_id(ObjectId)：读取数据的来源对象 read_specification(ReadSpecification): 对返回数据进行的约束，只有匹配了约束的数据才会被操作返回。 输出： returnValue(ResultStatus)：表示操作是否成功 read_data(DataRepresentation): 数据满足了 read_spec，或者存在错误 此操作从 object_id 标识的 XRCE DataReader 中读取一个或多个样本。如果成功读取数据，则应返回 STATUS_OK。 如果对象不存在，则返回 STATUS_ERR_UNKNOWN_REFERENCE 如果客户端因为权限约束不被允许使用引用的 object_id来读取数据，则返回STATUS_ERR_DENIED。 read_spec变量控制着由这个操作返回的数据。它的结构如下表所述 字段 类型 解释 preferred_stream_id octet（8位字节） 指定Agent 将样本发送到Client使用的StreamId。特殊值 STREAMID_NONE 表示 Agent 可以不受约束地选择 StreamId。如果代理确定使用 preferred_stream_id 会导致其资源管理出现问题，则允许代理使用与 preferred_stream_id 不同的 StreamId。 data_format DataFormat 选择一种数据格式 content_filter_expression string 选择要读取的数据的内容过滤器表达式。 max_samples (DataDeliveryControl) unsigned short 作为读取结果返回的最大样本数。特殊值 MAX_SAMPLES_ZERO =0 用于取消任何可能仍处于活动状态的先前读取操作。特殊值 MAX_SAMPLES_UNLIMITED =0xffff 用于表示对返回的样本数量有限制。 max_elapsed_time (DataDeliveryControl) unsigned short 从读取操作中传送样本可能花费的最长时间（以秒为单位）。单位是从发出呼叫时间算起的秒数。特殊值 MAX_ELAPSED_TIME_UNLIMITED = 0 表示没有最大值，操作将继续，直到满足某些其他条件或操作被明确取消。 max_bytes_per_sec (DataDeliveryControl) unsigned short 数据可以返回到读取操作的最大速率（以每秒字节数为单位）。 min_pace_period (DataDeliveryControl) unsigned short 从读取操作返回的数据消息之间的最小间隔（以毫秒为单位）。 data_format 的设置控制读取操作是返回每个消息的单个样本还是样本集合。它还确定数据是否包含出现在 SampleInfo 中的附加信息（参见附录 A IDL 类型）。附加信息包含序列号和时间戳。 content_filter_expression 的设置配置应用于 DataReader 缓存中的样本的内容过滤器。只有过滤器评估为 TRUE 的样本才应返回给 XRCE Client。 max_samples 的设置将读取操作配置为在返回指定数量的样本后终止。值 MAX_SAMPLES_ZERO 可用于取消当前活动的读取操作，而无需发送更多样本。值 MAX_SAMPLES_UNLIMITED 表示对返回的样本数量没有限制。 max_elapsed_time 的设置将读取操作配置为在从进行读取操作的那一刻起经过指定的时间后终止。值 MAX_ELAPSED_TIME_UNLIMITED 表示没有基于经过时间的终止条件。 max_bytes_per_sec 的设置配置可以返回样本的每秒字节数的最大速率。 min_pace_period 的设置配置了从代理发送到客户端的示例消息之间的最小间隔（以毫秒为单位）。这段时间使客户端可以在消息之间进入睡眠周期。 8 XRCE Protocol8.1 GeneralDDS-XRCE消息协议专门设计用于解决许多类型低功耗设备中的有限CPU、电源和网络带宽，并使该设备能够在较大的DDS网络中被发现。该协议有以下特点： 在带宽限制为40-100Kbps的网络上运行。 ==使用拥有睡眠周期的设备。这些设备可能每隔几分钟、几天、几个月甚至几年激活一次。== 简单且独立于编程语言，支持用高度专业化的语言或框架编程的设备。 支持最小发现协议，允许在动态发现代理位置的进行即插即用部署。 支持访问DDS的全部功能。任何数据类型都可以使用任何DDS QoS进行发布或订阅。 支持在同一个或多个DDS主题上高效地多次发送数据更新。 ==支持以可靠和尽力而为的方式接收信息，即使信息是在客户端处于睡眠周期时发送的==。 支持传输级别的安全通信。 ==提供对DDS全局数据空间中任何数据的完全读/写访问（受访问控制模块限制）。== 提供需要少于100KB代码的完整实现。 8.2 定义DDS-XRCE协议定义并使用了client、agent、session、stream和message这些术语。在上层来说，一个client使用DDS-XRCE协议和一个agent交流，是在一个session上的一个stream上进行交换message。 8.2.1 MessageMessage是通过传输发送的信息单元，是在DDS-XRCE传输上发送的结构化字节序列。message具有一个序列号，用于对message进行排序，或标识已被传输丢弃的消息。底层XRCE传输应将每条Message作为一个单元进行传输。单个XRCE传输“消息”应传输单个XRCEmessage。假设第一个字节具有16字节对齐，则应对XRCE消息进行编码。 因此，编码独立于它前面的任何传输标题或前缀。 8.2.2 Session一个Session定义了一个client和一个agent之间通过==一次握手建立==的双向链接。session在使用XRCE agent交换消息时被使用。一个XRCE client如果和多个XRCE agent通信时，应该在多个session上发送消息。一个session可以包含independent、reliable和best-effort消息流。每个session最多可以有256个stream。XRCE客户端和XRCE代理之间最多可以有一个活动session。新的session创建时会结束之前的session。 8.2.3 StreamStream表示Session中独立有序的消息流。消息通过序列号在流中排序。不同流使用的序列号（sequenceNr）彼此独立。数据流可以是reliable也可以是best-effort。每个stream使用一个固定的字节序来对消息/子消息的header和payload进行编码。 8.2.4 ClientXRCE client是发起与XRCE agent建session的实体。XRCE client可以在属于已建立的XRCE session的stream上向agent发送和接收message。 8.2.5 AgentXRCE agent是侦听和接受请求以建立来自XRCE client的session的实体。XRCE agent可以在属于已建立session的stream上向client发送和接收message。 8.3 Message Structure8.3.1 General一个XRCE message是由一个message Header跟着一个或多个Submessage组成的，它会被底层的XRCE传输以一个单元的形式进行传输。 8.3.2 Message Header 8.3.2.1 Sessions和sessionIdXRCE Client和XRCE Agent之间的Session的建立，是为了通信建立初始的环境。这主要包括了协议版本的交换、供应商的信息以及正确处理消息的其他信息。 一个Session由一个8位的sessionId来确定，sessionId对于给定XRCE Client的XRCE Agent是唯一的。seesionId同时也用来确定Header中是否包含了一个clientKey。 如果sessionId在0~127（0x00到0x7f）之间（含0和127），那么Header应该包含clientKey并且sessionId的作用域由clientKey确定。 如果sessionId在128~255（0x80到0xff）之间（含128 255），那么Header将不含clientKey，sessionId的作用域由message的源地址确定。如果clientKey没有显示出现在message的header，那么XRCE Agent必须能够从message的源地址定位它 有两个sessionId的值是预定的： 值0（0x00）应用于指示在包含clientKey的Header中缺少session。此值被称为SESSION_ID_NONE_WITH_CLIENT_KEY 值128（0x80）应用于指示在未包含clientKey的Header中缺少session。此值被称为SESSION_ID_NONE_WITHOUT_CLIENT_KEY. 8.3.2.2 Stream和streamIdXRCE Stream表示XRCE Client和XRCE Agent之间的独立信息流。 每个XRCE Message都属于一个stream。 属于同一stream的消息必须按其发送顺序进行传递。 属于不同流的消息没有相对于彼此排序。 Stream由他们所属于的Session所限制. 值为0（0x00）的streamId称为STREAMID_NONE。 此流用于仅包含不属于任何流的子消息的消息。 streamId在1（0x01）和127（0x7F）之间的流都应为best-effort流。 streamId在128（0x80）和255（0xFF）之间的流都应该是reliable流。 根据上述规则，如果streamId不是STREAMID_NONE，则streamId的前导位可以解释为指示流可靠性的标志。 每当创建会话时，都会创建两个内置流： 由值为1（0x01）的streamId标识的内置best-effort流。 这称为STREAMID_BUILTIN_BEST_EFFORTS。 由值128（0x80）的streamId标识的reliable流。 这称为STREAMID_BUILTIN_RELIABLE。 8.3.2.3 sequenceNrsequenceNr用于对流中的消息进行排序，并且范围仅限于该流。 属于不同流的消息彼此之间是无序的： 对于具有streamId STREAMID_NONE的stream，sequenceNr不强加任何顺序。 但是它仍然可以用来丢弃重复的消息。 对于streamId与STREAMID_NONE不同的流，sequenceNr施加顺序。 流中的消息不得乱序发送。 另外，重复的消息将被丢弃。 序列号的添加和比较应使用[IETF RFC-1982]定义的序列号算法，并且SERIAL_BITS设置为16。这意味着特定客户端会话流的未解决（未确认）消息的最大数目限制为$2^{15}$，即 是32768。sequenceNr应使用低字节序格式进行编码。 8.3.2.4 clientKeyclientKey唯一地标识XRCE Client并向XRCE Agent对XRCE Client进行身份验证。 如果sessionId在0到127之间，则clientKey将出现在Header上。 如果存在clientKey，则它应包含与XRCE Client关联的ClientKey。 如果clientKey不存在，则XRCE代理应能够从消息的源地址派生与XRCE Client关联的ClientKey。这意味着已经在XRCE Agent上为该特定源地址预配置了ClientKey，或者已将其作为会话建立的一部分进行了交换。 XRCE传输提供的安全机制可以保护clientKey的任何交换。这些安全机制是特定于传输的，可能涉及将每个设备与代理配对或用于建立安全传输连接的一些初始握手。 8.3.3 Submessage Structuremessage Header之后的就是一个或多个submessage。一个Submessage由一个SubmessageHeader和一个payload组成。 在一个message中防止多个Submessage的作用是减少带宽，原因是这样可以让多个资源来被一个message进行操作。 submessage应以相对于消息开头的 4 倍数的偏移量开始。。这意味着可以在子消息的结尾和下一个子消息的开始之间进行额外的填充。 8.3.4 Submessage Header每一个Submessage从一个SubmessageHeader开始，SubmessageHeader结构如下： 8.3.4.1 submessageIdsubmessageIde定义了submessage的种类。 8.3.4.2 flagsflags区域包括了Submessage的内容相关的信息。 0位是“Endianness”位，表示用于编码子消息头和有效负载的Endianness。如果Endianness位设置为0，则编码应为大端序，否则为小端序。 所有Submessage的flags都应该有Endianness位。特殊的submessage可能定义其他flag位。 8.3.4.3 submessageLengthsubmessageLength定义了Submessage的长度（含Submessage的头）。 同时它应该独立于flags的定义，以小端序进行编码。 8.3.4.4 payloadpayload包含了特殊于submessage的信息，submessage的格式取决于submessageId定义的submessage类型 8.3.5 Submessage Types 由SubmessageId定义的submessage中，有的是单向的，有的是双向的。 SubmessageId Value direction Purpose CREATE_CLIENT 0 Client到Agent 初始化Client和Agent之间的连接。在Agent上创建一个ProxyClient。会让Agent调用Root::create_client操作 CREATE 1 Client到Agent 创建一个XRCE对象会让Agent调用ProxyClient::create 操作 GET_INFO 2 Client到Agent 请求有关XRCE对象的信息会让Agent调用ROOT::get_info或ProxyClient::get_info操作 DELETE 3 Client到Agent 删除一个对象或删除一组XRCE对象会让Agent调用ProxyClient::delete操作或者Root::delete_client操作 STATUS_AGENT 4 Agent到Client 发送一个对CREATE_CLIENT的响应，包含Agent相关的信息携带Root::create_client操作的返回值 STATUS 5 Agent到Client 通常用来响应CREATE、UPDATE或者DELETE。包含一个XRCE对象的状态信息携带PoxyClient::create，update或者delete的返回值 INFO 6 Agent到Client 通常发送一个对GET_INFO的响应。包含关于一个XRCE::Object或者一个XRCE Agent的信息携带Root::get_info或者ProxyClient::get_info的返回值 WRITE_DATA 7 Client到Agent 使用XRCE的DataWriter来写数据会让Agent来调用ProxyClient::write操作 READ_DATA 8 Client到Agent 使用XRCE的DataReader来读数据会让Agent来调用ProxyClient::read操作 DATA 9 Agent到Client 响应READ_DATA，提供由XRCE的DataReader接收到的数据携带ProxyClient::read的返回值 ACKNACK 10 双向 发送肯定或者否定的信号给一些序列号 HEARTBEAT 11 双向 通知可用的序列号的范围 RESET 12 双向 重置session FRAGMENT 13 双向 传递数据片段。用于发送大小大于底层传输支持的大小的消息 8.4 互操作模型（Interaction Model）8.4.1 General本章节主要描述典型的信息流。 XRCE协议的目的就是使实现最小化发现和设置流量的客户端成为可能。因此一些信息流是可选的，而且可以被XRCE的Client和Agent进行带外（out-of-band，OOB）设置。 8.4.2 使用预先配置的DataWriter进行数据发送下面的消息流说明了XRCE Client使用XRCE Agent写入数据的完整消息集。 XRCE代理已预先配置为创建一个包含DomainParticipant，Publisher和DataWriter的XRCE应用程序。预先配置了object_id的DataWriter为XRCE Client所知。 ​ 已为Clinet（由ClientKey标识）预先配置了XRCE Agent，以便它可以识别出现在 CREATE_CLIENT消息中的application_object_id。 CREATE_CLIENT的接收触发相应XRCE对象的 创建或重用。这些XRCE对象包括XRCE DataWriter及其相应的DDS DataWriter。 随后的WRITE_DATA消息通过那些DataWriter的ObjectId来使用DDS发布数据。 8.4.3 使用预先配置的DataReader进行数据接收下面的消息流说明了XRCE Client用来通过XRCE Agent接收数据的完整消息集。 XRCE Agent已预先配置为创建一个包含DomainParticipant，Subscriber和DataReader的XRCE Application。 XRCE Client知道DataReader预先配置的object_id。 ​ 已为Client（由 ClientKey标识）预先配置了一个Agent，从而可以使它识别 出现在 CREATE_CLIENT消息中的 application_object_id。CREATE_CLIENT的接收触发相应 XRCE对象的 创建或重用。其中包括 XRCE DataReader及其相应的 DDS DataReader。 随后的READ消息引用这些DataReader的 ObjectId以便从DDS域接收数据。 8.4.4 发现一个Agent下面的消息流说明了XRCE客户端发现XRCE代理所需的消息。 仅当未使用XRCE代理的TransportLocator预先配置客户端时，才需要此流程。 它允许将XRCE客户端配置为满足一个或多个TransportLocator（可能包括多播地址）的需求，以便动态发现代理的存在和实际地址。 作为此过程的结果，XRCE客户端可能发现多个XRCE代理。 在那种情况下，它可能会使用收到的有关XRCE代理配置的信息（例如，字段版本，vendor_id或在AGENT_Representation中找到的属性）和XRCE代理活动（例如，ActivityInfo中的可用性字段）来选择最合适的XRCE代理，甚至连接到多个XRCE代理。 ​ XRCE 客户端使用 GET_INFO 查询 XRCE 代理的信息，代理响应后，客户端选择一个代理并使用 CREATE_CLIENT 消息连接到它。 代理以 STATUS_AGENT 响应，指示连接是否成功以及是否代表 XRCE 客户端创建了 ClientProxy。 8.4.5 链接到一个Agent上下面的消息流说明了XRCE Client连接到XRCE Agent所需的消息。Client连接后，它可以创建资源或调用现有资源上的操作。 ​ XRCE Client使用 CREATE_CLIENT 消息连接到 Agent。 Agent 以 STATUS_AGENT响应，该状态指示连接是否成功以及是否代表 XRCE客户端创建了ClientProxy。 8.4.6 创造一个完整的Application下面的消息流说明了已经连接的XRCE Client 创建完整的XRCE Application所需的消息。 ​ XRCE Client使用 CREATE 消息创建 XRCE Application。 CREATE消息带有一个CREATE_Payload，其中包含一个ObjectKind设置为OBJK_APPLICATION的 ObjectVariant。 相应的 OBJK_APPLICATION_Representation可以使用 REPRESENTATION_BY_REFERENCE 来引用在代理中预先配置的Application，也可以使用REPRESENTATION_AS_XML_STRING来完整地描述该 Application，包括任何必要的 Type，Qos和DDS实体。 8.4.7 定义Qos配置下面的消息流说明了已连接的XRCE Client动态定义XRCE QosProfiles所需的消息，这些消息以后可用于创建其他XRCE对象。 ​ XRCE Client使用 CREATE消息来定义Qos配置文件。 CREATE消息包含一个CREATE_Payload，其中包含一个ObjectKind设置为OBJK_QOSPROFILE的ObjectVariant。 相应的 OBJK_QOSPROFILE_Representation可以使用 REPRESENTATION_AS_XML_STRING来完整描述Qos概要文件。 8.4.8 定义类型下面的消息流说明了已连接的XRCE Client动态定义XRCE Type所需的消息，这些XRCE Type以后可用于创建XRCE Topic对象。 ​ XRCE Client使用 CREATE消息创建XRCE类型。 CREATE消息带有一个CREATE_Payload，其中包含一个ObjectKind设置为OBJK_TYPE的ObjectVariant。 对应的 OBJK_TYPE_Representation可以使用 REPRESENTATION_AS_XML_STRING 来完整描述 DDS-XTYPES类型，包括任何引用的类型。 8.4.9 创建一个Topic下面的消息流说明了已连接的XRCE Client动态创建XRCE主题所需的消息，该主题以后可用于创建XRCE DataWriter和DataReader对象。 ​ XRCE Client使用 CREATE消息创建 XRCE Topic。 CREATE消息包含一个CREATE_Payload，其中包含一个ObjectKind设置为OBJK_TOPIC的ObjectVariant。 相应的 OBJK_TOPIC_Representation可以使用 REPRESENTATION_IN_BINARY或 REPRESENTATION_AS_XML_STRING来完全定义主题。 8.4.10 创建一个DataWriter下面的消息流说明了已连接的XRCE Client动态创建XRCE DataWriter所需的消息，该资源具有发布数据所需的所有资源。 XRCE Agent可能具有QoS配置文件的先验知识，从而允许XRCE客户端按名称引用Qos，而无需明确定义它们。 或者，XRCE Client可以将它们的定义包括在XRCE DataWriter资源的定义中。 ​ XRCE Client使用 CREATE消息创建 XRCE DataWriter。 CREATE消息包含一个CREATE_Payload，其中包含一个ObjectKind设置为OBJK_DATAWRITER的ObjectVariat。 相应的 DATAREADER_Representation可以使用 REPRESENTATION_IN_BINARY或 REPRESENTATION_AS_XML_STRING来完全定义DataWriter。 这两种表示方式都可以指定DataWriter Qos。 DATAREADER_Representation也可以使用REPRESENTATION_BY_REFERNCE来引用Agent已知的DataWriter定义。 8.4.11 创建一个DataReader下面的消息流说明了已连接的XRCE Client动态创建XRCE DataReader所需要的消息，该资源具有订阅数据所需的所有资源(原文为publish data我觉得有点问题)。 XRCE Agent可能具有QoS配置文件的先验知识，从而允许XRCE客户端按名称引用这些Qos，而无需明确定义。 或者，XRCE Client可以将它们的定义包括为XRCE DataReader资源的定义中。 ​ XRCE Client使用 CREATE消息创建 XRCE DataReader。 CREATE消息包含一个CREATE_Payload，其中包含一个ObjectKind设置为OBJK_DATAREADER的ObjectVariant。 相应的 OBJK_DATAREADER_Representation可以使用 REPRESENTATION_IN_BINARY或 REPRESENTATION_AS_XML_STRING来完全定义DataReader。 这两种表示形式都允许指定DataReader Qos。 OBJK_DATAREADER_Representation也可以使用REPRESENTATION_BY_REFERENCE来引用Agent已知的DataReader定义 8.4.12 从一个资源上获取信息下面的消息流说明了XRCE Client如何查询有关资源的信息。 XRCE Client可以使用此机制来确定XRCE Agent代表XRCE Client管理的任何DDS代理实体的QoS。 它还可以用于读取XRCE Agent已知的QoS配置文件和类型声明。 ​ XRCE Client使用GET_INFO消息从由其 ObjectId标识的 XRCE Object获取信息。XRCE Agent以包含ObjectVariant的 INFO消息作为响应。 ObjectVariant的ObjectKind适用于指定的 ObjectId。 8.4.13 更新一个资源下面的消息流说明了XRCE Client 如何更新XRCE DataReader。 XRCE Client可以使用此机制来更改XRCE Agent代表XRCE Client管理的任何DDS代理实体的QoS参数。 ​ XRCE Client使用CREATE消息，将属性reuse设置为TRUE，并将属性replace设置为TRUE，以表示它希望更新由ObjectId标识的对象。 CREATE消息包含一个ObjectVariant，其中ObjectKind设置为指定的ObjectId的适当值。 XRCE代理使用ObjectVariant中包含的新配置更新对象，并以STATUS消息作为响应。 8.4.14 可靠通信可靠性是针对每个Stream分别实现的，并且仅针对由stream_id值介于0x80和0xFF之间标识的可靠流。 （参见第8.3.2.2节Streams和streamId。） 一个Stream恰好有两个端点，即发送端点和接收端点。 请注意，对于某些流，发送者是XRCE Client，例如 当XRCE Client使用流将数据写入XRCE Agent时。 同样，在其他流中，发送方可以是XRCE Agent，例如，当XRCE Agent 使用流来发送XRCE Client在READ操作中请求的数据时。 Stream上的发送者和接收者端点各自执行其自己的协议状态机。 这些在以下小节中进行了说明。序列号添加和比较应使用第8.3.2.3节sequenceNr中规定的序列号算法。 8.4.14.1 可靠发送状态机由端点在流上发送的协议如下图所示。 发送方维护与流关联的两个状态变量。 最高发送序列号（HighestSentSequenecNumber）和最高确认序列号（HighestAcknowledgedSequenceNumber）。 每次发送消息时，HighestSentSequenecNumber都会增加。 ACKNACK消息的接收会 更新HighestAcknowledgedSequenceNumber。当HighestAcknowledgedSequenceNumber小于HighestSentSequenceNumber时，发送方将HeartBeat消息发送给接收方，该消息宣告HighestSentSequenecNumber。 这些HeartBeat消息可以是定期的，也可以使用特定于供应商的机制进行优化。 要求以一定的速率发送它们，直到HighestAcknowledgedSequenceNumber与HighestSentSequenceNumber匹配为止。 8.4.14.2 可靠接收状态机由端点在流上接收的协议如下图所示： 接收方包括两个和流关联的状态变量。最高接受序列号（HighestReceivedSequenceNumber）和最高确认序列号（HighestAnnouncedSequenceNumber ）。 每次接收到一条消息时，HighestReceivedSequenceNumber可能会更新（假定已接收到所有先前的消息）。 HighestAnnouncedSequenceNumber也会进行调整。 每次收到HEARTBEAT时，可能会调整HighestAnnouncedSequenceNumber。 如果接收方是XRCE Client，则当HighestReceivedSequenceNumber小于HighestAnnouncedSequenceNumber时，接收方将发送ACKNACK消息以请求与丢失的序列号相对应的消息。 这些ACKNACK消息可以是周期性的，或者可以使用特定于供应商的机制进行优化。 如果接收方是XRCE Agent，则它仅响应于接收到HEARTBEAT才发送ACKNACK消息。 这样做是为了避免使XRCE Client不堪重负或在不适当的时间唤醒它。 8.5 XRCE 对象操作的可追溯性本节总结了用于在 XRCE 对象模型上实现每个操作的消息，确保已涵盖所有操作。 使用的消息触发每个操作并接收结果汇总在表 14 中 XRCE对象类型 操作 用于调用的消息 用于返回的消息 XRCE Root create_client CREATE_CLIENT STATUS_AGENT XRCE Root get_info GET_INFO INFO XRCE Root delete_client DELETE STATUS_AGENT XRCE ProxyClient create CREATE(标志为创建) STATUS XRCE ProxyClient update CREATE(标志为重用) STATUS XRCE ProxyClient get_info GET_INFO INFO XRCE ProxyClient delete DELETE STATUS XRCE DataWriter write WRITE_DATA, FRAGMENT STATUS XRCE DataReader read READ_DATA DATA, FRAGMENT, STATUS 9 XRCE Agent 配置9.1 常规XRCE Agent可以被配置为使得它具有先验知识 XRCE 对象。 这允许 XRCE Client使用表示格式 REPRESENTATION_BY_REFERENCE 来以非常紧凑的方式引用和创建 XRCE 对象，请参阅第 7.7.3.3.1 节 REPRESENTATION_BY_REFERENCE 格式。 本规范提供了两种标准机制来配置 XRCE Agent。 实现还可以提供额外的机制： 使用 XRCE 协议进行远程配置 基于文件的本地配置 这些机制在以下条款中进行了描述。 9.2 使用XRCE协议进行远程配置应用程序可以使用 XRCE Client，其唯一目的是定义和创建用于其他应用程序的 XRCE 对象。 这种类型的应用程序称为 XRCE ConfigurationClient。 XRCE ConfigurationClient 使用的协议与任何其他 XRCE Client 使用的协议相同。 唯一的区别是 XRCE ConfigurationClient 从不使用 READ_DATA 或 WRITE 消息。 它仅使用创建、更新或检索有关 XRCE 对象的信息的消息。 任何其他 XRCE Client都可以引用由XRCE ConfigurationClient创建的 XRCE 对象。 远程配置机制的典型用途是可用于在部署之前配置代理或交互式配置系统的工具。 请注意， XRCE ConfigurationClient可能使用不同的网络或传输与代理进行通信，这可能与典型的 XRCE Client具有不同的约束。 9.3 基于文件的配置略 10 XRCE部署DDS-XRCE PIM 中描述的所有操作都与客户端应用程序与单个 DDS XRCE Agent的交互有关。 因此，所有操作的范围仅限于与该 DDS-XRCE Agent的交互。 然而，尽管连接到不同的 DDS-XRCE Agent，客户端应用程序仍可能相互交互。 这些交互将作为 DDS-XRCE Agent在 DDS 域参与者实体上创建和执行操作的结果而发生，这些实体根据 DDS 规范交换信息。 10.1 XRCE Client到DDS的通信该规范定义了 XRCE Client用于与代理 DDS 域中客户端的 XRCE Agent通信的协议。 这样做的主要结果是 XRCE Client现在可以与任何 DDS 域参与者进行通信。 DDS 域参与者将发现 XRCE Agent代表Client创建的代理 DDS 实体，并使用标准的 DDS-RTPS 互操作性协议与代理进行通信。 XRCE Client将使用 XRCE 协议与 XRCE Agent通信。 使用该协议，它可以指导 XRCE Agent创建新的 DDS 实体，并使用这些实体在DDS全局数据空间上读写数据。 这种类型的部署如下面的图所示。 XRCE Client使用 XRCE 协议与 XRCE Agent通信。 XRCE Agent使用 DDS-RTPS 协议与 DDS 域中的其他 DDS 域参与者通信。 10.2 XRCE Client 通过DDS到XRCE Client的通信XRCE Agent在 DDS 域中显示为 DDS 域参与者。 因此，连接到不同 XRCE Agent的 XRCE Client应用程序无需进一步配置即可相互通信。 每个 XRCE Agent将其他 XRCE Agent视为 DDS 域参与者，与任何其他 DDS 域参与者没有区别，并使用 DDS-RTPS 与他们通信。 XRCE Agent将将该通信中继到其各自的 XRCE Client。 这种类型的场景如下图 所示 XRCE Client使用 XRCE 协议与其各自的 XRCE Agent进行通信。 这些 XRCE Agent使用 DDS-RTPS 相互通信，因为每个代理都是 DDS 域上的 DDS 域参与者。 10.3 由XRCE Agent当中间人的Client到Client通信多个 XRCE Client应用程序可以连接到同一个 XRCE Agent。 它取决于 XRCE Agent的实现，无论它创建的 DDS 实体是每个 XRCE Client专有的，还是在 XRCE Client之间共享的。但是，XRCE Client可观察到的行为应如同 DDS XRCE Agent创建每个 XRCE Client专有的单独 DDS 对象。 如果 XRCE Agent代表每个 XRCE Client创建单独的 DDS 实体，那么每个实体都将拥有自己的代理 DDS 域参与者。这两个 DDS 域参与者将在 DDS 域上相互通信。在这种情况下，两个 XRCE Client将在 XRCE Agent的“代理”下相互通信，而无需在 XRCE Agent中进行额外的配置或逻辑。 如果 XRCE Agent在不同的 XRCE Client之间共享 DDS 实体，那么行为“好像”每个都有自己独立的实体的要求需要本地 DDS DataWriter 实体发现并匹配同一 DomainParticipant 中的本地 DDS DataReader 实体。这将自动导致 XRCE Client使用代理作为“代理”相互通信，而无需进一步配置。 XRCE Agent的实现可以选择在本地 XRCE DataWriter 和 DataReader 对象之间创建更快的通信路径，以便来自 XRCE DataWriter 的数据可以直接进入匹配的 XRCE DataReader，而无需通过关联的 DDS 实体。这个“捷径”可以作为一种优化来实施，因为它不会影响任何协议，也不会影响与其他 XRCE Client、Agent或 DDS 域参与者的互操作性。 这种类型的场景如下图 所示。 多个 XRCE Client可以连接到同一个 XRCE Agent。 XRCE Client使用 XRCE Agent作为“代理”相互通信。 这种“客户端到客户端”的通信可以利用相关的 DDS 对象，或者可以使用代理内部的优化路径，从而缩短 DDS 对象的使用。 10.4 联合部署10.5 Client应用之间直接P2P通信10.6 组合部署11 传输映射11.1 传输模型XRCE 协议不限于任何特定的传输。它可以映射到大多数现有的网络传输，如 UDP、TCP 和低带宽传输，如蓝牙、ZigBee 和 6LoWPAN。 为了在没有额外开销的情况下运行，预计传输支持以下功能： 传送至少 64 字节的消息。 处理消息的完整性，丢弃任何损坏的消息。此功能不限制可用的传输；它只需要在来自不处理本机完整性的传输的消息中附加一个 CRC。 提供接收消息的大小以及源地址。此要求不限制可用的传输；它只需要在来自传输本身不包含信息的消息中添加源信息和大小。 支持双向通信。 提供传输级安全，特别是客户端验证代理的方法和安全（加密和验证）消息交换的方法。或者，XRCE Agent和Client可以部署在安全网络层（例如加密 VPN）之上。 传输明确不需要以下功能： 不需要提供可靠性。消息可能会被丢弃。 不需要提供顺序。消息可能会乱序到达。 不需要提供丢弃消息的通知。 不满足上述某些先决条件的传输仍可通过添加丢失的信息作为 XRCE message的信封来使用。这将作为映射到该特定协议的一部分来完成。 例如，如果缺少源地址或消息大小，它们可以作为前缀添加到 XRCE 消息。如果传输不支持完整性，可以将 CRC 后缀添加到 XRCE 消息。 11.2 UDP 传输UDP 传输满足第 11.1 节中列出的所有功能。 除了它不提供安全性。 对于需要安全性的应用程序，有“数据报传输层安全性”(DTLS) 标准 [DTLS]，它在 UDP/IP 之上提供安全性。 或者，UDP 可以部署在专用网络 (VPN) 上，它在 UDP 之下的 IP 层提供安全性。 由于 XRCE 协议不需要传输提供可靠性、排序或故障通知，因此它可以简单地映射到“数据报”传输，例如 UDP/IP。 11.2.1 传输定位器当 XRCE 映射到 UDP v4 时，union类型的TransportLocator 应使用 TransportLocatorFormat 鉴别器为 ADDRESS_FORMAT_MEDIUM。 这将选择类型的 medium_locator成员。 1234struct TransportLocatorMedium &#123; octet address[4]; unsigned short port; &#125;; 当 XRCE 映射到 UDP v6 时，union类型的TransportLocator 应使用 TransportLocatorFormat 鉴别器为 ADDRESS_FORMAT_LARGE。 这将选择类型的 large_locator成员。 1234struct TransportLocatorLarge &#123; octet address[16]; unsigned long port; &#125;; 11.2.4 Agent发现XRCE Agent发现可以使用 UDP/IP 多播完成。 XRCE Agent应预先配置它们应侦听的多播地址和端口号。默认情况下，它们应为地址 239.255.0.2 和端口 7400。 为了通过多播发现代理，XRCE Client应定期向配置的多播地址和端口发送 GET_INFO 消息（见 8.3.5.3）。该消息应调用 XRCE Agent上的 get_info 操作（见 7.8.2.2），该操作应响应并包括其 TransportLocators。一旦 XRCE Client收到来自代理的合适响应，它应停止发送定期消息。 XRCE Agent发现可以使用 UDP/IP 单播完成。 XRCE Client应预先配置有 XRCE Agent可能位于的候选 UDP 地址和端口列表。 为了通过单播发现代理，XRCE Client应定期向配置的地址和端口发送 GET_INFO 消息（见 8.3.5.3）。该消息应调用 XRCE Agent上的 get_info 操作（见 7.8.2.2），该操作应响应并包括其 TransportLocators。一旦 XRCE Client收到来自代理的合适响应，它应停止发送定期消息 11.3 TCP 传输11.3.4 Agent发现即使通信将通过 TCP，XRCE Agent发现可以使用 UDP/IP 多播完成。 XRCE Agent可以预先配置多播地址和端口号，它们将对多播进行侦听。默认情况下，它们应为地址 239.255.0.2 和端口 7400。 为了通过多播发现代理，XRCE Client应定期向配置的多播地址和端口发送 GET_INFO 消息（见 8.3.5.3）。该消息应调用 XRCE Agent上的 get_info 操作（见 7.8.2.2），该操作应响应并包括其 TransportLocators。一旦 XRCE Client收到来自代理的合适响应，它应停止发送定期消息。 XRCE Agent发现可以使用 TCP/IP 完成。 XRCE Client应预先配置有 XRCE Agent可能位于的候选 TCP 地址和端口列表。 为了通过单播发现代理，XRCE Client应定期尝试与配置的地址和端口建立 TCP 连接。建立连接后，它将发送 CREATE_CLIENT 消息（见 8.3.5.1）。该消息应调用 XRCE Agent上的 create_client 操作（见 7.8.2.1），该操作要么接受要么产生错误。一旦 XRCE Client收到来自代理的合适响应，它应停止进行定期连接尝试。","tags":[{"name":"DDS","slug":"DDS","permalink":"https://zijian.wang/tags/DDS/"},{"name":"研究方向","slug":"研究方向","permalink":"https://zijian.wang/tags/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/"},{"name":"协议阅读","slug":"协议阅读","permalink":"https://zijian.wang/tags/%E5%8D%8F%E8%AE%AE%E9%98%85%E8%AF%BB/"}]},{"title":"《C++ Primer 第五版》阅读过程查漏补缺 Chapter3","date":"2021-01-10T07:43:45.000Z","path":"2021/01/10/《C++ Primer 第五版》阅读过程查漏补缺 Chapter3/","text":"这一章名为字符串、向量和数组，主要区别于C和java的个人感觉就是向量这个概念。 命名空间Using的使用 通过using namespace::name;进行声明的方式也可以将某个指定的函数导入命名空间，后面使用无须专门的前缀。 一般在头文件中不会使用using声明。 标准库类型：stringstring类型是定义在命名空间std中的。 初始化方法C++有多种初始化方式。在这里总结为拷贝初始化和直接初始化。 拷贝初始化：使用 ”=“ 号进行初始化变量，实质进行了拷贝初始化eg. string s1 = string(&quot;value),string s2 = &quot;abcde&quot;或string s3 = string(10,&#39;c&#39;)(表示s3初始化为了由10个c组成的字符串) 直接初始化：否则就是直接初始化eg. string s4(s1)、string s5(&quot;jlkad&quot;)或者string s6(10,&#39;c&#39;) string对象的操作 getline函数需要注意的点： getline(is,s) 从输入流is中读取一行赋值给s，但是不包括换行符。 size()函数需要注意的点 string::size_type类型是size()函数所返回的类型。虽然大多数时候我们在编程时习惯用int型变量来承载string的size()函数的返回值，但事实上，他真正返回的是一个无符号的整数。所以如果表达式混杂了有符号和无符号数，就可能出现这个问题。本书后面还提到了一个关键字decltype()用来得到某个函数size()或者变量的类型。 比较string对象需要注意的点：比较顺序：先比较每个位置的字典序，然后再比较长度。 string对象的加法：必须保证‘+’号左右的运算对象至少有一个是string类型。字面值是无法和字面值相加的。 string对象中的字符操作关于C++版本的C标准库头文件C++标准库兼容了C语言的标准库。C语言中形如name.h的头文件，在C++中被命名为cname。例如cctype头文件和C语言中的ctype.h头文件的内容是一样的。一般而言，C++程序应该使用cname的头文件。在cname头文件中定义的名字都从属于std命名空间。下表是cctype头文件中比较常见的字符判断操作函数。 基于范围的for语句遍历给定序列的每个元素并进行操作，c++11标准给出了新语句，语法形式形如： 12for (declaration : expression ) statement 其中expressio表示序列的一个对象，declaration部分定义了一个变量，用来遍历序列中的每个元素。 123// eg 获得字符串中的每个字符进行操作变为大写for (auto &amp;c : s) c = toupper(c); //c是引用，所以可以改变 标准库类型：vector 事实上来讲c++中的vector其本质是一个类模板。尽管他被称为对对象的集合。在C++中，编译器根据模板创建类或函数的过程称为实例化。对于像vector这样的类模板来说，我们通过提供一些额外信息来指定模板到底实例化为什么样的类，具体提供什么信息由模板决定。提供信息的方式是这样的：在模板名字后面跟上一对尖括号，在括号中放上信息。 vector可以容纳绝大多数类型的对象作为元素，除了引用，因为引用不是对象。其他绝大多数（非引用）内置类型和类类型都可以构成vector对象，甚至组成vector的对象本身也能是对象。注：早期版本C++标准如果vector的元素是其他模板类型，必须在外层vector对象的右尖括号和其元素类型之间添加一个空格。如vector\\在早期版本应该为vector\\. vector的初始化有很多种。类似于string，但是需要注意的是，尽管我们在很多时候使用vector来作为动态数组进行使用，但是我们不能像在数组初始化时直接使用{}来进行整体的初始化。vector在使用{}进行初始化时，只有一种用法就是将vecotr包含大括号内值个数的元素，然后每个元素被赋予相应初始值。当然更一般的用法是直接创建一个空的vector对象，后面需要时逐一添加。 注意在拷贝初始化时，两个vector对象的类型必须相同。 初始化时区分是列表初始化还是元素数量主要依赖于传递初始值时使用花括号还是圆括号。但是特殊情况是如果使用了{}但是{}中的元素却和vector的类型不相符，则可以考虑他是否是初始化元素数量。例如： 12vector\\&lt;string\\&gt; v7&#123;10&#125;; // v7有10个默认初始化的元素vector\\&lt;string\\&gt; v8&#123;10,&quot;hi&quot;&#125;; // v8有10个值为“hi”的元素 向vector对象中添加元素一般使用的是push_back()函数，该函数会向vector对象末尾添加元素。注意对vector对象添加元素时蕴含有编程假定：a. 必须要确保所写的循环正确无误，特别是在循环有可能改变vector对象容量的时候。 b. 如果循环体内包含有向vector对象添加元素的语句，则不能使用范围for循环。 vector不能使用下标形式来添加元素，对于vector的下标运算符，只能对确定已存在的元素进行使用。 迭代器所有的标准库容器都可以使用迭代器。迭代器类似指针类型，提供了对对象的间接访问。迭代器分有效和无效，有效迭代器指向某个元素，或者容器中尾元素的下一位置。可以使用迭代器的类型（容器和string）都拥有begin和end成员。其中begin自然指向容器或者string的第一个元素或字符，而end则指向容器或者string的“尾元素的下一位置”。所以end返回的迭代器常被称为尾后迭代器。如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器·迭代器有一些自己的运算符。我们必须使用解引用符来获取迭代器所指向的元素，该迭代器必须合法并确实指向某个元素。例如尾后迭代器就无法被解引用。循环时可以用auto定义的变量来承接begin所返回的迭代器。然后进行++操作。同时使用判断it是否等于end来判断循环是否结束。_注：这里c++中一般使用!=来判断是否遍历完成而不是&lt;来判断，是因为所有的标准库容器的迭代器都定义了!=和==，但不是所有的都定义&lt;运算符，所以一般习惯性使用迭代器和!=进行配合。迭代器的精确类型一般我们并不关心，拥有迭代器的标准库类型使用iterator和const_iterator来表达迭代器类型。形如：vector\\::iterator it。对于begin和end运算符，返回的具体类型由对象是否是常量决定。分别返回const_iterator或者iterator。C++11提供了两个新的函数cbegin和cend，他们返回的都是const_iterator。另外由于vector的动态增长性，可能会使其迭代器失效。迭代器可以进行一部分运算，比如我们可以通过auto mid = (v.begin()+v.end())/2 得到一个指向v容器中间的元素的迭代器mid,并利用比较操作符来控制遍历。 数组数组和vector十分类似，但是大小确定不变。定义时必须使用常量表达式进行声明数组的维度（元素个数），默认情况下，数组的元素被默认初始化。不允许直接将数组内容拷贝给其他数组作为初始值，也不能直接用数组给其他数组赋值。（但是某些编译器可能支持，因为可能存在编译器扩展，但是标准特性是这样的） 复杂的数组声明一般要从内向外读，先读括号内的内容： 12int (*Parray)[10] = &amp;arr; // Parray 指向一个含有十个整数的数组 int (&amp;arrRef)[10] = arr; // arrRef引用一个含有十个整数的数组 指针和数组 和C语言中的类似，不过在C++11中提供了标准库函数begin(array)和end(array)。 C风格字符串cstring头文件中包含了strlen(p)、strcmp(p1,p2)、strcat(p1,p2)、strcpy(p1,p2)这些函数。传入这些函数的指针，必须指向以空字符’\\0’作为结束的数组。 与旧代码的接口很多C++程序再标准库之前就写出来了，所以对于vector和string类型，有一些c++程序使用的是C语言或其它语言的接口程序。所以C++提供一些工具来和这些代码衔接。在混用string和C风格字符串上，C++提供了下述手段：从string方向来讲： 允许使用以空字符结束的字符数组初始化string对象或为其赋值 在string对象的加法运算中允许使用以空字符结束的字符数组作为其一运算对象但是反过来讲，为了将string类型字符串也应用于字符数组，string提供了c_str的成员函数。","tags":[{"name":"C++","slug":"C","permalink":"https://zijian.wang/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zijian.wang/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"《C++ Primer 第五版》阅读过程查漏补缺 Chapter2","date":"2020-11-04T09:09:30.000Z","path":"2020/11/04/《C++ Primer 第五版》阅读过程查漏补缺 Chapter2/","text":"这一章名为变量和基本类型，个人觉得需要重点关注的是引用与指针，以及const相关的知识。 变量的定义和声明声明: 使得名字为程序所知， 定义:负责创建与名字相关的实体。 如果想要声明一个变量而非定义它，就需要在变量名前加上关键字extern。 12eg. extern int i; //声明i而非定义 int j; //声明并且定义j 然而，如果给extern标记的变量赋予了初始值，则进行了定义。 变量只能被定义一次，但是可以被多次声明 复合类型引用和指针都是c++的复合类型。他们的相似和区别如下： 相同 不同 引用 实现了对某个对象的间接访问一般情况引用类型需要和绑定的对象严格匹配 1. 引用在定义时就要进行和对象的绑定，一经绑定无法修改2. 引用本身不是一个对象，仅仅是一个别名，没有实际地址3. 引用只能绑定在某个对象上，不能绑定在字面值或者计算结果 指针 实现了对某个对象的间接访问一般情况引用类型需要和绑定的对象严格匹配 1. 指针本身就是一个对象，允许对指针赋值访问2. 指针无需在定义时赋初值，而且在其生命周期，可以多次指向不同对象3. 指针存放的是对象地址，所以赋值时要用取址符&amp;获取对象地址4. 使用指针时，需要使用解引用符*来访问对象 注： 可以有指向指针的引用，不能有指向引用的指针 12345int i = 42;int *p;int *&amp;r = p; // r是一个指向指针p的引用r = &amp;i; // 给指针p赋值*r = 0; // 得到p指向的对象并赋值 空指针：nullptr (c++11新标准引入) 等同于初始化为字面值0。 void* 指针： 一种特殊的指针类型，可以用于存放任意对象的地址。我们可以用void*指针进行指针比较、作函数输入或输出，或者赋值给别的void*指针，但是我们不能直接操作它所指向的对象。 const限定符const对象一般情况下仅在文件内有效。当多个文件中出现多个const，则说明是在多个文件中分别定义了不同的对象。 如果想要在多个文件中声明或使用某个const对象，那就需要在定义和声明时都加上extern关键字。 const的引用前面提到引用必须严格和绑定的对象进行匹配，int配int，double配double，但是在const中，针对const的引用是允许用任意表达式作为初始值的，只要其结果可以转换为引用的类型就可以。 123eg. double dval = 3.14; // const int &amp;ri = dval; // 此时ri为3 当然此时对ri是无法进行赋值操作的，而且此时 编译器中实质发生的是这样的过程： 123double dval = 3.14; const int temp = dval; // temp是一个临时量对象 const int &amp;ri = temp; // ri实际引用的是一个临时量对象，所以显然无法对它进行更改 引入了临时量这一概念之后，就很好理解“对const的引用可能引用一个并非const对象”的概念了。 12345int i = 42; int &amp;r1 = i; // 引用r1是一个普通的引用，绑定了iconst int &amp;r2 = i; // 引用r2是一个对const的引用，表面绑定了i，实质绑定的是一个临时量对象r1 = 0; // 此时i还可以通过r1更改r2 = 0; // 这里就会报错，因为r2是无法对i进行任何更改的。 指针与const普通指针类型无法指向常量。只有指向常量的指针才可以指向常量类型。指向常量类型的指针写作：const 数据类型 *ptr。 前面同样提到指针类型必须和它指向的对象的类型一致，但是指向常量的指针，也是可以指向一个非常量的对象的。 123eg. double i = 3.14; // 非const const double *cpter = &amp;i; //指向非常量对象，但是无法通过cpter改变 常量指针（const pointer）:const允许把指针本身定为常量。常量指针必须初始化， 一但初始化完成，指针就和它所指向的地址绑定了。但是指针指向的变量本身是可以改变的,换言之如果指向的是变量而不是常量，我们仍然可以使用ptr进行访问或修改。常量指针写作：``数据类型 const ptr``; 常量指针（顶层const） 指向常量的指针（底层const） 指向常量的常量指针 （右边的const是顶层const 左边的const是底层const） 指针对象是一个常量 指针指向的对象是一个常量 两者都是常量 可以通过解引用符*修改指向的变量 无法通过解引用符*修改指向的变量 无法通过解引用符*修改指向的变量 无法指向其他的对象 可以指向其他的对象 无法指向其他的对象 声明时必须初始化 声明时不必定义 声明时必须初始化 顶层const和底层const 底层const 顶层const 定义 指针和引用的复合类型的基本类型部分是常量 任意的对象是常量 拷贝操作 拷入拷出的对象必须都是相同的底层const，或者可以相互转换（非常量可以转为常量，反之不行） 不受影响 底层const和顶层const的实质理解是这样的： 对于一般对象，只存在顶层const 对于指针，由于指针包含了本身这个对象和它所指向的对象两个对象，所以指针本身的const称之为顶层const，指针指向的对象的const称之为底层const 对于引用，引用本身不是对象，所以只存在底层const constexpr和常量表达式常量表达式指的是在编译过程就能得到计算结果的表达式 声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化 一个constexpr指针的初始值必须为nullptr或者0，或者某个存储在固定地址的对象 指针和constexpr1constexpr int *q = nullptr // q是一个指向整数的常量指针，等同于 int *const q = nullptr constexpr可以把它所定义的对象置为顶层const。同时，constexpr指针既可以指向常量也可以指向非常量。但是当它指向一个变量名时，它的定义必须在函数体外 12345int j = 0;constexpr int i = 42; //i的类型时整型常量// i和j必须定义在函数体之外constexpr const int *p = &amp;i; // p是常量指针，指向整型常量iconstexpr int *p1 = &amp;j; // p1是常量指针，指向整数j 处理类型类型别名指针、常量和类型别名1234eg. typedef char *pstring; const pstring cstr = 0; // cstr是指向char的常量指针 类似于char *const cstr = 0;而不是直接带入的const char *cstr const pstring *ps; // ps是一个指针，指向了一个对象，该对象是一个指向char类型的常量指针 总之不能直接将typedef带入进行理解。 auto类型说明符和decltype类型指示符c++11新标准引入的新的类型说明符auto和类型指示符decltype。 auto 让编译器通过初始值来推算变量的类型 auto定义的变量必须具有初始值 auto能在一条语句中声明多个变量，但是该语句中所有变量的初始基本数据类型必须一致。 decltype 编译器分析表达式并得到它的类型，但是不计算表达式的值 decltype如果使用的是一个不加括号的变量，则得到的结果就是该变量的类型 decltype如果使用的是一个加括号的变量 ，则编译器会把它当作表达式，得到的结果是引用类型 auto decltype 相同 都可以通过编译器获得变量类型 都可以通过编译器获得变量类型 不同 1. 跟引用相关时，auto采用的是引用对象的值2. 在处理顶层const时，auto会自动忽略掉顶层const，只保留底层const3. 跟解引用*相关时，auto采用的是对对象地址进行解引用后的值 1. 跟引用相关时，decltype采用的是对象的引用2. 在处理顶层const时，decltype会保留顶层const3. 跟解引用相关时，decltype采用的是对对象的引用","tags":[{"name":"C++","slug":"C","permalink":"https://zijian.wang/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zijian.wang/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"ROS源代码阅读——publish底层实现部分","date":"2020-10-18T12:09:30.000Z","path":"2020/10/18/ROS源代码之Publish底层实现/","text":"在之前对ROS的源码的学习中，基本弄清楚了ROS的topic通信方式中，节点发布/订阅的机制和原理，可以说解释了节点与master之间的交流方式。但是对于节点与节点之间通信的具体过程，却一笔带过，所以这次通过再次阅读这部分源码，来明确节点在advertise之后，注册完成之后，publish消息时底层通信的逻辑和形式。 本次源码阅读主要通过dfs的方式来进行。首先是ROS wiki提供的发布者节点发布信息时的最表层调用： 12345678910111213141516171819202122232425262728#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;#include &lt;sstream&gt;int main(int argc, char **argv)&#123; ros::init(argc, argv, &quot;talker&quot;); ros::NodeHandle n; ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;, 1000); ros::Rate loop_rate(10); int count = 0; while (ros::ok()) &#123; std_msgs::String msg; std::stringstream ss; ss &lt;&lt; &quot;hello world &quot; &lt;&lt; count; msg.data = ss.str(); ROS_INFO(&quot;%s&quot;, msg.data.c_str()); chatter_pub.publish(msg); ros::spinOnce(); loop_rate.sleep(); &#125; return 0;&#125; 可以看到，其中调用publish函数的正是之前我们使用nodehandle对象的advertise注册发布者时所返回的publisher类对象chatterpub,传入的参数时我们自定义的msg类型。我们在roscpp包中寻找相关的代码，如下是在publisher.h中所定义的两种重载的模板函数，分别用来应传入参数类型不同的的两种情况。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960······//共享指针类型的引用传参 template &lt;typename M&gt; void publish(const boost::shared_ptr&lt;M&gt;&amp; message) const &#123; using namespace serialization; if (!impl_) &#123; ROS_ASSERT_MSG(false, &quot;Call to publish() on an invalid Publisher&quot;); return; &#125; if (!impl_-&gt;isValid()) &#123; ROS_ASSERT_MSG(false, &quot;Call to publish() on an invalid Publisher (topic [%s])&quot;, impl_-&gt;topic_.c_str()); return; &#125; ROS_ASSERT_MSG(impl_-&gt;md5sum_ == &quot;*&quot; || std::string(mt::md5sum&lt;M&gt;(*message)) == &quot;*&quot; || impl_-&gt;md5sum_ == mt::md5sum&lt;M&gt;(*message), &quot;Trying to publish message of type [%s/%s] on a publisher with type [%s/%s]&quot;, mt::datatype&lt;M&gt;(*message), mt::md5sum&lt;M&gt;(*message), impl_-&gt;datatype_.c_str(), impl_-&gt;md5sum_.c_str()); SerializedMessage m; m.type_info = &amp;typeid(M); m.message = message; // 这里使用ref函数是给bind绑定的参数传入ref()引用包装类型，使参数为引用传递； // 使用bind应该是为了把message绑定给serializeMessage publish(boost::bind(serializeMessage&lt;M&gt;, boost::ref(*message)), m); &#125;// M类型的引用传参 泛型 template &lt;typename M&gt; void publish(const M&amp; message) const &#123; using namespace serialization; namespace mt = ros::message_traits; if (!impl_) &#123; ROS_ASSERT_MSG(false, &quot;Call to publish() on an invalid Publisher&quot;); return; &#125; if (!impl_-&gt;isValid()) &#123; ROS_ASSERT_MSG(false, &quot;Call to publish() on an invalid Publisher (topic [%s])&quot;, impl_-&gt;topic_.c_str()); return; &#125; ROS_ASSERT_MSG(impl_-&gt;md5sum_ == &quot;*&quot; || std::string(mt::md5sum&lt;M&gt;(message)) == &quot;*&quot; || impl_-&gt;md5sum_ == mt::md5sum&lt;M&gt;(message), &quot;Trying to publish message of type [%s/%s] on a publisher with type [%s/%s]&quot;, mt::datatype&lt;M&gt;(message), mt::md5sum&lt;M&gt;(message), impl_-&gt;datatype_.c_str(), impl_-&gt;md5sum_.c_str()); SerializedMessage m; publish(boost::bind(serializeMessage&lt;M&gt;, boost::ref(message)), m); &#125;······他们最终都调用的publish函数在publisher.cpp中实现，具体如下：1234567891011121314151617181920 ········// publish函数void Publisher::publish(const boost::function&lt;SerializedMessage(void)&gt;&amp; serfunc, SerializedMessage&amp; m) const&#123; // impl是否存在 if (!impl_) &#123; ROS_ASSERT_MSG(false, &quot;Call to publish() on an invalid Publisher (topic [%s])&quot;, impl_-&gt;topic_.c_str()); return; &#125; // impl是否可用 if (!impl_-&gt;isValid()) &#123; ROS_ASSERT_MSG(false, &quot;Call to publish() on an invalid Publisher (topic [%s])&quot;, impl_-&gt;topic_.c_str()); return; &#125; // topicManager的单例调用publish TopicManager::instance()-&gt;publish(impl_-&gt;topic_, serfunc, m);&#125; ···········其中的impl是publisher类在传参构造时的生成一个内部类对象，一般是由nodehandle类中的advertise函数，获取到ops的相关信息并传进来生成的impl对象。也就是说在注册成功后才会存在的一个对象。显然之后，Publisher.publish()函数让TopicManager的唯一实例调用了它的publish方法，我们在TopicManger.h函数中找到了相关代码，这也是一个模板函数，将message绑定给serializeMessage后，将topic、bind、m传给后面的具体实现函数12345678910········ template&lt;typename M&gt; void publish(const std::string&amp; topic, const M&amp; message) &#123; using namespace serialization; SerializedMessage m; publish(topic, boost::bind(serializeMessage&lt;M&gt;, boost::ref(message)), m); &#125;········具体实现函数在topicmanager.cpp中。大概如我注释写的那样的流程。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566······// 发布消息void TopicManager::publish(const std::string&amp; topic, const boost::function&lt;SerializedMessage(void)&gt;&amp; serfunc, SerializedMessage&amp; m)&#123; // 递归互斥量，允许多次加锁在统一线程内 boost::recursive_mutex::scoped_lock lock(advertised_topics_mutex_); // 是否shutdown if (isShuttingDown()) &#123; return; &#125; // 寻找publication是否已注册 PublicationPtr p = lookupPublicationWithoutLock(topic); // 当publication有订阅者或者有latch属性，就执行下列代码 if (p-&gt;hasSubscribers() || p-&gt;isLatching()) &#123; ROS_DEBUG_NAMED(&quot;superdebug&quot;, &quot;Publishing message on topic [%s] with sequence number [%d]&quot;, p-&gt;getName().c_str(), p-&gt;getSequence()); // Determine what kinds of subscribers we&#x27;re publishing to. If they&#x27;re intraprocess with the same C++ type we can // do a no-copy publish. // 确认我们要发布给的订阅者是什么类别，如果是进程内的，并且使用者相同的c++类型，我们就可以进行no-copy模式的publish // 这里定义两个标志nocopy和serialize bool nocopy = false; bool serialize = false; // 如果msg的指针已经有了，而且我们有他的类型我们就可以使用no-copy的publish，否则我们就要进行序列化了 // We can only do a no-copy publish if a shared_ptr to the message is provided, and we have type information for it if (m.type_info &amp;&amp; m.message) &#123; // 注意这里表面传值，实际是引用传参，会修改serialize和nocopy的值， p-&gt;getPublishTypes(serialize, nocopy, *m.type_info); &#125; else &#123; serialize = true; &#125; // 如果nocopy为false，就说明publish的消息没有进程内同c++的订阅者，我们就要reset他的msg，并初始化type_info ？ if (!nocopy) &#123; m.message.reset(); m.type_info = 0; &#125; // 如果序列化为true，并且p设置了latch属性，就设置msg，进行序列化 if (serialize || p-&gt;isLatching()) &#123; SerializedMessage m2 = serfunc(); m.buf = m2.buf; m.num_bytes = m2.num_bytes; m.message_start = m2.message_start; &#125; // 让publication执行发布命令 p-&gt;publish(m); // 如果我们序列化了msg，那么显然我们就要进行进程间通信，利用的就是poll_manager的信号槽机制，调用signal信号 // If we&#x27;re not doing a serialized publish we don&#x27;t need to signal the pollset. The write() // call inside signal() is actually relatively expensive when doing a nocopy publish. if (serialize) &#123; poll_manager_-&gt;getPollSet().signal(); &#125; &#125; //如果publication既没有订阅者，也没有latch属性，就执行自增序列就好，sequence一般是分布式系统的唯一id，这里我先猜测他是用来表明新的发布的吧。 else &#123; p-&gt;incrementSequence(); &#125;&#125;······解释一下其中的一些变量。 首先是topicmanager本身，该类是每一个节点用来管理topic通信的类，采用的设计模式是单例模式，也就是说在同一个节点，或者说进程中，仅有一个topicmanager类对象，他管理了所有的topic相关的函数调用，它的初始化是在init函数中实现的。 然后介绍下加锁的对象，是advertised_topic_mutex这个信号量，它的类型是递归互斥量，在同一个线程中，它是允许多次加锁的 Publication类是在ROS的topic通信中极其重要的类，PublicationPtr是一个智能指针（boost::make_shared）。Publication的每个对象，在单个节点中，可以理解为topic的存在，也就是说每一个publication类的对象，都对应了一个topic，在同一个节点的topic通信中，不同的publisher如果往同一个topic上发送消息，都是通过同一个pubication的对象来实现的。而之所以使用智能指针，就是为了实现内存的自动管理，方便pubication的自动销毁。lookupPublicationWithoutLock()函数就是在topicmanager已存在的pubication中寻找当前topic是否已经具有相应的publication,一般如果具有impl_，那就必然能找到publication，因为我们的impl_的各个属性（包括topic）都是在advertise注册时从publication那里得到的。 publication的latch属性。这个属性的含义是是否为订阅者保留最后一次发送的信息。如果该属性设为true，当新的订阅者订阅时，就必然会收到之前发布者所发布的最后一条消息。 接下来，在topicmanager函数中，会检测一下publish消息所要发送的对象是在进程内还是在进程间。我个人认为其中比较关键的就是getPublishType函数和publish函数这两部分。首先,这一段的逻辑首先讲清楚是这个样子的： 定义nocpy和serialize两个bool型变量，来分别代表有进程内同C++类型订阅者和进程间订阅者 调用publication的getPublishTypes()函数，该函数原型如下：void getPublishTypes(bool&amp; serialize, bool&amp; nocopy, const std::type_info&amp; ti);这里注意使用了引用传参，也就是说会将serialize和nocopy的值进行更改。 如果nocopy为false，就会执行第一个if判断的语句，将m进行一个初始化（存疑）操作，然后判断是否需要序列化，如果需要，就对它进行序列化的赋值操作。 使用publication的publish函数进行发布消息 判断是否进行了序列化，如果进行了，就调用pollSet的信号函数触发槽函数。我们先来dfs一下getPublishTypes()函数，首先是调用了publication类的函数123456789101112131415161718192021222324252627·····················/** * 得到publish的type，传入三个参数，是否序列化，是否无需拷贝，type_info * 这里调用了subscriberLink的getPublishTypes，得到它的serialize和nocopy，然后用一个或运算来返回给topicmanager是否需要进行nocopy和serialize */void Publication::getPublishTypes(bool&amp; serialize, bool&amp; nocopy, const std::type_info&amp; ti)&#123; boost::mutex::scoped_lock lock(subscriber_links_mutex_); V_SubscriberLink::const_iterator it = subscriber_links_.begin(); V_SubscriberLink::const_iterator end = subscriber_links_.end(); for (; it != end; ++it) &#123; const SubscriberLinkPtr&amp; sub = *it; bool s = false; bool n = false; // 这里的详细说明见下文 sub-&gt;getPublishTypes(s, n, ti); serialize = serialize || s; nocopy = nocopy || n; if (serialize &amp;&amp; nocopy) &#123; break; &#125; &#125;&#125;··················· 这里的sub是一个subscriberLink类的父类指针，该类本身没有实现getPublishTypes()函数，而是以虚函数的方式实现的，它的子类IntraProcessPSubscriberLink类也进行了实现，具体代码如下：virtual void getPublishTypes(bool&amp; ser, bool&amp; nocopy, const std::type_info&amp; ti) &#123; (void)ti; ser = true; nocopy = false; &#125;这是一个虚函数而不是纯虚函数，纯虚函数父类不会实现，只是在声明后加一个=0，如virtual void enqueueMessage(const SerializedMessage&amp; m, bool ser, bool nocopy) = 0;。虚函数一定会有一个自己的实现，在用父类指针进行调用函数时，实现了该函数的子类对象会调用自己的函数，没有实现该函数的子类对象会调用父类的函数，也就是说在这里，如果sub为transportPublisherLink对象，就会像上述代码一样，设置序列化为true，nocopy为false。否则，就会像下面的代码一样。1234567891011// 这里会调用subscription的的getPublisType函数来修改值void IntraProcessSubscriberLink::getPublishTypes(bool&amp; ser, bool&amp; nocopy, const std::type_info&amp; ti)&#123; boost::recursive_mutex::scoped_lock lock(drop_mutex_); if (dropped_) &#123; return; &#125; subscriber_-&gt;getPublishTypes(ser, nocopy, ti);&#125; 这里有一个很容易误会的地方就是subscriber_的类型，很容易以为她是subscription类，事实上，它是IntraProcessPublisherLinkPtr subscriber_定义的，所以实际这里调用了IntraProcessPublisherLink类中的方法123456789101112131415161718192021222324void IntraProcessPublisherLink::getPublishTypes(bool&amp; ser, bool&amp; nocopy, const std::type_info&amp; ti)&#123; boost::recursive_mutex::scoped_lock lock(drop_mutex_); // 如果连接已经dropped了，就全都false，无需序列化也无需查看是否nocopy直接return就好 // dropoed是IntraProcessPublisherLink的一个成员变量，表示当前link是否已经失效 if (dropped_) &#123; ser = false; nocopy = false; return; &#125; // parent_是父类PublisherLink定义的一个弱指针，指向intraprocessPublisher的所属subscription，所以这里实际是调用了subscription的这个函数，使用lock是因为weak指针的特性，只有使用lock才能短暂拥有对象。 SubscriptionPtr parent = parent_.lock(); if (parent) &#123; parent-&gt;getPublishTypes(ser, nocopy, ti); &#125; else &#123; // 如果parent不存在，就说明没有内部订阅类，序列化设置为true，nocopy设置为false ser = true; nocopy = false; &#125;&#125; 在这里首先会判断当前link是否dropped掉了，如果没有，那就说明还在订阅，就尝试获取它的parent，也就是订阅的subscription，如果存在，就调用subscription的getPublishType()函数，否则，就说明他没有进程内订阅，就直接设置序列化为真，nocopy为假就ok了。至于subscription类的函数实现如下:1234567891011121314151617181920212223// 遍历callback_队列，比较传进来的type_info是否和callback_中的相同，如果相同，就将nocopy设置为true，表示不需要进行序列化，否则就是serialize为true，需要序列化，直到两个参数都为turevoid Subscription::getPublishTypes(bool&amp; ser, bool&amp; nocopy, const std::type_info&amp; ti)&#123; boost::mutex::scoped_lock lock(callbacks_mutex_); for (V_CallbackInfo::iterator cb = callbacks_.begin(); cb != callbacks_.end(); ++cb) &#123; const CallbackInfoPtr&amp; info = *cb; if (info-&gt;helper_-&gt;getTypeInfo() == ti) &#123; nocopy = true; &#125; else &#123; ser = true; &#125; if (nocopy &amp;&amp; ser) &#123; return; &#125; &#125;&#125; callbacks_容器就是一个放置了CallbackInfo的容器，它包含了subscription所订阅的message的类型等消息。具体细节会在subscribe中进行讨论。接下来就调用了publication对象的publish函数，函数具体代码如下：1234567891011121314151617181920212223242526272829········void Publication::publish(SerializedMessage&amp; m)&#123; if (m.message) &#123; // 给subscriber_link_加上区域锁 boost::mutex::scoped_lock lock(subscriber_links_mutex_); // 遍历subscriber_links_,如果找到的subscriber_links_是进程内的，就直接enqueueMessage信息，遍历完之后进行message.reset(); V_SubscriberLink::const_iterator it = subscriber_links_.begin(); V_SubscriberLink::const_iterator end = subscriber_links_.end(); for (; it != end; ++it) &#123; const SubscriberLinkPtr&amp; sub = *it; if (sub-&gt;isIntraprocess()) &#123; sub-&gt;enqueueMessage(m, false, true); &#125; &#125; // m.message.reset(); &#125; // 如果buff有内容，就把m放入publish_queue中 if (m.buf) &#123; boost::mutex::scoped_lock lock(publish_queue_mutex_); publish_queue_.push_back(m); &#125;&#125;·········· 在这段代码中，可以看到他在检测publication所管理的subscriber_links是否是本进程内的，如果是的话，就会直接把message进行入队，然后这里虽然是一个SubscriberLinkptr指针对象调用的enqueueMessage，实际上在SubscriberLink类中这只是一个虚函数，具体实现是由IntraProcessSubscriberLink类和TransportSubscriberLink类实现的。我们先介绍前者的实现，具体代码是这个样子的：123456789101112void IntraProcessSubscriberLink::enqueueMessage(const SerializedMessage&amp; m, bool ser, bool nocopy)&#123; boost::recursive_mutex::scoped_lock lock(drop_mutex_); if (dropped_) &#123; return; &#125; ROS_ASSERT(subscriber_); // subscriber_的类型其实是IntralProcessPublisherLink，这里的声明误导性很强 subscriber_-&gt;handleMessage(m, ser, nocopy);&#125; 在这里最让人难受的就是subscriber_的理解，它的声明出现在intra_processSubscriber_link.h文件中。IntraProcessPublisherLinkPtr subscriber_可以这样理解，发布者向订阅者发布信息时，会publication会先从自己的订阅列表中找出在进程内的订阅者，然后就会让IntraProcessSubscriberLink对象来进行enqueueMessage操作，这个入队操作到下面实际又交给了IntraProcessPublisherLink对象调用handleMessage,它的实现代码如下：123456789101112131415161718void IntraProcessPublisherLink::handleMessage(const SerializedMessage&amp; m, bool ser, bool nocopy)&#123; boost::recursive_mutex::scoped_lock lock(drop_mutex_); if (dropped_) &#123; return; &#125; stats_.bytes_received_ += m.num_bytes; stats_.messages_received_++; SubscriptionPtr parent = parent_.lock(); if (parent) &#123; stats_.drops_ += parent-&gt;handleMessage(m, ser, nocopy, header_.getValues(), shared_from_this()); &#125;&#125; 显然到这里，m这个message就已经成功交给了SubscriptionPtr，接下来就是Subscription来调用handleMessage来进行反序列化和进行回调函数的调用了。暂停一下，我们回头看看进程间通信又是如何进行到这一步的。在上面我们进行publication类的publish时，进程内通信直接进行了enqueueMessage，之后并没有结束，我们判断message如果buff不为空，就会让他把信息放入publish_queue_中，这是一个在publication中声明的队列。紧接着我们判断message是否进行了序列化，如果进行序列化，显然就要进行进程间通信，就调用poll_manager_的单例，使用getPollSet()函数获得PollSet对象，并调用signal()函数，这个函数是用来搞pipe的，具体细节我不太领会，需要在学习一些Unix网络编程的知识。我们看一下message 放入了publis_queue_后是如何发送给其他进程间的subscriber的。我们可以通过SourceTrail这个工具清楚看出，另一个使用了了publis_queue_的函数正是publication中的processPublishQueue函数。这个函数是由TopicManager类的processPublishQueues函数调用的，TopicManager类的processPublishQueues函数就是一个循环，会把当前节点的所有publication，调用processPublishQueue函数，进行处理，发布信息。具体内容如下：123456789101112131415·········· // 处理publish队列void TopicManager::processPublishQueues()&#123; boost::recursive_mutex::scoped_lock lock(advertised_topics_mutex_); // 遍历已发布节点，对每个publication调用processPublishQueue函数。 V_Publication::iterator it = advertised_topics_.begin(); V_Publication::iterator end = advertised_topics_.end(); for (; it != end; ++it) &#123; const PublicationPtr&amp; pub = *it; pub-&gt;processPublishQueue(); &#125;&#125;·········· 而它的调用，则是在topicManager的start函数中就使用了【注意是使用而不是调用】，topicmanager的实例的初始化就是由start函数进行的，而它的start也正是在整个节点进行初始化时，由init()函数调用的ros::start()调用的。我们到topicManager的start函数中去看，看到了processPublishQueue()是如何进行使用的：12// 让poll_manager单例监听processPublishQueues函数 poll_manager_-&gt;addPollThreadListener(boost::bind(&amp;TopicManager::processPublishQueues, this)); 可以看到在这里他是通过pollManager的单例对象来进行使用的，这个函数是一个监听函数，它的内部实现是这个样子的：12345boost::signals2::connection PollManager::addPollThreadListener(const VoidFunc&amp; func)&#123; boost::recursive_mutex::scoped_lock lock(signal_mutex_); return poll_signal_.connect(func);&#125; 这里的poll_signal_是一个boosts::signal2::signal对象，这个signal2实现了线程安全的信号槽机制，也就是说，我们通过connect（）函数可以将任何一个函数作为参数绑定到signal定义的对象上（这里时poll_signal_),我们可以绑定任意多个函数，作为槽，然后我们可以通过poll_signal_()这个函数，来触发和它绑定的所有函数。这里其实就是将processPublishQueues函数和这个信号进行了绑定，那么这个信号量是在哪里触发的呢？12345678910111213141516171819void PollManager::threadFunc()&#123; disableAllSignalsInThisThread(); while (!shutting_down_) &#123; &#123; boost::recursive_mutex::scoped_lock lock(signal_mutex_); poll_signal_(); &#125; if (shutting_down_) &#123; return; &#125; poll_set_.update(100); &#125;&#125; 在这个threadFunc()函数中，我们调用了poll_signal_信号量，从而触发了和他绑定的一系列函数，从SourceTrail工具我们可以看到有若干函数和他绑定。但重要的时，这个threadFunc函数又是在何时调用的呢？12345void PollManager::start()&#123; shutting_down_ = false; thread_ = boost::thread(&amp;PollManager::threadFunc, this);&#125; 是在PollManager初始化时候和一个线程绑定了。也就是说我们在初始化Nodehandle之后，就建立了一个线程，线程轮转，就是在进行信号触发，然后执行processPublishQueues函数。我们跟着processPublishQueues函数向下看，我们可以看到publication的processPublishQueues函数是这个样子的：123456789101112131415161718192021222324252627void Publication::processPublishQueue()&#123; V_SerializedMessage queue; &#123; boost::mutex::scoped_lock lock(publish_queue_mutex_); if (dropped_) &#123; return; &#125; // 把publish_queue_中的信息全部放到queue中取，并清空publish_queue queue.insert(queue.end(), publish_queue_.begin(), publish_queue_.end()); publish_queue_.clear(); &#125; // 如果queue为空，则返回 if (queue.empty()) &#123; return; &#125; // 把queue中的所有消息，入队 V_SerializedMessage::iterator it = queue.begin(); V_SerializedMessage::iterator end = queue.end(); for (; it != end; ++it) &#123; enqueueMessage(*it); &#125;&#125; 这里同样有一个enqueueMessage，这个是由publication本身实现的123456789101112131415161718192021222324252627282930313233343536373839bool Publication::enqueueMessage(const SerializedMessage&amp; m)&#123; boost::mutex::scoped_lock lock(subscriber_links_mutex_); // 如果publication已经drop了。返回false if (dropped_) &#123; return false; &#125; ROS_ASSERT(m.buf); //自增序列 uint32_t seq = incrementSequence(); if (has_header_) &#123; // If we have a header, we know it&#x27;s immediately after the message length // Deserialize it, write the sequence, and then serialize it again. namespace ser = ros::serialization; std_msgs::Header header; ser::IStream istream(m.buf.get() + 4, m.num_bytes - 4); ser::deserialize(istream, header); header.seq = seq; ser::OStream ostream(m.buf.get() + 4, m.num_bytes - 4); ser::serialize(ostream, header); &#125; // 遍历subscriberLinks，分别将message放入subscriberlink队列 for(V_SubscriberLink::iterator i = subscriber_links_.begin(); i != subscriber_links_.end(); ++i) &#123; const SubscriberLinkPtr&amp; sub_link = (*i); sub_link-&gt;enqueueMessage(m, true, false); &#125; // 如果有latch属性，把m赋值给last_message if (latch_) &#123; last_message_ = m; &#125; return true;&#125; 这里虽然同样有一个subscriberLink指针调用了enqueueMessage函数，但是实际上确实transportSubcriberLink对象进行调用的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546void TransportSubscriberLink::enqueueMessage(const SerializedMessage&amp; m, bool ser, bool nocopy)&#123; (void)nocopy; // 如过ser为0,说明是进程内通信，说明不符，直接返回 if (!ser) &#123; return; &#125; &#123; boost::mutex::scoped_lock lock(outbox_mutex_); // 得到publication的最大队列 int max_queue = 0; if (PublicationPtr parent = parent_.lock()) &#123; max_queue = parent-&gt;getMaxQueue(); &#125; ROS_DEBUG_NAMED(&quot;superdebug&quot;, &quot;TransportSubscriberLink on topic [%s] to caller [%s], queueing message (queue size [%d])&quot;, topic_.c_str(), destination_caller_id_.c_str(), (int)outbox_.size()); // 看队列满了没有 outbox_是一个存放序列化信息的队列，如果满了，就会把队列最前面的信息pop掉，并更新queue_full_标志 if (max_queue &gt; 0 &amp;&amp; (int)outbox_.size() &gt;= max_queue) &#123; // if (!queue_full_) &#123; ROS_DEBUG(&quot;Outgoing queue full for topic [%s]. &quot; &quot;Discarding oldest message&quot;, topic_.c_str()); &#125; outbox_.pop(); // toss out the oldest thing in the queue to make room for us queue_full_ = true; &#125; else // 没有满就继续标志false &#123; queue_full_ = false; &#125; // 放入消息 outbox_.push(m); &#125; // 先不立即写入，因为需要去函数里设置一些标志 startMessageWrite(false); // 更新一些状态信息 stats_.messages_sent_++; stats_.bytes_sent_ += m.num_bytes; stats_.message_data_sent_ += m.num_bytes;&#125; 在这里主要利用outbox_队列来维护要发的信息，queue_full_来标志队列满了没有。然后startMessageWrite函数来执行具体往connection中写数据的过程1234567891011121314151617181920212223242526// 开始向connection中写信息void TransportSubscriberLink::startMessageWrite(bool immediate_write)&#123; boost::shared_array&lt;uint8_t&gt; dummy; SerializedMessage m(dummy, (uint32_t)0); &#123; boost::mutex::scoped_lock lock(outbox_mutex_); if (writing_message_ || !header_written_) &#123; return; &#125; // 如果outbox不为空，就获得信息，并且把writing_message标志置为true，然后pop掉outbox队列中的信息 if (!outbox_.empty()) &#123; writing_message_ = true; m = outbox_.front(); outbox_.pop(); &#125; &#125; // connection具体过程。 if (m.num_bytes &gt; 0) &#123; connection_-&gt;write(m.buf, m.num_bytes, boost::bind(&amp;TransportSubscriberLink::onMessageWritten, this, _1), immediate_write); &#125;&#125;","tags":[{"name":"研究方向","slug":"研究方向","permalink":"https://zijian.wang/tags/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://zijian.wang/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"嵌入式实时操作系统课程知识点复习","date":"2018-06-30T07:05:49.000Z","path":"2018/06/30/嵌入式RTOS复习/","text":"上学期嵌入式实时操作系统对PPT上的知识点的一个汇总 最后真就一个都没考 嵌入式系统体系结构回顾基本概念DSP：数字信号处理处理器 可以进行累乘累加，区别于普通的CPU，一般的CPU的运算器是无法直接进行累乘操作的 CPU包括：运算器、控制器、寄存器。 NOC和SOC：分别是片上网络和片上系统 三大总线： 地址总线、数据总线、控制总线 PC： 程序计数器。系统复位后指向某一点区域，然后取值、译码、执行。然后PC寄存器内容会增加一个单位指向下条指令 CPU的架构有 冯诺依曼架构，cpu通过三大总线和同时存储了数据和指令的存储联系 哈佛结构，六个总线，三个负责指令，三个负责数据，指令数据分开存放，取址就不会受到数据的干扰 改进的哈佛结构，总线分开，数据和指令分区域存放。 FPU：浮点数单元 MPU：内存保护单元，监控在CPU和主存之的事务，并且在检测到访问违规时发出警报。主要目的是防止程序访问为分配给它的内存。 MMU：翻译虚拟地址到主存中的物理地址 Microprocessor Unit（MPU）：微处理器单元。有很多种类，除了CPU外，FPU、MMU、cache都是可选项。为什么不要cache，因为cache可能会影响干扰RTOS的实时性，所以嵌入式RTOS一般会关掉cache，以保证系统的确定性。 Microcontroller Unit（MCU）：微控制器单元。其中FPU、MPU为可选项。由于没有MMU，所以无法跑大型OS GPU（Graphics Processing Unit）： 图形处理单元。有很多core NPU/TPU：用来加速神经网络运算 FPGA：现场可编程门阵列。一种可编程硬件 NVIC：嵌套式向量中断控制器。确定中断优先级、提高MCU或CPU性能并减少中断延迟的方法。 时钟振荡器：一种物理器件，又名晶振。可以作为频率源，产生时钟信号 锁相环（phase locked loop）：利用相位同步产生的电压，去调谐压控振荡器以产生目标频率的负反馈控制系统。作用是使得电路上的时钟和某一外部时钟的相位同步。 RAM（Random access memory）：常用的时SRAM和DRAM。前者更快动态功率更少，但是成本更高。一般而言，SRAM多作为CPU的缓存，DRAM作为内存 SRAM：有一定数据持久能力，但依然在断电后会最终丢失 DRAM：需要外部存储器刷新电路，定期重写电容器中的数据。这是一种易失性存储器，断电后会迅速丢失数据 SDRAM：同步动态随机存取存储器，外部引脚接口的操作由外部提供的时钟信号协调，DDR3 DDR4···都是这种 SGRAM&amp;HBM：超级计算器、高性能图形加速器、网络设备使用的高性能RAM ROM：只读内存 。一种非易失性存储器，一般无法进行电子修改，一般用于存储很少更改的软件，即固件 EEPROM：代表电可擦除可编程只读存储器，一种非易失性存储器，允许单个字节被擦除或重新编程 嵌入式实时操作系统基础概念任务拥有CPU资源（寄存器 堆栈）正在执行的简单程序，类似于进程的概念，可以申请资源，一般是周期性的，是一个无限循环，拥有就绪、运行、挂起三种状态。 就绪状态指任务获得执行优先级，等待OS安排开始执行（还没进入死循环） 运行状态指任务执行过程（正在死循环） 挂起状态指任务结束（跳出死循环，释放资源） 任务的拥有动态性（拥有生命周期）、并发性（单核交替——逻辑并发，中断服务例程辅助，假并发；多核同时）、独立性（任务是资源分配的基本单位，MCU上多使用栈资源，因为有的RTOS没有堆，这一块应该是是为了防止复杂的内存分配算法降低实时性）、异步性（任务按异步方式运行） 任务上下文任务上下文就是指一个未运行任务的状态，包括堆栈指针、计数器、内存字段和通用寄存器。 tips:某些编译器会和OS、CPU配合将某些寄存器定为专门存放中间值，那么就不需要在任务切换时进行内存交换，这是一种运行时的优化 调度调度即决定任务运行次序的机制。主要有抢占式、非抢占式。 多数实时内核的调度实际上是基于优先级调度的多种方法的复合。 其中抢占与否和实时画不上等号，非抢占式调度的划分时间片法，如果能很好地划分时间片，那么对于整个系统来说抖动也很小，也是可以接受的实时调度。 基本的调度算法先来先服务、最短周期优先、优先级法、轮转法、多级队列法、多级反馈队列 优先级法是最常用最有效的调度方法（FreeRTOS和ucos都采用的这种调度方法），分为抢占式和非抢占式 先来先服务法简单易行，性能较差，cpu会先运行处于就绪队列之首的任务。这种方法下可以想到我们的任务不再是while死循环，而是不断再创建一次 轮转法多用在windows和Linux中，每次从有序队列头部选出一任务，并分配定长时间片。时间片内未处理完的任务会在时间片用尽后重新送到队列尾部。凡新到达的任务会被放在队列尾部。 最短周期优先：谁执行周期最短先执行谁（可能会产生进程饥饿） 多级反馈队列：设置多个就绪队列，每个队列对应一种优先级。CPU先执行高优先级队列中的任务。各就绪队列中的 进程运行时间片不同，高优先级队列时间片小，低优先级队列时间片大（可以理解为对其抢占到cpu的概率小的补偿），UNIX和windowsNT采用的就是这种方法。 一般而言，桌面系统，多采用时间片分片的调度，RTOS多采用抢占式调度。 调度延迟调度延迟，指当一个事件从引起更高优先级任务就绪到开始运行之间的时间。表示的是系统的反应能力。 一般会存在三种调度延迟 直接创建新任务并执行——这种事调度延迟最小的。 触发中断，由中断服务例程直接创建并执行新任务 触发中断，由中断服务例程创建任务，回到原任务后执行新任务。——这种是调度延迟最长的。 优先级优先级即表示任务的轻重缓急，每个任务会有自己的优先级。 优先级分为静态优先级和动态优先级，区别在于是否可变 基于优先级的系统会出现优先级倒置的问题， 这实际上是资源占用导致的。 优先级倒置当一个任务等待比它优先级低的任务释放资源而被阻塞时，就发生了优先级倒置。 解决方法是优先级继承 优先级继承优先级继承强制命令低优先级的任务继承与之共享资源而被挂起的任意高优先级任务的优先等级，使较低优先级任务尽快执行，尽快释放高优先级所需要的资源。 代码临界区不可分割的一段代码。一旦执行不能被中断 实现方法有两种： 屏蔽中断，代码执行前关中断，执行后开中断，只能用于单核情形。但如果过于频繁开关中断，也会影响性能 通过信号量实现。 信号量多任务环境常用的协调各个任务来使用公共资源的指示标志。查询信号量来确定公共资源的使用情况，符合要求可以使用，不然就要等待。使用资源的任务在使用完毕后要释放信号量。 任务间通信多任务系统中，任务之间存在相互制约的关系，任务之间需要交换信息，这就是任务间通信 有两种任务间通信 控制信息传送 批量数据传送 任务间通信方式有信号量、消息邮箱（消息队列）、管道、共享内存、套接字等。 任务间通信在微内核操作系统中非常常见，各内核会构建自己的容器，进行互相通信。 未来发布订阅机制在这方面可能会有更进一步的应用，比如分布式系统的DDS，不过是是分布式系统一般通过网络、外部总线进行任务间通信，无法实现0拷贝。 信箱信箱在两个任务之间，使用步骤是首先创建信箱，然后任务一向信箱发送消息，任务二会查询信箱状态，从而从信箱二中接收消息 队列队列是一种非阻塞式同步，过程跟信箱类似，但是具有强序列关系。 一般数据队列用于数据缓存，可以用来平衡速率不同的两个部件，使快速部件不需要等待慢速部件 互斥控制多任务对共享数据顺序访问的同步机制。方法主要有开关中断、使用硬件指令、使用信号量。 目前处理器主要有主从通信、总线通信、内存通信 未来处理器可能会靠网络通信、点对点通信 抢占当前执行任务可被另外任务打断的任务调度机制。 FreeRTOS代码主要负责三个区块——任务、通讯、硬件接口，代码量比为5：4：0.6 任务任务函数返回值为void且不允许返回，不允许有一条return语句 FreeRTOS的任务调度 通过对任务设置优先级进行优先级抢占式调度，拥有下述特性 每个任务都赋予了一个优先级 每个任务都可以存在一个或多个状态 在任何时候都只有一个任务可以处于运行状态 调度器总是在所有处于就绪态的任务中具有最高优先级的任务来执行。 一般FreeRTOS会存在一个任务在其他所有任务都处于阻塞态时运行，也就是空闲任务，一个非常短小的循环，它拥有最低优先级（优先级0），就不会妨碍更高优先级的任务进入运行态。空闲任务会通过钩子函数，直接在空闲任务中添加应用程序相关功能。空闲任务钩子函数有很多功能，比如在没有应用能力需要处理的时候，将系统配置为省电模式。空闲任务钩子函数绝对不能阻塞或挂起，且一定要能尽快返回，因为空闲函数负责回收内核资源，不尽快返回无法进行回收工作。 FreeRTOS对于相同优先级的任务，会划分时间片轮流执行。 FreeRTOS任务有运行、阻塞、挂起、就绪四个状态。 队列FreeRTOS通过队列来解决通信与同步机制，队列是具有自己独立权限的内核对象，不属于任何任务 FreeRTOS中队列有两套函数，分别用于普通情况和中断服务。不可混用。 队列可以通过yeild（taskYIELD()）立即进行任务切换不必等到时间片耗尽. 延迟中断处理在嵌入式实时领域，一般都不会让中断服务程序运行时间过长，否则会大大降低系统的实时性。我们可以让中断服务程序作为触发者，触发其他函数（被称为延迟处理任务）执行任务，这样就增强了实时性，一般这种手段通过二值信号量的手段来实现。 延迟处理任务会对一个信号量执行take调用，进入阻塞态等待中断发生，中断发生后，ISR（中断服务例程）会对该信号量进行give操作，当ISR退出后，该延迟处理任务就会由阻塞态转为运行态，进行相应处理，处理完后会再次尝试获取信号量，从而进入阻塞态，等待下次中断发生。 计数信号量二值信号量会在中断多次触发时，存在丢失后面的中断事件的可能，所以引入计数信号量，计数信号量代替二值信号量，有事件计数和资源管理两种用法。 共享资源的处理多任务系统当一个任务在使用某个资源时，如果没完全结束对资源的访问，就被切除运行态，就会使得资源处于非一致，不完整的状态，此时其他任务或中断访问资源，就会出现数据损坏或者其他错误。 函数重入一个函数可以安全地被多个任务调用，或者在任务和中断中均可调用，那么该函数是可重入的。 每个任务单独维护自己的的栈空间和自身在的内存寄存器组的值，如果一个函数除了访问自己栈空间上分配的数据或内核寄存器中的数据外，不会访问其他任何数据，则这个函数是可重入的。 互斥FreeRTOS有临界区（必须只具有很短的时间，否则会反过来影响中断响应）、挂起（锁定）调度器（只防止任务打断，中断是使能的）、互斥量（特殊的二值信号量，互斥的信号量必须归还，同步的信号量同步后丢弃）、守护任务（对某资源具备唯一所有权，其他任务要访问该资源只能间接通过守护任务提供的服务进行访问，这可以避免优先级反转和死锁问题） 内存管理任务、队列或信号量被创建时，内核需要进行动态内存分配。一般内存分配调用的是malloc()函数和free()函数，面临的问题有下述六条 小型嵌入式系统不支持这两个函数 两个函数实现需要的代码空间很大 两个函数不具备线程安全特性 两个函数具有不确定性，每次调用时间开销不同 会产生内存碎片 链接器配置会复杂 FreeRTOS有自己的内存分配算法，有多种实现范例，现在已经从heap1~heap4。PPT上只介绍了三种。heap1没有free，面向不需要删除任务、队列、信号量的应用程序，其确定性最强。heap2允许内存释放，但是不会把相邻空闲块合并，所以会产生内存碎片，因此适用于重复创建和删除具有相同栈空间人物的应用程序。heap3调用了标准的malloc和free，但是通过挂起调度器保证了线程安全。 RTOS网络通讯LwIP用于嵌入式系统的开源TCP/IP协议栈。轻型IP协议，实现重点在保持TCP协议主要功能基础上减少对RAM的占用，非常适用于小型嵌入式系统 OSI标准模型七层模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 LwIP的软件体系结构 LwIP是以4层TCP/IP模型(从下至上分别是网络接口层、网际层、运输层和应用层)为参照实现TCP/IP协议簇的，，同时提供几个函数作为协议的入口点。没有严格按照OSI分层方式实现协议簇。 一种比较松散的通讯机制，通过共享内存实现应用层与底层协议族之间的通信。 拥有独特的缓冲机制，可以更加有效利用缓冲区。尽量避免内存复制，减少性能损失 模块化设计实现 LwIP的进程模型TCP/IP协议族的进程模型指的是采用何种方法把系统分成不同进程。 常见的进程模型有两种： 每个协议作为一个独立进程 该模型必须符合协议的每一层，协议层之间通过指定的方式进行通讯。 优点是每一种协议可以独立参与系统运行，且实现简单，便于理解和调试 缺点是跨层传递必须产生进程切换和内存复制。这一缺点极大影响整体性能，为嵌入式系统不能接受。 协议栈作为一个内核，只占据一个进程 协议栈在操作系统内核中，应用程序通过系统调用与协议栈通讯。 缺点是层次不清，不好理解 LwIP的进程模型比较灵活，可以所有协议驻留在一个进程，以便独立于内核之外，也可以根据协议层次结构创建多个进程，但是各个进程之间只传送尽可能少的必要信息，没有引入额外的内存复制。 LWIP的函数调用关系为了避免内存复制，LwIP采用基于回调函数的设计方法 。 优点时提高了整体性能 缺点是使整个软件体系显得略微复杂 回调函数是一种异步的设计方法，是事件驱动式的。 协议层的调用TCP/IP协议栈是按功能层组织的，每一层都为上一层提供服务，并使用下一层提供的服务。在4层TCP/IP模型中，从下至上依次是网络接口层、网际层、运输层和应用层 网络接口层 较高协议与局域网接口的地方。 收到数据帧时，该层负责判断数据帧的协议类型（IP还是ARP）， 如果是ARP协议（地址解析协议，将ip地址转换为MAC地址），则本层可以自行应答 如果是IP协议，则传递给上层网际层 发送数据帧时，该层会调用netif-&gt;output，完成真正的数据发送 网际层 负责网间寻址、数据封装、路由选择、错误处理和诊断等。典型协议有IP协议和ICMP协议 从下层网络接口层接收到IP数据报，仅从处理。根据IP数据报中的协议字段，决定是否传给上层 如果是ICMP协议，本层的函数会被调用 其他大多应该传给上层 当有数据需要从网际层发送出去，会先找到合适的网络接口（ip_route）再发送出去（ip_outpu_if） 传输层 负责在网际设备之间传输数据，有可靠或者不可靠两种方式，也就是TCP、UDP传输 当下层网际层传上来数据时，根据类型不同（TCP、UDP）调用不同函数进行处理。处理后提交给上层应用层。 当上层发送数据时，选择调用函数进行数据处理，然后再调用其他函数将数据交给下层。 应用层 用户的应用所运行的地方。 用户发送数据时，LwIP根据类型调用下层运输层的发送函数 用户接受数据同样由LwIP调用下层接收函数送达。 典型模块的跨层调用一般对于某一个协议来说，只隶属于某一个层次（ARP除外）。但也会有其他层次调用该协议的有关函数。该协议一般也会主动调用其他层次的有关函数。 IP模块：实现了大部分基本功能，能够发送、接收以及转发信息包 ICMP模块：由ip_input函数收到，转交给icmp_input解码 UDP模块 TCP模块 TCP数据的发送过程一般是由应用层发起的，接受过程由网络接口层发起 IwIP的pbufpbuf时LwIP信息包的内部表示，pbuf结构既支持动态内存分配以保存信息报内容，又支持让信息包数据驻留在静态存储区。 pbuf由四种类型：PBUF_RAM、PBUF_ROM、PBUF_REF、PBUF_POOL。 PBUF_RAM：在实现划分好的内存堆栈中分配，用于存放应用程序动态产生的数据 PBUF_ROM: PBUF_ROM类型的pbuf的payload指针指向不由协议栈管理的外部存储区，如应用程序管理的存储器为用户数据分配的缓存。同时由于应用程序交付的数据不能改动，所以动态分配一个PBUF_RAM来装载协议首部，添加到PBUF_ROM的前面 PBUF_REF：和PBUF_ROM非常类似，都可以实现数据的零拷贝。当发送数据需要排队时，针对REF类型的pbuf，LwIP会在数据分组排队时为pbuf分配缓存，并将引用的应用程序的数据拷贝到分配的缓存中，这样应用程序被引用数据的存储区域能被释放。 PBUF_POOL: 固定容量的pbuf，由宏定义指定。主要用于网络设备驱动层，因为分配操作可以快速完成。 一般来说，收到的pbuf是PBUF_POOL类型，发送出的pbuf是PBUF_ROM或者PBUF_RAM类型。 IwIP的内存管理（这块太多了，其实就是在讲四种pbuf的内存管理相关的函数啥的，感觉也考不到这么细，不写了）LwIP的内存区域主要用于装载待接收和发送的网络数据分组。分组交付或发送完毕后，协议栈会对缓存进行回收利用。 协议栈分配的缓存必须能容纳各种大小的报文。 PBUF_RAMLwIP协议栈会首先从系统内存中开辟一块连续的静态存储区域，用于PBUF_RAM，同时协议栈还定义了一个比较小的结构体mem，放在内存分配块顶层保存内存分配记录。 啊吧啊吧啊吧（这块太多了，其实就是在讲四种pbuf的内存管理相关的函数啥的，感觉也考不到这么细，不写了）······· LwIP移植啊吧啊吧啊吧（同样讲的是LwIP在ucosII的具体移植，代码相关，不介绍了） EtherCAT实时以太网路背景现场总线技术：全数字通信代替模拟传播。目前存在的不足有下述几点 无统一标准 不同总线不兼容，无法实现透明信息互访、信息无缝集成 专用实时通信网络，成本较高 速度较低，支持应用有限，不便于和因特网信息集成 以太网技术：通用性号、低成本、高效率、高可靠性、稳定性好。用于工业领域的以太网称为工业以太网。 普通以太网采用的是CSMA/CD(载波侦听多路访问/冲突检测）访问控制技术。网上节点通过竞争获得发送信息的权力，显然因为竞争，以及发生碰撞要推出重发等级制，会导致无法预见的延迟特性，就破坏了我们的确定性。以及以太网无法及时发现故障节点所以可能导致故障节点独占总线，其他节点无法传输，工控实时性很难保证。 实时工业以太网一般有三种实现，分别是基于TCP/IP实现（应用层）的改造、基于以太网（主要是网络层和传输层）实现的改造以及基于修改的以太网（主要在以太网的数据链路层）实现的改造。 基于TCP/IP的实现应用层做修改，仍使用TCP/IP协议，通过应用层过滤不确定因素。改造方法有调度法、优先级机制、交换式以太网等。代表是Modbus/TCP和Ethernet/IP。仅适用于对实时性要求不高的工控环境 基于以太网的实现网络层和传输层做修改。基于标准的ISO/IEC802.3中物理层和数据链路层协议，工控相关的过程数据不通过TCP/IP协议传输。常用手段时间片机制。代表是Ethernet powerlink、EPA、profinet RT等 基于修改以太网实现数据链路层做修改。一般采用专用硬件处理数据，使用专用帧类型提高工控数据帧的优先级，简化通信处理过程，避免报文冲突，代表为EtherCAT、SERCOS III和profinet IRT。可以获得响应事件小于1ms的硬实时。 tips:以太网帧的数据有1500个字节左右 第三类工业以太网协议性能对比 EtherCAT，全双工（可以同时在两个方向上收发消息），拓扑结构支持星型、线型、环型、树型和总线型。同步精度最高 100ns。实时特性最好 SERCOS III，全双工，拓扑结构支持线型、环型 PROFINET IRT，半双工（可以双向传输，但不能同时传输），拓扑结构支持星型和线型。 EtherCAT——基于以太网的开发构架的实时工业现场总线通讯协议特点：高性能、拓扑结构灵活、应用容易、低成本、高精度设备同步、可选线缆冗余、功能性安全协议、热插拔 需要注意的是EtherCAT中数据交换完全基于纯粹的硬件设备，利用逻辑环网结构和全双工快速以太网。时钟抖动小，非常精确。 逻辑环网是一种可以完全避免消息碰撞的技术。 主要可以用于短指令的简单控制系统，可以充分利用以太网的payload空间，存放多条指令，防止浪费。 后面的不总结了，看看就完事了，老师好像都没怎么讲印象里。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://zijian.wang/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"嵌入式RTOS","slug":"嵌入式RTOS","permalink":"https://zijian.wang/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FRTOS/"}]},{"title":"数据库基础（二）——数据模型与数据结构","date":"2018-03-27T07:07:34.000Z","path":"2018/03/27/数据库基础（二）——数据模型与数据结构/","text":"这是第二篇笔记第一章简单的介绍了关于数据库的一些常识，数据、数据库等基本概念、两种数据管理技术的比较、对比，也简单介绍了数据的独立性和数据库系统的具体组成。那么，这篇文章总结的是第二章的内容，具体将要总结数据模型的基本概念和数据库的结构，关于程序与数据相互独立的基本原理。 数据和数据模型数据与信息数据，是数据库中存储的基本概念；信息，是用来描述客观世界事物的信息。我们把事物的特征抽象出来，把这些信息写成一行数据，就成为了一个记录。我们将描述事物的符号记录称为数据，从数据中提炼出来的有意义的内容称为信息。数据是信息存在的一种形式，只有通过解释或处理才能成为有用的信息。而数据库中的数据，具有动态特征和静态特征两个方面。 静态特征。包括数据额基本结构、数据间的联系以及对数据取值范围的约束。 动态特征。指对数据可以进行的操作以及操作规则。一般就是指增删改查。 数据模型数据模型是一种对现实世界数据特征的抽象。数据库中用数据模型这个工具来抽象表示和处理现实世界中的数据和信息。为了让数据模型既可以面向现实世界，又面向机器世界，一般要求其满足三个方面： 能够真实地模拟现实世界。构建模型是为了真是形象地表达现实世界的情况。 容易被人理解。 能够方便在计算机上实现。 当然，同一个模型很难实现三方面要求。所以数据库要根据不同情况，采用不同的数据模型。按应用分类，模型要分为两大类，分别属于两个层次。 分类 概念层数据模型 组织层数据模型 又名 概念模型/信息模型 组织模型 建模方式 从数据应用语义来抽取现实世界中有价值的数据，并按用户的观点对数据进行建模 以数据的组织形式来描述数据，主要从计算机系统的观点对数据进行建模 和所使用的数据库管理系统是否相关 无关 相关 实现方式 无关 主要采用了以下组织方式：层次模型、网状模型、关系模型、对象-关系模型 从现实世界到机器世界的过程如下图所示由图可知，概念层模型实际上只是一个中间层，机器世界实现的最终目的是反映和描述现实世界。 概念层数据模型基本概念概念层数据模型是现实世界到信息世界的第一层抽象，一方面应具有较强的语义表达能力，能够方便、直接地表达应用中的各种语义知识，另一方面还应该简单清晰和易于被用户理解。常用的概念层数据模型有实体-联系（E-R模型）、语义对象模型。最常用的就是E-R模型。 E-R模型E-R方法的实用工具称为E-R图，他所描述的信息结果称为企业模式。该模型主要涉及实体、属性和联系三方面内容。 实体：具有公共性质，并可以相互去分的现实世界对象的集合。E-R图中使用矩形边框表示。 属性：属于一个实体的所有实例都具有相同的性质和特征。E-R图中用圆角矩形表示。在实体的属性中，能够唯一标识实体的一个或最小的一组属性称为属性的标识属性 联系：分为实体内部和实体之间，都指的是属性之间的联系。E-R图中用菱形边框表示。两个实体之间的联系通常有三类： 一对一联系(1:1) 实体A中的每个实例在实体B中至多有一个（或没有）实例与之关联，反之亦然。 一对多联系(1:n) 实体A中的每个实例在实体B中有n(n&gt;=0)个实例与之关联，而实体B中的每个实例在实体A中最多只有一个实例与之关联 多对多联系(n:n) 实体A中的每个实例在实体B中有n(n&gt;=0)个实例与之关联，反之亦然 组织层数据模型主要分为层次模型、网状模型、面向对象模型和对象关系模型。前两者称为非关系模型，已逐渐被淘汰 层次数据模型使用树形结构表示实体和实体之间的联系，这种联系是一对多的。层次模型有两点限制：1. 有且仅有一个节点无父节点，及树的根2. 其他节点有且仅有一个父节点层次模型的一个基本特点是：任何一个给定的记录值只有从层次模型的根部开始按路径查看时，才能明确其含义，任何子节点都不能脱离父节点而存在。 网状数据模型去掉层次模型中的两点限制，允许一个以上的节点无父节点，并且每个子节点可以有多个父节点，这便构成了网状模型。这种联系可以是多对多的。显然网状数据模型和层次数据模型无论逻辑结构还是物理结构都十分相似，只是网络数据模型更为复杂罢了。 关系数据模型目前最为重要的一种数据模型。实体间的联系不再通过指针来实现。在关系数据库中，记录仅仅构成关系，关系之间的联系是靠语义相同的字段值表达的。 面向对象数据模型面向对象数据模型把实体表示为类，一个类描述了对象属性和实体行为。面向对象数据库通过逻辑包含来维护联系。 数据库结构数据库的结构从不同角度层次考虑是不同的，比如从管理角度看，数据库通常采用三级模式结构，这就是内部的系统结构；而从最终用户角度看，结构分为集中式结构、文件服务器结构、客户/服务器结构等，这是外部结构。此处讨论的是内部结构。 模式的基本概念组织层数据模型描述数据的组织形式，模式是用给定的数据模型对具体数据的描述。我认为，模式其实有点类似于“类”的概念，首先，它仅仅描述“型”，不涉及具体的值。比如关系模式就是关系的“型”或说是元组的结构共性的描述，实际上对应的是关系表的表头。其次，模式的一个具体值称为模式的一个实例，一个模式可以有多个实例，模式稳定而实例变动。 三级模式结构三级模式的三级指的是外模式、模式和内模式。 模式 描述 对应到关系数据库 外模式 又称为用户模式和子模式，内容来源于模式。是面向用户的对整体数据的局部描述。是模式的子集或局部重构，对不同用户有不同的外模式的描述，是保证数据库安全的一个措施 外部视图 模式 又称为逻辑模式或概念模式，是对数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。是数据库结构的中间层，及不涉及物理存储细节，也不涉及具体应用程序。模式由概念记录类型的值构成，概念记录是数据的一种逻辑表达，是数据库数据在逻辑级上的逻辑表达 关系数据库管理系统提供模式定义语言DDL来定义数据库的模式 内模式 又称为组织模式，是整个数据库的底层描述，描述了数据的存储结构，但不涉及物理记录的形式，不考虑具体设备。 内模式不是关系的 模式映像和数据独立性为了实现数据库的三级模式的联系和转换，产生了两级映像： 外模式/模式映像 每个数据库有多个外模式和一个模式，每个外模式都有一个到模式的映像，定义了其与模式之间的对应关系。当模式改变时，调整映像，基于外模式编写的应用程序不会受影响 模式/内模式映像 定义了数据库的逻辑结构与物理存储之间的对应关系，该关系保存在数据库的系统表。 三级模式结构中，模式是数据库的中心和关键，独立于数据库的其他层。数据库管理系统提供的两级映像保证了外模式的稳定性，从而保证了应用程序的稳定性。因为应用程序都是在外模式描述的数据结构上编写的。","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zijian.wang/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zijian.wang/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"Microsoft SQL Server 2017下载安装","date":"2018-03-14T12:09:30.000Z","path":"2018/03/14/Microsoft SQL Server 2017下载安装/","text":"本学期学习课程中有数据库这门课，为了深入了解学习数据库，最好的做法就是去实际操作数据库，微软的SQL Server其实还算不错，而且其Developer（开发者版）也免费对用户使用，但是在安装的过程中，尤其是在没有之前版本的全新安装时，往往会出现很多问题，在本文中我将详细再现整个安装流程，并对出现的问题给出解决办法。当然，因为第一次做教程，同时试验下微信图床的功能，所以把图全部截了截，做完觉得好小白，所以其实可以直接在目录上看那几个有问题的地方 官网下载可以直接百度打开官网，选择中间的developer版就可以满足学习需要。developer版本是免费的。 进行安装双击安装包SQLServer2017-SSEI-Dev运行。进入安装页面。选择自定义安装。媒体位置默认是C盘，可以自行更改到其他位置，我这里选择了D盘。点击安装。安装完毕后进入新的页面，开始正式的安装过程。在左侧选择安装字样。可以看到右侧出现很多选择的操作。本机并没有装过SQL Server，所以选择第一项就ok。这里版本不用更改，也不需要产品密钥，下一步。之后往下按部就班走就可以，接受条款、根据自己选择是否同意更新，进行安全检查，进行安全检查时会出现防火墙警告，无视掉就ok。继续下一步，就到了第一个问题出现的地方。 第一个问题————功能选择到了这一步就是要你选择你的SQL Server希望具有哪些功能了，这一步很容易出问题，因为在进行勾选选择全选的话，在安装时会卡在一个地方动不了，就很尴尬，事实上这里主要是机器学习相关组件安装的问题，所以在这里，我推荐大家不要勾选机器学习相关的几个东西(包括机器学习服务和共享功能内的机器学习服务器中的R和Python)。如果需要，可以后面进行更新。在这里，可以考虑对安装路径进行修改，放到别的盘里。我这里放到了我在D盘中建的文件夹里。 第二个问题————jre7.0点击下一步，比较快速的安装，结果发现一个新的问题：如图，polybase要求安装Oracle JRE 7更新 51（64位）或更高版本。但是不对啊，我电脑上有Java 9.0了啊，所以结论是，SQL Server2017需要一份jre 7.0的。那没办法咯，去下载一个吧，然后你到官网发现，已经没有jre7了，当然，你麻烦一点注册账号，还是能找到的。这里我把我的jre7.0放出来好了，放网盘连接：链接：https://pan.baidu.com/s/1FVa-Xv0V-DVyY8foaQMFtw密码：p3r6下载后双击运行安装就ok，不必配置环境，放到哪个盘里都没关系。然后回到SQL Server 2017安装程序，点击重新运行ok,没问题了，接下来疯狂下一步吧到了这一步，需要停一下，默认是Windows身份验证，我们更改换为混合模式，并设置sa的密码，然后点击下方添加当前用户。下一步，同样也是添加当前用户。然后又是下一步添加当前用户然后到这里，如果要更改工作目录，注意这里是不会自动生成的，就是如果你改动了目录，直接在路径后面放’\\Dreplay’什么是不管用的，所以需要到相应文件夹下建立文件，这里自己操作，没必要像我这个强迫症一样建立那么多文件夹。反正总之搞定别让他报错就ok了。下一步吧。好的，完成界面！是不是大功告成呢？运行下吧不好意思，还是不行！ 第三个问题，安装完成，然而运行不成功其实这个主要是因为之前电脑上没有安装过SQL Server导致的，所以还缺少一个叫做SSMS(SQL Server Management Studio )的集成环境，百度一下你就可以在微软官网上进行下载。当然我这里也有下载好的，百度链接：链接：https://pan.baidu.com/s/1yWG3HSNrhux7sx5pUMGGeg密码：mr7v双击安装到底 完成再次打开运行：恭喜，SQL Server 2017安装成功。","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zijian.wang/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"工具","slug":"工具","permalink":"https://zijian.wang/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"数据库基础（一）——数据库概述","date":"2018-03-09T07:05:49.000Z","path":"2018/03/09/数据库基础（一）——数据库概述/","text":"数据库用于数据管理，是数据管理的最新技术，数据库技术一般包括数据管理和数据处理两部分。数据库系统本质上是一个用计算机存储数据的系统。以下将先对一些基本概念进行总结。 基本概念 数据（Data）：描述事物的符号记录。是有结构的 数据库（Database，DB）：将数据存储在计算机存储设备上、按一定格式存储的仓库，严格上讲是长期存储在计算机中的、有组织的、可共享的数据的集合 数据库管理系统（Database Management System，DBMS）：专门用于实现对数据进行管理和维护的系统软件。DBMS位于用户应用程序与操作系统之间，其主要功能有以下几个方面 数据库的建立和维护 数据定义功能 数据组织、存储和管理功能 数据操作功能 事物的管理和运行功能 其他功能 数据库系统（Database System，DBS）：指计算机引入数据库后的系统，一般有数据库、数据库管理系统、应用程序、数据库管理员组成。一般数据库系统被简称为数据库。 数据管理技术发展数据管理技术的发展分为两个阶段：文件管理和数据库管理。先展示一下两者的优缺点。 文件管理 数据库管理 编写应用程序不方便 相互关联的数据集合 数据冗余不可避免 较小的数据冗余 应用程序依赖性 程序与程序相互对立 不支持并发访问 保证数据安全、可靠 数据间联系弱 最大限度保证数据正确性 难以满足不同用户对数据需求 数据可以共享并能保证数据的一致性 无安全控制功能 总结：数据库是相互关联的数据的集合，他用综合的方法组织数据，具有较小的数据冗余，可供多个用户共享，具有较高的数据独立性，具有安全控制机构，能够保证数据安全可靠、允许并发的使用数据库，能有效即使的处理数据，并能保证数据的一致性和正确性。 数据独立性数据独立性指的是应用程序不会因数据的物理表示方式和访问技术的改变而改变，即应用不依赖于任何特定的物理表示方式和访问技术。它包括两个以下方面： 物理独立性：当数据的存储位置和存储结构发生变化时，不影响应用程序的特性 逻辑独立性：当表达现实世界的信息内容发生变化时（增删列行），也不影响应用程序的特性。 数据库系统组成数据库系统包括如下部分。 数据库：数据的汇集场所，以一定形式存储在存储介质上 数据库管理系统：管理数据库的系统软件，实现数据库系统的各种功能 应用程序：这里专指访问数据库数据的程序 数据库管理员：负责整个数据库的正常运行。 数据库管理系统程序的使用需要占用硬件资源，这里从硬件、软件和人员方面简要介绍主要内容。 硬件：内存要足够大来运行操作系统、数据库管理系统和应用程序 软件：包括以下内容： 数据库管理系统：整个数据库系统核心，是建立、使用和维护数据库的系统软件（可以使用微软公司的SQL Server，免费的开发者版足够练习使用） 支持数据库管理系统运行的操作系统。 以数据库管理系统为核心的使用工具。 人员：包括数据库管理员、系统分析人员、数据库设计人员、应用程序编程人员和最终用户。","tags":[{"name":"数据库","slug":"数据库","permalink":"https://zijian.wang/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://zijian.wang/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"计算机网络笔记（一）","date":"2018-03-08T07:06:00.000Z","path":"2018/03/08/计算机网络基础（一）/","text":"这是我第一次学习计网（谢希仁版课本）总结的一些自以为值得一提的东西。没有整理完，先上传一部分。 常识三网融合21世纪是一个以网络为核心的信息时代，起初，三网有电信网络、有线电视网络、计算机网络。到了后期，计算机网络发展最快而且起到了核心作用 互联网（Internet）和互连网（internet）互联网是国际的；互连网是局部的 互联网的特性： 连通性 共享性：资源共享。 概述网络的网络 计算机网络（网络）由若干结点（node）和链接他们的链路（link）组成。 互连网（internet）就是网络的网络，就是指网络与网络之间用路由器互联起来，组成覆盖范围更大的网络。 主机（host）就是与网络相连的计算机。 互联网基础发展三阶段1. 单个网络ARPANET向互联网发展该过程导致了互连网络的产生，是互联网的雏形 互联网（Internet）专用名词，单指最大的特定互连网，采用TCP/IP协议族作为通信规则，前身就是ARPANET 互连网（internet）通用名词，泛指多个网络互连而成的网络。通信协议可以不是TCP/IP协议。 2. 形成三级结构互联网三级计算机网络国家科学基金网诞生，分为主干网、地区网和校园网（企业网）。这一阶段美国政府将主干网转交给了私人公司经营。 3. 形成多层次ISP结构的互联网NSFNET被若干商用互联网主干网替代，政府机构不再负责互联网运营，于是互联网服务提供商ISP（Internet Service Provider）应运而生。 ISP从互联网机构申请大量IP地址，同时拥有联网设备和通信线路，这样个人使用者向ISP缴费后就可以被分配一个IP地址的使用权，从而可以连入网络。（管理机构不单卖IP，只会批发给ISP。）所以如今可以说，互联网是被全世界的ISP共有的。而ISP根据大小和IP数目不同也分为主干ISP、地区ISP、本地ISP。分层交流 为了解决应对互联网上流量数据增长，互联网交换点IXP应运而生。他的作用就是允许两个网络直接相连交换分组。它通常在数据链路层的网络交换机中起作用。 互联网标准化。互联网协会ISOC下有一个技术组织IAB下有两个工程部IETF（互联网工程部）和IRTF（互联网研究部）进行研究协议、应用和体系。所有的互联网标准都是以RFC（Request For Comment）的形式在互联网上发表的，都可以被下载。制定互联网正是标准需要三个阶段：互联网草案、建议标准和互联网标准（STD XX）。 互联网组成互联网的工作方式大概可以划分为边缘部分和核心部分 边缘部分用户直接使用，由所有连接到互联网上的主机组成。这些主机又称为端系统。边缘部分利用核心部分提供的服务进行通信交换共享信息。这种计算机之间的通信通信方式通常可划分为两大类：客户-服务器方式（C/S方式）和对等方式（P2P方式） C/S方式 客户Client 服务器Server 请求方 服务提供方 调用后运行，通信时发送通信 启动后自动调用不断运行，被动接受信息后响应 需要知道服务器程序地址 不需要知道客户地址 不需要特殊硬件和操作系统 需要强大的硬件和高级的操作系统 P2P（peer-to-peer）方式每个主机既是客户也是服务器。 核心部分为边缘部分提供服务，由大量网络和连接他们的路由器组成。核心是路由器（router），实现分组交换的关键，任务是转发收到的分组。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://zijian.wang/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://zijian.wang/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}]