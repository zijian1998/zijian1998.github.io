<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>《C++ Primer 第五版》阅读过程查漏补缺 Chapter6 | 妄越</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
    <meta name="description" content="学海无涯，记在路上">
  
  
    <meta name="keywords" content="技术博客">
  
  
    <link rel="alternate" href="/atom.xml" title="妄越" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/logo.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/localshare/css/share.css">

  
  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">妄越</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">平生蹉跎少年志，雨落樱花又一年</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa fa-home"></i> 首页</a>
        
          <a class="main-nav-link" href="/archives/"><i class="fa fa-archive"></i> 归档</a>
        
          <a class="main-nav-link" href="/about/"><i class="fa fa-user"></i> 关于</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-《C++ Primer第五版》阅读过程查漏补缺 chapter6" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      《C++ Primer 第五版》阅读过程查漏补缺 Chapter6
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2021-07-11T08:50:22.000Z" itemprop="datePublished">2021年07月11日</time>
</span>
      
  <div class="article-category">
    <i class="fa fa-classify"></i>
    <a class="article-category-link" href="/categories/%E3%80%8AC-Primer%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">《C++ Primer》阅读笔记</a>
  </div>

      
        <span class="article-views">
  <i class="fa fa-views"></i>
  <i id="busuanzi_container_page_pv">
      <i id="busuanzi_value_page_pv"></i>
  </i>
</span>

      
      
<a href="/2021/07/11/%E3%80%8AC++%20Primer%E7%AC%AC%E4%BA%94%E7%89%88%E3%80%8B%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%20chapter6/#comments" class="article-comment-link">
  
    
    
    
    
    
      <i id="changyan_count_unit" data-xid="/2021/07/11/%E3%80%8AC++%20Primer%E7%AC%AC%E4%BA%94%E7%89%88%E3%80%8B%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%20chapter6/"></i>
    
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>函数部分比较难的地方在函数指针的各个概念，需要多加注意</p>
<span id="more"></span>
<h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><h3 id="函数的调用和返回"><a href="#函数的调用和返回" class="headerlink" title="函数的调用和返回"></a>函数的调用和返回</h3><h4 id="调用相关"><a href="#调用相关" class="headerlink" title="调用相关"></a>调用相关</h4><p><strong>调用运算符</strong>：调用运算符的形式是一对圆括号，作用于一个表达式，该表达式是函数或者指向函数的指针。圆括号之内是一个用逗号隔开的实参列表，我们用实参初始化函数的形参。调用运算符的类型就是函数的返回类型</p>
<p><strong>函数调用完成两项工作</strong>：</p>
<ol>
<li>使用实参初始化函数对应的形参</li>
<li>将控制权转移给被调函数。此时，主调函数的执行被打断，被调函数开始执行</li>
</ol>
<h4 id="返回相关"><a href="#返回相关" class="headerlink" title="返回相关"></a>返回相关</h4><p>一般的类型函数都可以进行返回，当函数不需要返回任何值时，可以返回void，当然也可以返回空语句。</p>
<p>但是函数返回类型不能是数组，但是可以是指向数组或函数的指针，</p>
<p><strong>return语句同样完成两项工作</strong>：</p>
<ol>
<li>返回return语句中的值</li>
<li>将控制权从被调函数转移回主调函数。</li>
</ol>
<h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><p>函数有几个参数，就必须提供相同数量的实参，因为参数的调用规定实参数量要和形参一致，所以形参一定会被初始化。</p>
<p>同时，形参的类型一定要被实参很好的满足。比如如果形参是int类型，实参可以是double类型，因为可以隐式转换，但却不能是const char*类型。</p>
<h4 id="函数的形参列表"><a href="#函数的形参列表" class="headerlink" title="函数的形参列表"></a>函数的形参列表</h4><ul>
<li><p>当一个函数没有形参时，可以书写一个空的形参列表，为了和C语言兼容，函数的形参列表可以用关键字void表示函数没有参数。</p>
</li>
<li><p>偶尔有函数的个别参数不会被使用，则此类形参通常不命名以表示在函数体内不会使用。但即便如此，函数调用时，依然应该为其提供一个实参。</p>
</li>
</ul>
<h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>在C++中，<strong>名字</strong>有<strong>作用域</strong>，<strong>对象</strong>有<strong>生命周期</strong>。</p>
<ul>
<li>名字的作用域是程序文本的一部分，名字在其中可见</li>
<li>对象的生命周期是程序执行过程中该对象存在的一段时间</li>
</ul>
<p>形参和函数体内部定义的变量统称为局部变量。局部变量会在外层作用域中同名的其他所有声明里<strong>隐藏</strong>（意思就是在外层作用域如果存在同名变量，则局部变量是无法访问到的。）</p>
<h4 id="自动对象"><a href="#自动对象" class="headerlink" title="自动对象"></a>自动对象</h4><p>函数的控制路径经过变量定义语句时创建的对象，该对象当到达定义所在块的末尾时会进行销毁，只存在于块执行期间的对象，就是自动对象。</p>
<ul>
<li>形参就是一种自动对象。该自动对象在函数开始时申请存储空间，由实参进行初始化，在函数结束时被销毁</li>
<li>对于非形参的局部变量的自动对象，如果含有初始值，则使用初始值进行初始化；否则执行<strong>默认初始化</strong>。也就是说<strong>内置类型的未初始化局部变量将产生未定义的值。</strong></li>
</ul>
<h4 id="局部静态变量"><a href="#局部静态变量" class="headerlink" title="局部静态变量"></a>局部静态变量</h4><p>如果要让局部变脸的生命周期贯穿函数调用，<strong>及之后的时间</strong>，可以将局部变量定义为static类型。</p>
<p>局部静态变量在程序执行路径第一次经过对象定义语句时初始化，直到程序终止才被销毁，在此期间即使对象的所有函数执行也不会对他有影响。</p>
<p>如果局部静态变量没有显式的初始值，则将执行值初始化，<strong>内置类型的局部静态变量初始化为0.</strong></p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数的名字必须在使用前声明，函数只能定义一次，但能声明多次。</p>
<p>函数声明可以省去形参的名字，只要形参的类型。</p>
<p>函数声明也称为函数原型。</p>
<p>函数声明建议放在头文件中而不是源文件中，便于更改。</p>
<p>定义函数的源文件把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。</p>
<h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><p>C++支持分离式编译，也就是允许多个源文件共同编译，或各自编译，生成对象文件，再进行链接成可执行文件</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>C++的参数传递分为<strong>值传递</strong>或<strong>引用传递</strong>两大类。</p>
<h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><p>值传递本质就是形参和实参是完全两个不同的变量，形参只是利用实参的值进行拷贝初始化。</p>
<p>而对于指针传参而言，同样依然是一种“值传递”，这种值传递不过是把指针的值进行了拷贝传递，拷贝之后形参的指针和实参的指针依然是两个完全不同的指针，只是他们访问的对象是同一个对象罢了。</p>
<p>以前在C语言中，我们把参数传递分为按值传参和按址传参，在C++中更经常使用引用传参而不是按址传参。</p>
<h4 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h4><p>引用的本质就是通过给原本的对象起一个别名，然后使用它。对引用的操作实际上是作用在引用的对象上的。引用形参是同一个道理。</p>
<p>最重要的是通过引用传参，可以避免变量的复制。对于大的类型（string等）还有不支持拷贝操作的类型（IO类型），我们要使用<strong>引用形参</strong>的方式来访问该类型的对象。同时，<strong>如果函数无需修改引用类型的值，最好用常量进行引用</strong></p>
<p>引用是一种和指针非常类似的东西，也就是说我们也可以用引用传参的方法，返回额外的信息（因为return只能返回一个值）。</p>
<h4 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h4><p>使用实参初始化形参时，会忽略掉顶层const（顶层const的具体含义见<a target="_blank" rel="noopener" href="http://rrazz.love/2020/11/04/%E3%80%8AC++%20Primer%20%E7%AC%AC%E4%BA%94%E7%89%88%E3%80%8B%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%20Chapter2/">章节二</a>）。也就是说，<strong>当形参有顶层的const时，传给他常量对象或者非常量对象都是合法的。</strong></p>
<p>由于C++中虽然允许函数名相同的函数存在，但前提是不同函数的形参列表应该有明显区别。那么如果两个函数的唯一区别就是形参列表中有无顶层const，那么第二个函数就是错误的，因为是重复定义的函数，如下述代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>&#123;```<span class="comment">/*fcn可以读取i，但不可以改变i*/</span>```&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;```&#125;	<span class="comment">// 重复定义了</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用非常量初始化一个底层const对象，但是无法用一个底层const对象来初始化一个非const指针；同时一个普通的引用必须用同类型的对象初始化。如下述代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">const int *cp = &amp;i;	// 正确。</span><br><span class="line">const int &amp;r = i;	// 正确</span><br><span class="line">const int &amp;r2 = 42;	// 正确</span><br><span class="line">int *p = cp;		// 错误，cp是指向一个底层const对象的指针，p是一个指向普通对象的指针，类型不同</span><br><span class="line">int &amp;r3 = r;		// 错误，r是一个底层const对象的引用，我们无法用一个引用普通对象的引用来引用一个底层const对象。</span><br><span class="line">int &amp;r4 = 42;		// 错误，无法引用一个常数。</span><br></pre></td></tr></table></figure>
<p>同样这些规则也适合于函数传参。</p>
<p>但是当我们的形参类型是常量引用时，确实可以使用一个字面值作为实参进行初始化。</p>
<p><strong>在函数不会改变形参时尽量使用常量引用</strong></p>
<p>原因是：<strong>常量引用可以扩大函数所能接受的实参类型。如上文所述，顶层const可以忽略对于函数引用，不会影响非const类型的接受，但是如果是非const引用，则会导致无法接受const类型参数进行初始化——尽管那可能是我们想要的。</strong></p>
<h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>数组存在两个性质：<strong>不允许拷贝数组</strong>、<strong>使用数组时通常会将其转换为指针</strong></p>
<p>所以当数组作为形参时，我们无法用值传递的方式使用数组参数，实际上我们是将指向数组首元素的指针传入函数</p>
<p>形如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>都是将数组传入函数的写法，且上述三种表示的含义相同——都表示传入的参数为<code>const int*</code>类型。编译器检查只会检查是否为这种类型。</p>
<p>和其他使用数组的代码一样，以数组为形参的函数也必须保证数组不越界，管理指针形参有三种常用的技术</p>
<ul>
<li>使用<strong>标记</strong>指定数组长度。即规定数组中含有某个元素，标记数组的结束。比如C风格字符串，会以空字符作为字符串结束的标志</li>
<li>使用标准库规范。即传递数组的<strong>首元素</strong>和<strong>尾后元素</strong>的指针。一般可以使用标准库的<strong>begin()</strong>函数和<strong>end()</strong>函数</li>
<li>显示传递一个数组大小的形参。在C程序和过去的C++程序中常用，调用函数时，提前用一个变量表示函数大小，作为参数传递过去。</li>
</ul>
<h4 id="数组形参和const"><a href="#数组形参和const" class="headerlink" title="数组形参和const"></a>数组形参和const</h4><p>同引用一样，如果函数不需要对数组元素执行写操作，数组形参应该是指向const的指针</p>
<h4 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h4><p>如同之前的引用传参，形参也可以是数组的引用，此时引用形参绑定到对应的实参，也就是绑定到数组上。写法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中<code>&amp;arr</code>两端的括号必不可少。</p>
<h4 id="传递多维数组"><a href="#传递多维数组" class="headerlink" title="传递多维数组"></a>传递多维数组</h4><p>C和C++中没有真正意义的多维数组，只有存放了数组的数组。而一般多维数组的写法如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matric)[<span class="number">10</span>],<span class="keyword">int</span> rowSize)</span></span>;</span><br><span class="line">或者</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matric[][<span class="number">10</span>],<span class="keyword">int</span> rowSize)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一般来说，数组作为传参，编译器不会在乎你的数组容量，但是会在乎你的数组中元素的类型。正如前面介绍的，传入参数传入的实际只是首元素的地址，而n维函数也不过只是存放了一个(n-1)维数组的一维数组，所以编译器会优化掉你的第一个维度（也就是一维数组的长度）,但是却需要知道你的类型。这也就是为什么我们传入指针时，需要标注10，传入数组时，省略第一个括号中的值的原因。</p>
<h3 id="main：处理命令行选项"><a href="#main：处理命令行选项" class="headerlink" title="main：处理命令行选项"></a>main：处理命令行选项</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;···········&#125;</span><br></pre></td></tr></table></figure>
<p>其中argc为命令行传入参数数目+1，同时也代表argv数组的大小。</p>
<p>argv是一个存放字符串的数组，其中它的第一个元素必然是可执行文件，后面的元素即为传进来的参数。（书上说最后一个元素一定为0，事实上打印时发现如果尝试打印下个数，会段错误）</p>
<h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><p>在无法提前预支需要向函数传递多少个参数时，C++11提供了两种主要方法：</p>
<ul>
<li>initializer_list标准库类型：要求所有的实参类型都相同</li>
<li>可变参数模板：实参类型不同</li>
</ul>
<p>同时C++还有一种形参类型——省略符，可以用来传递可变数量的实参，一般用于与C函数交互的接口程序</p>
<h4 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h4><p>定义在同名头文件需要引入。相关操作如图所示</p>
<p>需要注意的是，initializer_list对象中的元素永远是常量值，无法改变其中元素的值。</p>
<p>如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号里。</p>
<h4 id="省略符形参"><a href="#省略符形参" class="headerlink" title="省略符形参"></a>省略符形参</h4><p>使用了varargs的C标准库功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="返回类型和return类型"><a href="#返回类型和return类型" class="headerlink" title="返回类型和return类型"></a>返回类型和return类型</h2><h4 id="关于return的有无"><a href="#关于return的有无" class="headerlink" title="关于return的有无"></a>关于return的有无</h4><p>当函数的返回类型不是void，则该函数内每条return语句必须返回一个值。且返回值的类型必须与函数返回类型相同，或可以隐式转换。</p>
<p>同样 在含有return语句的循环后面也要有一条return语句，如果没有，该程序就是错误的。</p>
<h4 id="不要反悔局部对象的引用或指针"><a href="#不要反悔局部对象的引用或指针" class="headerlink" title="不要反悔局部对象的引用或指针"></a><strong>不要反悔局部对象的引用或指针</strong></h4><p>形如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> string &amp;<span class="title">manip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string ret</span><br><span class="line">	<span class="comment">//····</span></span><br><span class="line">	<span class="keyword">if</span>(!ret.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Empty&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的程序，两条返回语句都是错误的，第一条语句实际返回的是<strong>局部对象的引用</strong>，第二条语句实际返回的是<strong>局部临时量</strong>。</p>
<p>综上，返回局部对象的引用或指针都是错误的， 因为会在函数结束后释放掉空间，指针或引用就访问了不可用的内存空间。</p>
<h4 id="返回类类型的函数和调用运算符"><a href="#返回类类型的函数和调用运算符" class="headerlink" title="返回类类型的函数和调用运算符"></a>返回类类型的函数和调用运算符</h4><p>调用运算符优先级和<strong>点运算符</strong>、<strong>箭头运算符</strong>相同，且符合左结合律。</p>
<h4 id="引用返回左值"><a href="#引用返回左值" class="headerlink" title="引用返回左值"></a>引用返回左值</h4><p>函数的<strong>返回类型</strong>决定函数调用是否为<strong><a target="_blank" rel="noopener" href="http://rrazz.love/2021/04/10/%E3%80%8AC++%20Primer%20%E7%AC%AC%E4%BA%94%E7%89%88%E3%80%8B%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%20Chapter4/">左值</a></strong>。当函数返回<strong>引用</strong>时，得到左值，其他返回类型为右值。返回类型为引用的函数可以像其他左值一样进行使用，比如我们可以为返回类型为<strong>非常量引用</strong>的函数的结果赋值。当然如果为常量引用，我们依旧无法赋值。</p>
<h4 id="列表初始化返回值（C-11）"><a href="#列表初始化返回值（C-11）" class="headerlink" title="列表初始化返回值（C++11）"></a>列表初始化返回值（C++11）</h4><p>C++11规定，函数可以返回花括号包围的值的列表。此处列表也是用来对表示函数返回的临时量进行初始化。</p>
<ul>
<li>列表为空时，临时量执行值初始化</li>
<li>否则，返回的值由函数的返回类型决定。</li>
</ul>
<p>如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不能大于目标类型的空间。如果函数返回的是类类型，则需要由类本身定义初始值如何使用。</p>
<h4 id="main主函数"><a href="#main主函数" class="headerlink" title="main主函数"></a>main主函数</h4><p>主函数可以不显示的写上return 0，编译器一般会自己隐式插入。</p>
<p>main函数的返回值是状态指示器。返回0表示执行成功，其他值表示失败，具体非0值的含义跟机器相关。为了机器无关，cstdlib头文件定义了两个预处理变量，分别表示成功与失败</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(/···some failure···/)</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;	<span class="comment">//	表示返回失败</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> EXIT_SUCCESS;	<span class="comment">// 	表示返回成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数不可以调用自己</p>
<h3 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h3><p>定义一个返回数组的指针或引用有下述几种方法：</p>
<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a><a target="_blank" rel="noopener" href="http://rrazz.love/2020/11/04/%E3%80%8AC++%20Primer%20%E7%AC%AC%E4%BA%94%E7%89%88%E3%80%8B%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%20Chapter2/">类型别名</a></h4><ul>
<li><code>typedef int arrT[10]</code>。arrt表示了一个类型别名，表示的类型为含有10个整数的数组</li>
<li><code>using arrT=int[10]</code>。   同上</li>
</ul>
<p>这样，就有函数<code>arrT* func(int i)</code>来返回一个指向含有10个整数的数组的指针。其中arrT是含有10个整数的数组的别名。</p>
<h4 id="声明一个返回数组指针的函数"><a href="#声明一个返回数组指针的函数" class="headerlink" title="声明一个返回数组指针的函数"></a>声明一个返回数组指针的函数</h4><p>不使用类型别名，就需要用比较繁琐的方式进行表示，函数形式如下所示</p>
<script type="math/tex; mode=display">
Type\ \  (*function(parameter_list))\ \ [dimension]</script><p>其中$Type$表示元素类型，$dimension$表示数组大小，$ (*function(parameter_list))$的括号必须存在，如果不存在，返回的就是指针数组。</p>
<h4 id="尾置返回类型（C-11）"><a href="#尾置返回类型（C-11）" class="headerlink" title="尾置返回类型（C++11）"></a>尾置返回类型（C++11）</h4><p>C++11中有一种简化的方法，就是尾置返回类型。这种形式对返回类型比较复杂的函数最有效。</p>
<p>尾置返回类型跟在形参列表后面并以一个$-&gt;$开头，同时在返回类型处，放置一个auto，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span> [10]</span>;</span><br></pre></td></tr></table></figure>
<p>这里返回了一个指针，指针指向含有10个整数的数组。</p>
<h4 id="使用decltype"><a href="#使用decltype" class="headerlink" title="使用decltype"></a>使用<a target="_blank" rel="noopener" href="http://rrazz.love/2020/11/04/%E3%80%8AC++%20Primer%20%E7%AC%AC%E4%BA%94%E7%89%88%E3%80%8B%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%20Chapter2/">decltype</a></h4><p>这应用于我们提前知道了函数返回的指针将要指向哪个数组。如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> even[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">arrPtr</span>(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (i%<span class="number">2</span>) ? &amp;odd : &amp;even;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是需要注意decltype并不负责把数组类型转换成对应的指针，所以decltype的结果为数组，所以应该在arrPtr函数前加上*号。</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数名字相同，形参列表不同，称之为重载函数。重载函数允许函数形参数量和形参类型不同，但不允许两个函数除了类型外其他所有要素都相同。</p>
<h4 id="形参类型究竟是否相同"><a href="#形参类型究竟是否相同" class="headerlink" title="形参类型究竟是否相同"></a>形参类型究竟是否相同</h4><p>有些函数虽然形参类型看似不同，但是本质不是重载函数。主要指的是<strong>类型别名</strong></p>
<h4 id="重载函数和const形参"><a href="#重载函数和const形参" class="headerlink" title="重载函数和const形参"></a>重载函数和const形参</h4><p>参考<a href="[《C++ Primer 第五版》阅读过程查漏补缺 Chapter2 | 妄越 (rrazz.love">顶层const和底层const</a>](<a target="_blank" rel="noopener" href="http://rrazz.love/2020/11/04/《C++">http://rrazz.love/2020/11/04/《C++</a> Primer 第五版》阅读过程查漏补缺 Chapter2/))，两者要区分开来。</p>
<p><strong>顶层const</strong>作为参数时，无法影响传入函数的对象， 也就是无法进行重载。典型代表就是<strong>常量指针</strong>。</p>
<p><strong>底层const</strong>作为参数时，可以理解为不同函数，是一种函数重载，包括<strong>常量引用</strong>和<strong>指向常量的指针</strong>。</p>
<h4 id="重载函数和const-cast"><a href="#重载函数和const-cast" class="headerlink" title="重载函数和const_cast"></a>重载函数和const_cast</h4><p><a target="_blank" rel="noopener" href="http://rrazz.love/2021/04/10/%E3%80%8AC++%20Primer%20%E7%AC%AC%E4%BA%94%E7%89%88%E3%80%8B%E9%98%85%E8%AF%BB%E8%BF%87%E7%A8%8B%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%20Chapter4/">第4章</a>介绍了const_cast，作为一种解引用的关键字，在重载函数中很有用。举例假如我们有一个函数shorterString如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1: s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的参数、返回值都是<strong>const string</strong>的引用，如果我们对两个<strong>非常量</strong> 调用该函数，那么显然我们返回的结果是一个<strong>const string的引用</strong>。这时我们就需要一个重载函数，他要达到的目的是：<strong>当我传入实参不是常量时，我得到的结果也应该是一个非常量的引用</strong>。重载函数如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string &amp; <span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> string&amp;&gt; (s1), <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> string&amp;&gt;(s2));</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写，最终返回的非常量引用显然是安全的。</p>
<h4 id="函数匹配（重载确定）"><a href="#函数匹配（重载确定）" class="headerlink" title="函数匹配（重载确定）"></a>函数匹配（重载确定）</h4><p>调用重载函数可能有三种结果 </p>
<ul>
<li>编译器找到一个<strong>最佳匹配</strong></li>
<li>找不到任何一个函数与调用的实参匹配，编译器发出<strong>无匹配</strong>错误</li>
<li>在多余一个函数可以匹配，但每个都不是最佳选择，此时会发生错误，称为<strong>二义性调用</strong></li>
</ul>
<h4 id="重载和作用域"><a href="#重载和作用域" class="headerlink" title="重载和作用域"></a>重载和作用域</h4><p>不同作用域，函数重载不生效。<strong>如果在新的子作用域中声明了某一个函数，而和他同名的其他函数未在作用域声明，则其他重载函数会被屏蔽。</strong>因为编译器会先从局部作用域中找起，当前作用域找到后就会接受该函数，并忽略外层作用域中的同名实体。</p>
<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><p>有三种函数相关的语言特性，分别是<strong>默认实参、内联函数和constexpr函数。</strong></p>
<h4 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h4><p>我们可以为每一个形参提供默认实参，默认实参作为形参初始值出现在形参列表。一旦某个形参被赋予了默认值，形参列表中在他之后的所有形参都要赋予默认值。</p>
<p>tips：对于函数的声明，一般习惯放在头文件，且只声明一次。</p>
<p>局部变量不能作为默认实参。但表达式可以，用作默认实参的名字在函数声明所在的作用域内解析，但是求值过程发生在函数调用</p>
<h4 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h4><ul>
<li><p>内联函数</p>
<p>内联函数可以避免函数调用的开销。所谓内联函数就是让函数在调用点“内联”展开。</p>
<p>只需要在函数返回值前加上关键字inline，就可以声明为内联函数。</p>
<p>一般来说内联函数用于优化<strong>规模小、流程直接、频繁调用</strong>的函数</p>
<p>编译器一般不支持内联<strong>递归函数</strong>以及<strong>大于75行的函数</strong>。</p>
</li>
<li><p>constexpr函数</p>
<p>指能用于常量表达式的函数。需要遵循下列约定</p>
<ul>
<li>函数的返回值和所有形参的类型都要是字面值类型</li>
<li>函数体中必须有且只有一条return语句</li>
</ul>
<p>同时，constexpr函数一般会被隐式的指定为内联函数。</p>
</li>
</ul>
<p>由于内联函数和constexpr函数可以在程序中多次定义，所以为了保证其多次定义完全一致，他们通常定义在头文件中。</p>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><h4 id="assert预处理宏"><a href="#assert预处理宏" class="headerlink" title="assert预处理宏"></a>assert预处理宏</h4><p>assert宏在cassert头文件中定义。预处理名字由预处理器而非编译器管理，所以可以直接使用assert而不是std::assert</p>
<p>assert宏用于检查“不能发生”的条件。本质类似于内联函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(expr)</span><br></pre></td></tr></table></figure>
<h4 id="NDEBUG预处理变量"><a href="#NDEBUG预处理变量" class="headerlink" title="NDEBUG预处理变量"></a>NDEBUG预处理变量</h4><p>assert的行为依赖于NDEBUG的预处理变量的状态。如果定义了该变量，则assert什么也不做。</p>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><p>重载函数的选用过程就是函数匹配，这一过程主要分为三步：</p>
<p><em>第一步</em> 是找到重载函数集，也就是<strong>候选函数</strong>们，候选函数具备两个特征：<em>1. 与被调用的函数同名 2. 它的声明在调用点可见。</em></p>
<p><em>第二步</em> 是根据调用提供的实参，确定<strong>可行函数</strong>。可行函数具备两个特征 <em>1. 形参数量和调用提供的实参数量相同 2. 每个实参的类型和对应形参类型相匹配</em></p>
<p>在此步骤中，两个小步骤可能存在以下两种特殊情况：</p>
<ol>
<li>具有<strong>默认实参</strong>的函数比较特殊，在调用该函数时传入的实参数量，可能要少于其实际使用的实参数量。</li>
<li>实参形参匹配的含义可能是具有相同的类型，也可能是实参类型和形参类型满足转换规则（比如高精度转低精度）。</li>
</ol>
<p><em>第三步</em> 是在可行函数中寻找<strong>最匹配的函数</strong>，所谓<em>最匹配</em>的基本思想，就是实参和形参类型最接近。详细说来就是两点：</p>
<ol>
<li>最匹配函数的每个实参匹配都<strong>不劣于</strong>其他可行函数需要的匹配</li>
<li>至少有一个实参的匹配，比其他可行函数提供的匹配都<strong>优秀</strong>。</li>
</ol>
<p>如果这两点无法满足，则编译器将会报错<strong>二义性调用</strong></p>
<h3 id="类型转化的等级排序"><a href="#类型转化的等级排序" class="headerlink" title="类型转化的等级排序"></a>类型转化的等级排序</h3><ol>
<li>下述三种情况都属于最优的精确匹配<ol>
<li>实参与形参类型完全相同</li>
<li>实参从数组类型或函数类型转换为指针类型</li>
<li>实参添加或删除顶层const</li>
</ol>
</li>
<li>const转换实现的匹配</li>
<li>类型提升实现的匹配</li>
<li>算术类型转换、指针转换实现的匹配</li>
<li>类类型转换实现的匹配</li>
</ol>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是指向函数的指针。该函数的类型由返回类型和形参类型有关，<strong>和函数名无关</strong></p>
<p>比如：</p>
<p>如有一函数为<code>bool lengthCompare(cosnt string &amp;, const string &amp;)</code>，则其类型为<code>bool (const string &amp;, const string &amp;)</code>，指向该类型函数的指针可以声明为<code>bool (*pf) (const string &amp;, const string &amp;)</code>。其中，<code>*pf</code>左右的括号必不可少，否则pf只是一个返回值为bool指针的函数，而不是一个指向函数的指针。</p>
<h3 id="使用函数指针"><a href="#使用函数指针" class="headerlink" title="使用函数指针"></a>使用函数指针</h3><p>函数指针的使用和其他指针不太相同，主要有以下这些点：</p>
<ol>
<li><p>函数名作为右值赋值给指针时，函数可以自动转换为指针，取地址符是可选的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两条语句等价</span></span><br><span class="line">pf = lengthCompare;</span><br><span class="line">pf = &amp;lengthCompare;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指向函数的指针调用该函数时，无需提前解引用指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面三条语句等价</span></span><br><span class="line"><span class="keyword">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line"><span class="keyword">bool</span> b2 = (*pf) (<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line"><span class="keyword">bool</span> b3 = <span class="built_in">lengthCompare</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>不同函数类型的指针<strong>不存在转换规则</strong>，且函数指针可以赋值为nullptr。</p>
</li>
<li><p>对于重载函数的指针，指针类型<strong>必须</strong>与候选函数中的某一个<strong>精准匹配</strong>。</p>
</li>
<li><p>函数类型是无法被定义为<strong>形参</strong>的，但是我们可以使用指向函数的指针，也就是函数指针，来作为函数的形参，此时，形参看上去是函数类型，但其实实际上是被视为指针使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两条语句等价</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2, <span class="keyword">bool</span> pf(<span class="keyword">const</span> string &amp;, cosnt string &amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2, <span class="keyword">bool</span> (*pf) (<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;))</span></span>;</span><br></pre></td></tr></table></figure>
<p>此时我们将函数直接作为实参转入，其会自动转换为指针类型。</p>
</li>
<li><p>上面直接使用函数作为形参，使得代码很长，我们使用<strong>类型别名</strong>和<strong>decltype</strong>简化函数指针的代码：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Func和Func2就是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;</span><br><span class="line"><span class="comment">// FuncP和FuncP2是函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncP)</span> <span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;</span><br></pre></td></tr></table></figure>
<p> 需要注意，上面和下面是不等价的，decltype返回函数类型，在此时，是不会将函数类型自动转换为指针类型的。所以只能加上*号，才可以得到函数指针。</p>
<p> 从而得到简单的写法：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2,Func)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2, FuncP2)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数类型无法作为实际的参数，所以在作为形参时，可以自动转换为函数指针，但是函数类型作为返回时，却无法自动转换为函数指针，所以当我们需要返回一个函数指针时，必须显式地将函数返回类型指定为函数指针。使用类型别名可以简单的表示返回的函数指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span> *, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in"><span class="keyword">int</span></span>(*) (<span class="keyword">int</span>*, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>其中，<strong>F</strong>为一个<strong>函数类型</strong>，<strong>PF</strong>为一个<strong>指向函数类型的指针</strong>。注意在定义完返回的函数指针后，正确的函数写法分别有以下两种：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">F *<span class="title">func1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">PF <span class="title">func1</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>前者使用了定义的函数类型，由于无法向形参那样自动转换为函数指针，所以需要显式的加上*号。后者使用了定义的函数指针，所以可以直接接到返回值。</p>
<p>在不使用类型别名时，上面这个返回值为函数指针的函数还可以写为下面的形式：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*<span class="built_in">f1</span>(<span class="keyword">int</span>)) (<span class="keyword">int</span> *, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>首先f1具有形参列表，所以f1是一个函数，其次有*号，说明返回了一个指针，然后指针的类型包括了形参列表，所以指针指向函数，被指向的函数的返回类型是int。</p>
<p>或者使用尾置返回类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> -&gt; <span class="title">int</span> <span class="params">(*)</span> <span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在明确知道返回函数是谁时，可以使用<code>decltype</code>简化上述过程，直接使用<code>deccltype</code>得到已知的返回的函数类型，由于<code>decltype</code>返回的是函数类型而非指针，所以要加上*号来返回一个指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string::size_type <span class="title">sumLength</span><span class="params">(<span class="keyword">const</span> string&amp;, <span class="keyword">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(sumLength) *<span class="built_in">getFun</span>(<span class="keyword">const</span> string&amp;);</span><br></pre></td></tr></table></figure>
<p>getFunc函数返回的就是指向sumLength函数类型的指针。</p>
</li>
</ol>

        
            <div id="toc-article">
                
  <div class="widget-wrap" id="toc-wrap">
    <h3 class="widget-title"><i class="fa fa-toc"></i> 文章目录</h3>
    <div class="widget">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80"><span class="toc-text">函数基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%94%E5%9B%9E"><span class="toc-text">函数的调用和返回</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E7%9B%B8%E5%85%B3"><span class="toc-text">调用相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%9B%B8%E5%85%B3"><span class="toc-text">返回相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82"><span class="toc-text">形参与实参</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82%E5%88%97%E8%A1%A8"><span class="toc-text">函数的形参列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1"><span class="toc-text">局部对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%AF%B9%E8%B1%A1"><span class="toc-text">自动对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">局部静态变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-text">函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E5%BC%8F%E7%BC%96%E8%AF%91"><span class="toc-text">分离式编译</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-text">值传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-text">引用传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="toc-text">const形参和实参</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82"><span class="toc-text">数组形参</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82%E5%92%8Cconst"><span class="toc-text">数组形参和const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%E5%BD%A2%E5%8F%82"><span class="toc-text">数组引用形参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">传递多维数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main%EF%BC%9A%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="toc-text">main：处理命令行选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">含有可变形参的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#initializer-list"><span class="toc-text">initializer_list</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%81%E7%95%A5%E7%AC%A6%E5%BD%A2%E5%8F%82"><span class="toc-text">省略符形参</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%92%8Creturn%E7%B1%BB%E5%9E%8B"><span class="toc-text">返回类型和return类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ereturn%E7%9A%84%E6%9C%89%E6%97%A0"><span class="toc-text">关于return的有无</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E5%8F%8D%E6%82%94%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E6%88%96%E6%8C%87%E9%92%88"><span class="toc-text">不要反悔局部对象的引用或指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">返回类类型的函数和调用运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E5%B7%A6%E5%80%BC"><span class="toc-text">引用返回左值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%88C-11%EF%BC%89"><span class="toc-text">列表初始化返回值（C++11）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="toc-text">main主函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-text">返回数组指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">声明一个返回数组指针的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E7%BD%AE%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%EF%BC%88C-11%EF%BC%89"><span class="toc-text">尾置返回类型（C++11）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8decltype"><span class="toc-text">使用decltype</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-text">函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E7%B1%BB%E5%9E%8B%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C"><span class="toc-text">形参类型究竟是否相同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E5%92%8Cconst%E5%BD%A2%E5%8F%82"><span class="toc-text">重载函数和const形参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E5%92%8Cconst-cast"><span class="toc-text">重载函数和const_cast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D%EF%BC%88%E9%87%8D%E8%BD%BD%E7%A1%AE%E5%AE%9A%EF%BC%89"><span class="toc-text">函数匹配（重载确定）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">重载和作用域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-text">特殊用途语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="toc-text">默认实参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8Cconstexpr%E5%87%BD%E6%95%B0"><span class="toc-text">内联函数和constexpr函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%B8%AE%E5%8A%A9"><span class="toc-text">调试帮助</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#assert%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F"><span class="toc-text">assert预处理宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NDEBUG%E9%A2%84%E5%A4%84%E7%90%86%E5%8F%98%E9%87%8F"><span class="toc-text">NDEBUG预处理变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="toc-text">函数匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E7%9A%84%E7%AD%89%E7%BA%A7%E6%8E%92%E5%BA%8F"><span class="toc-text">类型转化的等级排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">使用函数指针</span></a></li></ol></li></ol>
    </div>
  </div>


            </div>
        
        
          <blockquote id="copyright">
              <p>原文链接: <a href="https://zijian.wang/2021/07/11/《C++ Primer第五版》阅读过程查漏补缺 chapter6/">https://zijian.wang/2021/07/11/《C++ Primer第五版》阅读过程查漏补缺 chapter6/</a></p>
              <p>版权声明: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          
    <div class="article-reward">
        <a id="reward-btn" href="javascript:;">打赏</a>
        <div id="reward-content">
            <h6 class="reward-tit">“感谢你的支持，我会继续努力！”</h6>
            <div>
                <div class="reward-code">
                    <img class="type-code" src="/css/images/wechat.jpg">
                    <img class="er-code" src="/css/images/wechat-pay.jpg">
                </div>
                <div class="reward-code">
                    <img class="type-code" src="/css/images/alipay.jpg">
                    <img class="er-code" src="/css/images/alipay-pay.jpg">
                </div>
            </div>
            <p class="reward-desc">扫码打赏，感谢支持</p>
        </div>
    </div>


          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
        
<nav id="article-nav">
  
    <a href="/2021/07/19/29.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">newer</strong>
      <div class="article-nav-title">
        
          《剑指offer》 29. 顺时针打印矩阵
        
      </div>
    </a>
  
  
    <a href="/2021/07/06/28.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">older</strong>
      <div class="article-nav-title">《剑指offer》 28. 对称的二叉树</div>
    </a>
  
</nav>

      
      
        






  <div id="SOHUCS" sid="2021/07/11/《C++ Primer第五版》阅读过程查漏补缺 chapter6/"></div>


      
    </footer>
  </div>
</article>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> 最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/17/XRCE-DDS%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88epromisa%E5%AE%9E%E7%8E%B0%EF%BC%89/">XRCE-DDS源码阅读（epromisa实现）</a>
          </li>
        
          <li>
            <a href="/2021/12/30/%E5%AF%B9MQTT%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%88%86%E6%9E%90%E4%B8%8E%E5%BB%BA%E6%A8%A1/">对MQTT的形式化分析和建模</a>
          </li>
        
          <li>
            <a href="/2021/12/13/git%E5%AD%A6%E4%B9%A0/">git学习</a>
          </li>
        
          <li>
            <a href="/2021/12/01/%E5%AF%B9ROS2%E7%9A%84DDS%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%88%86%E6%9E%90/">对ROS2的DDS的形式化分析</a>
          </li>
        
          <li>
            <a href="/2021/10/19/%E6%97%B6%E9%97%B4%E8%87%AA%E5%8A%A8%E6%9C%BA/">时间自动机</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> 标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/DDS/" style="font-size: 15px;">DDS</a> <a href="/tags/Leetcode/" style="font-size: 20px;">Leetcode</a> <a href="/tags/ROS/" style="font-size: 10px;">ROS</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hash/" style="font-size: 13.75px;">hash</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" style="font-size: 11.25px;">二分查找</a> <a href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" style="font-size: 10px;">前缀和</a> <a href="/tags/%E5%89%91%E6%8C%87offer/" style="font-size: 18.75px;">剑指offer</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 12.5px;">动态规划</a> <a href="/tags/%E5%8D%8F%E8%AE%AE%E9%98%85%E8%AF%BB/" style="font-size: 12.5px;">协议阅读</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 11.25px;">双指针</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FRTOS/" style="font-size: 10px;">嵌入式RTOS</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 11.25px;">工具</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">工具使用</a> <a href="/tags/%E5%BD%A2%E5%BC%8F%E5%8C%96/" style="font-size: 10px;">形式化</a> <a href="/tags/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81/" style="font-size: 11.25px;">形式化验证</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">操作系统，环境配置</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 12.5px;">数据库</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 13.75px;">数组</a> <a href="/tags/%E6%A8%A1%E5%9E%8B%E6%A3%80%E6%B5%8B/" style="font-size: 11.25px;">模型检测</a> <a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" style="font-size: 11.25px;">源码阅读</a> <a href="/tags/%E7%9F%A9%E9%98%B5/" style="font-size: 13.75px;">矩阵</a> <a href="/tags/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/" style="font-size: 16.25px;">研究方向</a> <a href="/tags/%E7%A7%91%E7%A0%94%E5%91%A8%E8%AE%B0/" style="font-size: 10px;">科研周记</a> <a href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98/" style="font-size: 20px;">算法题</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a> <a href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" style="font-size: 11.25px;">论文阅读</a> <a href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%8CROS2/" style="font-size: 10px;">论文阅读，ROS2</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 17.5px;">读书笔记</a> <a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 10px;">贪心</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-classify"></i> 分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-%E8%A7%86%E9%A2%91%E8%AF%BE/">C++视频课</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode%E5%88%B7%E9%A2%98/">Leetcode刷题</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ROS/">ROS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ROS2%E4%B8%8EMicro-ROS/">ROS2与Micro-ROS</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E3%80%8AC-Primer%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">《C++ Primer》阅读笔记</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">刷题记录</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/">工具学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/">数据库学习</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%91%E7%A0%94%E5%91%A8%E8%AE%B0/">科研周记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/">计算机网络学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/">软件安装</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> 归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">2022年03月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">2021年12月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">2021年10月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">2021年09月</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">2021年07月</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">2021年06月</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">2021年05月</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">2021年04月</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">2021年01月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020年11月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020年10月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">2018年06月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">2018年03月</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> 标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DDS/" rel="tag">DDS</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a><span class="tag-list-count">43</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ROS/" rel="tag">ROS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hash/" rel="tag">hash</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" rel="tag">前缀和</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%91%E6%8C%87offer/" rel="tag">剑指offer</a><span class="tag-list-count">25</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%8F%E8%AE%AE%E9%98%85%E8%AF%BB/" rel="tag">协议阅读</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FRTOS/" rel="tag">嵌入式RTOS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" rel="tag">工具使用</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%A2%E5%BC%8F%E5%8C%96/" rel="tag">形式化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81/" rel="tag">形式化验证</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="tag">操作系统，环境配置</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9E%8B%E6%A3%80%E6%B5%8B/" rel="tag">模型检测</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" rel="tag">源码阅读</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A9%E9%98%B5/" rel="tag">矩阵</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91/" rel="tag">研究方向</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%91%E7%A0%94%E5%91%A8%E8%AE%B0/" rel="tag">科研周记</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98/" rel="tag">算法题</a><span class="tag-list-count">43</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" rel="tag">论文阅读</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%EF%BC%8CROS2/" rel="tag">论文阅读，ROS2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-link"></i> 友情链接</h3>
    <div class="widget">
      <ul>
      
        <li>
          <a target="_blank" rel="noopener" href="https://www.guanyuqian.com/">G-Blog（关师兄的博客）</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="https://imvector.github.io/">峰哥的博客</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="https://amyzhoucc.github.io/">豆豆龙（zcc师姐的博客）</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="https://mchen0607.github.io/">闽哥的博客</a>
        </li>
      
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/sitemap.xml">网站地图</a>
        <span> | </span><a href="/about/">联系博主</a>
      </p>
      
        <p>
          <i class="fa fa-visitors"></i>
          <i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>
          ，
          <i class="fa fa-views"></i>
          <i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>
        </p>
      
      <p>
        <span>Copyright &copy; 2022 Eric Wang.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        
            <span>Count by <a href="http://busuanzi.ibruce.info/" target="_blank">busuanzi.</a></span>
        
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>

    </div>
    
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/search.json.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>






  
<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



  
<script src="/localshare/js/social-share.js"></script>

  
<script src="/localshare/js/qrcode.js"></script>

















  <script>
    window._config = { showScore: true };
    (function(){
      var appid = 'cyvoLETLk';
      var conf = '9be4582e027b7ddeb93c7cb6571009a5';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var nodes =document.getElementsByTagName("head")[0]||document.head||document.documentElement;
      if (/(Android|iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) && width < 750) {
          window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
      }
      else {
        var loadJs=function(d,a){
          var b=document.createElement("script");b.setAttribute("type","text/javascript");
          b.setAttribute("charset","UTF-8");
          b.setAttribute("src",d);
          if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}
          nodes.appendChild(b)
        };
        loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})});
      }
      var loadCss = function(cssString){
        var style=document.createElement("style");
        style.setAttribute("type", "text/css");
        if(style.styleSheet){// IE
            style.styleSheet.cssText = cssString;
        } else {// w3c
            var cssText = document.createTextNode(cssString);
            style.appendChild(cssText);
        }
        nodes.appendChild(style);
      }
    })();
    function removeElement(_element){
         var _parentElement = _element.parentNode;
         if(_parentElement){
                _parentElement.removeChild(_element);
         }
    }
    var removeAD = document.createElement("div");
    removeAD.id = 'removeAD';
    var adInterval1 = setInterval(function() {
      if(document.querySelector("#feedAv")){
        document.querySelector("[node-type=cmt-list]").appendChild(removeAD);
        document.querySelector("#removeAD").appendChild(document.querySelector("#feedAv"));
        //- removeElement(document.querySelectorAll("#feedAv")[0]);
        var feedAv = document.querySelector("#feedAv").children;
        for( item of feedAv){
          item.style.display = 'none'
        }
        document.querySelector("#removeAD").style.display="none"
        clearInterval(adInterval1);
      }
    },1000);
    var adInterval2 = setInterval(function() {
      if(document.querySelector("#pop_ad")){
        removeElement(document.querySelector("#pop_ad"));
        clearInterval(adInterval2);
      }
    }, 1000);
  </script>
  
<script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>





  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>
  <script src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML" async type="text/javascript"></script>

  </div>
</body>
</html>